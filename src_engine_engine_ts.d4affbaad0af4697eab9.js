/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is not neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkmdt_charts"] = self["webpackChunkmdt_charts"] || []).push([["src_engine_engine_ts"],{

/***/ "./src/engine/block/block.ts":
/*!***********************************!*\
  !*** ./src/engine/block/block.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Block\": () => /* binding */ Block\n/* harmony export */ });\n/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-selection */ \"./node_modules/d3-selection/src/select.js\");\n/* harmony import */ var _features_tipBox_tipBox__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../features/tipBox/tipBox */ \"./src/engine/features/tipBox/tipBox.ts\");\n/* harmony import */ var _helpers_helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/helper */ \"./src/engine/helpers/helper.ts\");\n/* harmony import */ var _namesManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../namesManager */ \"./src/engine/namesManager.ts\");\n/* harmony import */ var _polarNotation_donut_donut__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../polarNotation/donut/donut */ \"./src/engine/polarNotation/donut/donut.ts\");\n/* harmony import */ var _transitionManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../transitionManager */ \"./src/engine/transitionManager.ts\");\n/* harmony import */ var _blockHelper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./blockHelper */ \"./src/engine/block/blockHelper.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass Block {\r\n    constructor(cssClass, parentElement, blockId, filterEventManager, transitions = null) {\r\n        this.chartBlockClass = 'chart-block';\r\n        this.chartGroupClass = 'chart-group';\r\n        this.wrapperCssClasses = _helpers_helper__WEBPACK_IMPORTED_MODULE_1__.Helper.getCssClassesArray(cssClass);\r\n        this.svgCssClasses = _helpers_helper__WEBPACK_IMPORTED_MODULE_1__.Helper.getCssClassesArray(cssClass);\r\n        this.wrapperCssClasses = _blockHelper__WEBPACK_IMPORTED_MODULE_5__.BlockHelper.getFormattedCssClassesForWrapper(this.wrapperCssClasses);\r\n        this.parentElement = parentElement;\r\n        this.parentElementSelection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__.default)(parentElement);\r\n        this.id = blockId;\r\n        this.transitionManager = new _transitionManager__WEBPACK_IMPORTED_MODULE_4__.TransitionManager(this, transitions);\r\n        this.filterEventManager = filterEventManager;\r\n    }\r\n    renderSvg(blockSize) {\r\n        this.getWrapper()\r\n            .append('svg')\r\n            .attr('width', blockSize.width)\r\n            .attr('height', blockSize.height)\r\n            .attr('class', this.svgCssClasses.join(' ') + ' ' + _namesManager__WEBPACK_IMPORTED_MODULE_2__.NamesManager.getClassName('svg-chart'));\r\n    }\r\n    renderWrapper(blockSize) {\r\n        this.wrapper = this.parentElementSelection\r\n            .append('div')\r\n            .attr('class', this.wrapperCssClasses.join(' '))\r\n            .style('width', blockSize.width + 'px')\r\n            .style('height', blockSize.height + 'px')\r\n            .style('position', 'relative');\r\n    }\r\n    getSvg() {\r\n        return this.getWrapper().select(`svg.${_namesManager__WEBPACK_IMPORTED_MODULE_2__.NamesManager.getClassName('svg-chart')}`);\r\n    }\r\n    getWrapper() {\r\n        return this.wrapper;\r\n    }\r\n    renderChartsBlock() {\r\n        this.getSvg()\r\n            .append('g')\r\n            .attr('class', this.chartBlockClass);\r\n    }\r\n    getChartBlock() {\r\n        return this.getSvg().select(`.${this.chartBlockClass}`);\r\n    }\r\n    getChartGroup(chartIndex) {\r\n        let group = this.getChartBlock().select(`.${this.chartGroupClass}-${chartIndex}`);\r\n        if (group.empty()) {\r\n            group = this.getChartBlock()\r\n                .append('g')\r\n                .attr('class', `${this.chartGroupClass}-${chartIndex}`);\r\n        }\r\n        return group;\r\n    }\r\n    renderChartClipPath(margin, blockSize) {\r\n        const attributes = _blockHelper__WEBPACK_IMPORTED_MODULE_5__.BlockHelper.getClipPathAttributes(blockSize, margin);\r\n        this.renderDefs()\r\n            .append('clipPath')\r\n            .attr('id', this.getClipPathId())\r\n            .append('rect')\r\n            .attr('x', attributes.x)\r\n            .attr('y', attributes.y)\r\n            .attr('width', attributes.width)\r\n            .attr('height', attributes.height);\r\n    }\r\n    updateChartClipPath(margin, blockSize) {\r\n        const attributes = _blockHelper__WEBPACK_IMPORTED_MODULE_5__.BlockHelper.getClipPathAttributes(blockSize, margin);\r\n        this.renderDefs()\r\n            .select('clipPath')\r\n            .select('rect')\r\n            .attr('x', attributes.x)\r\n            .attr('y', attributes.y)\r\n            .attr('width', attributes.width)\r\n            .attr('height', attributes.height);\r\n    }\r\n    getClipPathId() {\r\n        return _namesManager__WEBPACK_IMPORTED_MODULE_2__.NamesManager.getId('clip-path', this.id);\r\n    }\r\n    renderDefs() {\r\n        let defs = this.getSvg()\r\n            .select('defs');\r\n        if (defs.empty())\r\n            defs = this.getSvg().append('defs');\r\n        return defs;\r\n    }\r\n    removeMouseEvents() {\r\n        const tipBoxes = this.getSvg().selectAll(`.${_features_tipBox_tipBox__WEBPACK_IMPORTED_MODULE_0__.TipBox.tipBoxClass}`);\r\n        tipBoxes.on('mousemove', null);\r\n        tipBoxes.on('mouseover', null);\r\n        tipBoxes.on('mouseleave', null);\r\n        tipBoxes.on('click', null);\r\n        const arcItems = _polarNotation_donut_donut__WEBPACK_IMPORTED_MODULE_3__.Donut.getAllArcGroups(this);\r\n        arcItems.on('mouseover', null);\r\n        arcItems.on('mouseleave', null);\r\n        arcItems.on('mousemove', null);\r\n        arcItems.on('click', null);\r\n    }\r\n    clearWrapper() {\r\n        this.getWrapper().selectAll('*').remove();\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/block/block.ts?");

/***/ }),

/***/ "./src/engine/block/blockHelper.ts":
/*!*****************************************!*\
  !*** ./src/engine/block/blockHelper.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BlockHelper\": () => /* binding */ BlockHelper\n/* harmony export */ });\n/* harmony import */ var _helpers_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/helper */ \"./src/engine/helpers/helper.ts\");\n\r\nclass BlockHelper {\r\n    static getClipPathAttributes(blockSize, margin) {\r\n        const outSize = 9;\r\n        return {\r\n            x: margin.left - outSize,\r\n            y: margin.top - outSize,\r\n            width: _helpers_helper__WEBPACK_IMPORTED_MODULE_0__.Helper.getValueOrZero(blockSize.width - margin.left - margin.right) + outSize * 2,\r\n            height: _helpers_helper__WEBPACK_IMPORTED_MODULE_0__.Helper.getValueOrZero(blockSize.height - margin.top - margin.bottom) + outSize * 2\r\n        };\r\n    }\r\n    static getFormattedCssClassesForWrapper(cssClasses) {\r\n        const wrapperClasses = [];\r\n        cssClasses.forEach(cssClass => {\r\n            wrapperClasses.push(cssClass + '-wrapper');\r\n        });\r\n        return wrapperClasses;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/block/blockHelper.ts?");

/***/ }),

/***/ "./src/engine/contentManager.ts":
/*!**************************************!*\
  !*** ./src/engine/contentManager.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ContentManager\": () => /* binding */ ContentManager\n/* harmony export */ });\n/* harmony import */ var _twoDimensionalNotation_twoDimensionalManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./twoDimensionalNotation/twoDimensionalManager */ \"./src/engine/twoDimensionalNotation/twoDimensionalManager.ts\");\n/* harmony import */ var _polarNotation_polarManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./polarNotation/polarManager */ \"./src/engine/polarNotation/polarManager.ts\");\n/* harmony import */ var _intervalNotation_intervalManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./intervalNotation/intervalManager */ \"./src/engine/intervalNotation/intervalManager.ts\");\n\r\n\r\n\r\nclass ContentManager {\r\n    static render(model, data, engine) {\r\n        if (model.options.type === '2d')\r\n            _twoDimensionalNotation_twoDimensionalManager__WEBPACK_IMPORTED_MODULE_0__.TwoDimensionalManager.render(engine, model);\r\n        else if (model.options.type === 'polar')\r\n            _polarNotation_polarManager__WEBPACK_IMPORTED_MODULE_1__.PolarManager.render(engine, model);\r\n        else if (model.options.type === 'interval')\r\n            _intervalNotation_intervalManager__WEBPACK_IMPORTED_MODULE_2__.IntervalManager.render(engine.block, model, data);\r\n    }\r\n    static updateData(block, model, newData) {\r\n        if (model.options.type === '2d') {\r\n            _twoDimensionalNotation_twoDimensionalManager__WEBPACK_IMPORTED_MODULE_0__.TwoDimensionalManager.updateData(block, model, newData);\r\n        }\r\n        else if (model.options.type === 'polar') {\r\n            _polarNotation_polarManager__WEBPACK_IMPORTED_MODULE_1__.PolarManager.updateData(block, model, newData);\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/contentManager.ts?");

/***/ }),

/***/ "./src/engine/elementHighlighter/elementHighlighter.ts":
/*!*************************************************************!*\
  !*** ./src/engine/elementHighlighter/elementHighlighter.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ElementHighlighter\": () => /* binding */ ElementHighlighter\n/* harmony export */ });\n/* harmony import */ var d3_ease__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-ease */ \"./node_modules/d3-ease/src/linear.js\");\n/* harmony import */ var d3_transition__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-transition */ \"./node_modules/d3-transition/src/index.js\");\n/* harmony import */ var _polarNotation_donut_DonutHelper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../polarNotation/donut/DonutHelper */ \"./src/engine/polarNotation/donut/DonutHelper.ts\");\n/* harmony import */ var _helpers_domHelper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers/domHelper */ \"./src/engine/helpers/domHelper.ts\");\n/* harmony import */ var _namesManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../namesManager */ \"./src/engine/namesManager.ts\");\n/* harmony import */ var _polarNotation_donut_donut__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../polarNotation/donut/donut */ \"./src/engine/polarNotation/donut/donut.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\nclass ElementHighlighter {\r\n    static renderShadowFilter(block) {\r\n        const filterId = _namesManager__WEBPACK_IMPORTED_MODULE_3__.NamesManager.getId('shadow', block.id);\r\n        let filter = block.renderDefs()\r\n            .select(`filter#${filterId}`);\r\n        if (filter.empty())\r\n            filter = block.renderDefs()\r\n                .append('filter')\r\n                .attr('id', filterId)\r\n                .attr('width', '300%')\r\n                .attr('height', '300%')\r\n                .attr('x', '-100%')\r\n                .attr('y', '-100%');\r\n        if (filter.select('feDropShadow').empty())\r\n            filter.append('feDropShadow')\r\n                .attr('dx', 0)\r\n                .attr('dy', 0)\r\n                .attr('flood-color', 'rgba(0, 0, 0, 0.5)')\r\n                .attr('stdDeviation', 6);\r\n        return filter;\r\n    }\r\n    static removeFilter(elemSelection) {\r\n        elemSelection.style('filter', null);\r\n    }\r\n    static setFilter(elemSelection, block) {\r\n        elemSelection.style('filter', `url(#${_namesManager__WEBPACK_IMPORTED_MODULE_3__.NamesManager.getId('shadow', block.id)})`);\r\n    }\r\n    static makeArcClone(segment, block) {\r\n        const clone = segment\r\n            .clone(true)\r\n            .style('pointer-events', 'none')\r\n            .raise()\r\n            .classed(`${_polarNotation_donut_donut__WEBPACK_IMPORTED_MODULE_4__.Donut.arcItemClass}`, false)\r\n            .classed(`${_polarNotation_donut_donut__WEBPACK_IMPORTED_MODULE_4__.Donut.arcItemClass}-clone`, true)\r\n            .remove();\r\n        block.getSvg().select(`.${_polarNotation_donut_donut__WEBPACK_IMPORTED_MODULE_4__.Donut.clonesGroupClass}`).append(function () { return clone.node(); });\r\n        return clone;\r\n    }\r\n    static removeDonutArcClones(block) {\r\n        _polarNotation_donut_donut__WEBPACK_IMPORTED_MODULE_4__.Donut.getAllArcClones(block).remove();\r\n    }\r\n    static renderArcCloneAndHighlight(block, margin, arcSelection, blockSize, donutThickness) {\r\n        const clones = this.makeArcClone(arcSelection, block);\r\n        this.toggleDonutHighlightState(arcSelection, margin, blockSize, donutThickness, block.transitionManager.durations.donutHover, true);\r\n        this.toggleDonutHighlightState(clones, margin, blockSize, donutThickness, block.transitionManager.durations.donutHover, true);\r\n    }\r\n    static toggleDonutHighlightState(segment, margin, blockSize, donutThickness, transitionDuration, on) {\r\n        let scaleSize = 0;\r\n        if (on)\r\n            scaleSize = 5; // Если нужно выделить сегмент, то scaleSize не равен нулю и отображается увеличенным\r\n        segment\r\n            .select('path')\r\n            .interrupt()\r\n            .transition()\r\n            .duration(transitionDuration)\r\n            .ease(d3_ease__WEBPACK_IMPORTED_MODULE_5__.linear)\r\n            .attr('d', (d, i) => _polarNotation_donut_DonutHelper__WEBPACK_IMPORTED_MODULE_1__.DonutHelper.getArcGeneratorObject(blockSize, margin, donutThickness)\r\n            .outerRadius(_polarNotation_donut_DonutHelper__WEBPACK_IMPORTED_MODULE_1__.DonutHelper.getOuterRadius(margin, blockSize) + scaleSize)\r\n            .innerRadius(_polarNotation_donut_DonutHelper__WEBPACK_IMPORTED_MODULE_1__.DonutHelper.getOuterRadius(margin, blockSize) - donutThickness - scaleSize)(d, i));\r\n    }\r\n    static toggleActivityStyle(elementSelection, isActive) {\r\n        elementSelection.classed(this.inactiveElemClass, !isActive);\r\n    }\r\n    static removeDonutHighlightingByKeys(arcSegments, keyFieldName, keyValues, margin, blockSize, donutThickness) {\r\n        const segments = _helpers_domHelper__WEBPACK_IMPORTED_MODULE_2__.DomHelper.getChartElementsByKeys(arcSegments, true, keyFieldName, keyValues, _helpers_domHelper__WEBPACK_IMPORTED_MODULE_2__.SelectionCondition.Exclude);\r\n        this.toggleDonutHighlightState(segments, margin, blockSize, donutThickness, 0, false);\r\n    }\r\n    static remove2DChartsFullHighlighting(block, charts, transitionDuration = 0) {\r\n        charts.forEach(chart => {\r\n            const elems = _helpers_domHelper__WEBPACK_IMPORTED_MODULE_2__.DomHelper.get2DChartElements(block, chart);\r\n            if (chart.type === 'area' || chart.type === 'line') {\r\n                elems.call(this.scaleHandler, false, transitionDuration);\r\n            }\r\n            else {\r\n                this.removeFilter(elems);\r\n            }\r\n        });\r\n    }\r\n    static highlight2DElementsHover(block, keyFieldName, keyValue, charts, transitionDuration) {\r\n        this.removeUnselected2DHighlight(block, keyFieldName, charts, transitionDuration);\r\n        this.highlightElementsOf2D(block, keyFieldName, keyValue, charts, transitionDuration);\r\n    }\r\n    static removeUnselected2DHighlight(block, keyFieldName, charts, transitionDuration) {\r\n        charts.forEach(chart => {\r\n            const elems = _helpers_domHelper__WEBPACK_IMPORTED_MODULE_2__.DomHelper.get2DChartElements(block, chart);\r\n            const selectedElems = _helpers_domHelper__WEBPACK_IMPORTED_MODULE_2__.DomHelper.getChartElementsByKeys(elems, chart.isSegmented, keyFieldName, block.filterEventManager.getSelectedKeys(), _helpers_domHelper__WEBPACK_IMPORTED_MODULE_2__.SelectionCondition.Exclude);\r\n            if (chart.type === 'area' || chart.type === 'line') {\r\n                selectedElems.call(this.scaleHandler, false, transitionDuration);\r\n            }\r\n            else {\r\n                this.removeFilter(selectedElems);\r\n            }\r\n        });\r\n    }\r\n    static highlightElementsOf2D(block, keyFieldName, keyValue, charts, transitionDuration) {\r\n        const filterId = _namesManager__WEBPACK_IMPORTED_MODULE_3__.NamesManager.getId('shadow', block.id);\r\n        this.change2DHighlightState(block, keyFieldName, keyValue, charts, true, filterId, transitionDuration);\r\n    }\r\n    static remove2DHighlightingByKey(block, keyFieldName, keyValue, charts, transitionDuration) {\r\n        this.change2DHighlightState(block, keyFieldName, keyValue, charts, false, null, transitionDuration);\r\n    }\r\n    static change2DHighlightState(block, keyFieldName, keyValue, charts, isHighlight, filterId, transitionDuration) {\r\n        charts.forEach(chart => {\r\n            const elems = _helpers_domHelper__WEBPACK_IMPORTED_MODULE_2__.DomHelper.get2DChartElements(block, chart);\r\n            const selectedElems = _helpers_domHelper__WEBPACK_IMPORTED_MODULE_2__.DomHelper.get2DElementsByKey(elems, chart.isSegmented, keyFieldName, keyValue);\r\n            if (chart.type === 'area' || chart.type === 'line') {\r\n                selectedElems.call(this.scaleHandler, isHighlight, transitionDuration);\r\n            }\r\n            else {\r\n                if (isHighlight)\r\n                    selectedElems.style('filter', `url(#${filterId})`);\r\n                else\r\n                    this.removeFilter(selectedElems);\r\n            }\r\n        });\r\n    }\r\n    static scaleHandler(elementSelection, isScaled, transitionDuration = 0) {\r\n        const animationName = 'size-scale';\r\n        elementSelection.nodes().forEach(node => {\r\n            (0,d3_transition__WEBPACK_IMPORTED_MODULE_0__.interrupt)(node, animationName);\r\n        });\r\n        let elementsHandler = elementSelection;\r\n        if (transitionDuration > 0) {\r\n            elementsHandler = elementsHandler.interrupt().transition(animationName)\r\n                .duration(transitionDuration)\r\n                .ease(d3_ease__WEBPACK_IMPORTED_MODULE_5__.linear);\r\n        }\r\n        elementsHandler\r\n            .attr('r', isScaled ? 6 : 4)\r\n            .style('stroke-width', (isScaled ? 4.3 : 3) + 'px');\r\n    }\r\n    static removeCloneForElem(block, keyFieldName, selectedSegment) {\r\n        const clone = _polarNotation_donut_donut__WEBPACK_IMPORTED_MODULE_4__.Donut.getAllArcClones(block)\r\n            .filter((d) => d.data[keyFieldName] === selectedSegment.datum().data[keyFieldName]);\r\n        clone.remove();\r\n    }\r\n}\r\nElementHighlighter.inactiveElemClass = 'charts-opacity-inactive';\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/elementHighlighter/elementHighlighter.ts?");

/***/ }),

/***/ "./src/engine/elementHighlighter/selectHighlighter.ts":
/*!************************************************************!*\
  !*** ./src/engine/elementHighlighter/selectHighlighter.ts ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SelectHighlighter\": () => /* binding */ SelectHighlighter\n/* harmony export */ });\n/* harmony import */ var _features_legend_legend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../features/legend/legend */ \"./src/engine/features/legend/legend.ts\");\n/* harmony import */ var _helpers_domHelper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/domHelper */ \"./src/engine/helpers/domHelper.ts\");\n/* harmony import */ var _polarNotation_donut_donut__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../polarNotation/donut/donut */ \"./src/engine/polarNotation/donut/donut.ts\");\n/* harmony import */ var _polarNotation_donut_DonutHelper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../polarNotation/donut/DonutHelper */ \"./src/engine/polarNotation/donut/DonutHelper.ts\");\n/* harmony import */ var _elementHighlighter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./elementHighlighter */ \"./src/engine/elementHighlighter/elementHighlighter.ts\");\n\r\n\r\n\r\n\r\n\r\nclass SelectHighlighter {\r\n    static click2DHandler(multySelection, appendKey, keyValue, block, options) {\r\n        _elementHighlighter__WEBPACK_IMPORTED_MODULE_4__.ElementHighlighter.renderShadowFilter(block);\r\n        if (!appendKey) {\r\n            _elementHighlighter__WEBPACK_IMPORTED_MODULE_4__.ElementHighlighter.remove2DHighlightingByKey(block, options.data.keyField.name, keyValue, options.charts, 0);\r\n            return;\r\n        }\r\n        if (multySelection) {\r\n            _elementHighlighter__WEBPACK_IMPORTED_MODULE_4__.ElementHighlighter.highlightElementsOf2D(block, options.data.keyField.name, keyValue, options.charts, 0);\r\n        }\r\n        else {\r\n            _elementHighlighter__WEBPACK_IMPORTED_MODULE_4__.ElementHighlighter.removeUnselected2DHighlight(block, options.data.keyField.name, options.charts, 0);\r\n            _elementHighlighter__WEBPACK_IMPORTED_MODULE_4__.ElementHighlighter.highlightElementsOf2D(block, options.data.keyField.name, keyValue, options.charts, 0);\r\n        }\r\n    }\r\n    static clickPolarHandler(multySelection, appendKey, selectedSegment, selectedKeys, margin, blockSize, block, options, arcItems, donutSettings) {\r\n        const donutThickness = _polarNotation_donut_DonutHelper__WEBPACK_IMPORTED_MODULE_3__.DonutHelper.getThickness(donutSettings, blockSize, margin);\r\n        _elementHighlighter__WEBPACK_IMPORTED_MODULE_4__.ElementHighlighter.renderShadowFilter(block);\r\n        if (!appendKey) {\r\n            _elementHighlighter__WEBPACK_IMPORTED_MODULE_4__.ElementHighlighter.toggleDonutHighlightState(selectedSegment, margin, blockSize, donutThickness, block.transitionManager.durations.donutHover, false);\r\n            _elementHighlighter__WEBPACK_IMPORTED_MODULE_4__.ElementHighlighter.removeCloneForElem(block, options.data.keyField.name, selectedSegment);\r\n            if (selectedKeys.length > 0) {\r\n                _elementHighlighter__WEBPACK_IMPORTED_MODULE_4__.ElementHighlighter.toggleActivityStyle(selectedSegment, false);\r\n                _elementHighlighter__WEBPACK_IMPORTED_MODULE_4__.ElementHighlighter.toggleActivityStyle(_features_legend_legend__WEBPACK_IMPORTED_MODULE_0__.Legend.getItemsByKeys(block, selectedKeys, _helpers_domHelper__WEBPACK_IMPORTED_MODULE_1__.SelectionCondition.Exclude), false);\r\n            }\r\n            else {\r\n                _elementHighlighter__WEBPACK_IMPORTED_MODULE_4__.ElementHighlighter.toggleActivityStyle(_polarNotation_donut_donut__WEBPACK_IMPORTED_MODULE_2__.Donut.getAllArcGroups(block), true);\r\n                _elementHighlighter__WEBPACK_IMPORTED_MODULE_4__.ElementHighlighter.toggleActivityStyle(_features_legend_legend__WEBPACK_IMPORTED_MODULE_0__.Legend.getItemsByKeys(block, [], _helpers_domHelper__WEBPACK_IMPORTED_MODULE_1__.SelectionCondition.Exclude), true);\r\n            }\r\n            return;\r\n        }\r\n        if (multySelection) {\r\n            _elementHighlighter__WEBPACK_IMPORTED_MODULE_4__.ElementHighlighter.removeCloneForElem(block, options.data.keyField.name, selectedSegment);\r\n            _elementHighlighter__WEBPACK_IMPORTED_MODULE_4__.ElementHighlighter.renderArcCloneAndHighlight(block, margin, selectedSegment, blockSize, donutThickness);\r\n            _elementHighlighter__WEBPACK_IMPORTED_MODULE_4__.ElementHighlighter.toggleActivityStyle(selectedSegment, true);\r\n            _elementHighlighter__WEBPACK_IMPORTED_MODULE_4__.ElementHighlighter.toggleActivityStyle(_helpers_domHelper__WEBPACK_IMPORTED_MODULE_1__.DomHelper.getChartElementsByKeys(_polarNotation_donut_donut__WEBPACK_IMPORTED_MODULE_2__.Donut.getAllArcGroups(block), true, options.data.keyField.name, selectedKeys, _helpers_domHelper__WEBPACK_IMPORTED_MODULE_1__.SelectionCondition.Exclude), false);\r\n        }\r\n        else {\r\n            _elementHighlighter__WEBPACK_IMPORTED_MODULE_4__.ElementHighlighter.removeDonutHighlightingByKeys(arcItems, options.data.keyField.name, selectedKeys, margin, blockSize, donutThickness);\r\n            _elementHighlighter__WEBPACK_IMPORTED_MODULE_4__.ElementHighlighter.removeDonutArcClones(block);\r\n            _elementHighlighter__WEBPACK_IMPORTED_MODULE_4__.ElementHighlighter.toggleActivityStyle(_polarNotation_donut_donut__WEBPACK_IMPORTED_MODULE_2__.Donut.getAllArcGroups(block), false);\r\n            _elementHighlighter__WEBPACK_IMPORTED_MODULE_4__.ElementHighlighter.toggleActivityStyle(selectedSegment, true);\r\n            _elementHighlighter__WEBPACK_IMPORTED_MODULE_4__.ElementHighlighter.renderArcCloneAndHighlight(block, margin, selectedSegment, blockSize, donutThickness);\r\n        }\r\n        _elementHighlighter__WEBPACK_IMPORTED_MODULE_4__.ElementHighlighter.toggleActivityStyle(_features_legend_legend__WEBPACK_IMPORTED_MODULE_0__.Legend.getItemsByKeys(block, selectedKeys, _helpers_domHelper__WEBPACK_IMPORTED_MODULE_1__.SelectionCondition.Exclude), false);\r\n        _elementHighlighter__WEBPACK_IMPORTED_MODULE_4__.ElementHighlighter.toggleActivityStyle(_features_legend_legend__WEBPACK_IMPORTED_MODULE_0__.Legend.getItemsByKeys(block, selectedKeys), true);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/elementHighlighter/selectHighlighter.ts?");

/***/ }),

/***/ "./src/engine/engine.ts":
/*!******************************!*\
  !*** ./src/engine/engine.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => /* binding */ Engine\n/* harmony export */ });\n/* harmony import */ var _block_block__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./block/block */ \"./src/engine/block/block.ts\");\n/* harmony import */ var _valueFormatter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./valueFormatter */ \"./src/engine/valueFormatter.ts\");\n/* harmony import */ var _contentManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./contentManager */ \"./src/engine/contentManager.ts\");\n/* harmony import */ var _filterManager_filterEventManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./filterManager/filterEventManager */ \"./src/engine/filterManager/filterEventManager.ts\");\n/* harmony import */ var _helpers_helper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./helpers/helper */ \"./src/engine/helpers/helper.ts\");\n\r\n\r\n\r\n\r\n\r\nclass Engine {\r\n    constructor(id, filterCallback, initializeSelected) {\r\n        this.filterCallback = filterCallback;\r\n        this.initializeSelected = initializeSelected;\r\n        this.chartId = id;\r\n    }\r\n    render(model, data, parentElement) {\r\n        this.data = data;\r\n        this.setFilterEventManager(model === null || model === void 0 ? void 0 : model.options);\r\n        this.block = new _block_block__WEBPACK_IMPORTED_MODULE_0__.Block(model.blockCanvas.cssClass, parentElement, this.chartId, this.filterEventManager, model.transitions);\r\n        this.filterEventManager.setBlock(this.block);\r\n        this.block.renderWrapper(model.blockCanvas.size);\r\n        if (model.options) {\r\n            _valueFormatter__WEBPACK_IMPORTED_MODULE_1__.ValueFormatter.setFormatFunction(model.dataSettings.format.formatters);\r\n            this.renderCharts(model, this.data);\r\n        }\r\n    }\r\n    updateFullBlock(model, data) {\r\n        this.destroy();\r\n        this.render(model, data, this.block.parentElement);\r\n    }\r\n    destroy() {\r\n        this.block.transitionManager.interruptTransitions();\r\n        this.block.removeMouseEvents();\r\n        this.block.getWrapper().remove();\r\n    }\r\n    updateData(model, newData) {\r\n        if (!newData) {\r\n            this.data = newData;\r\n            this.block.clearWrapper();\r\n        }\r\n        else {\r\n            if (!this.data) {\r\n                this.data = newData;\r\n                this.updateFullBlock(model, this.data);\r\n            }\r\n            else if (!_helpers_helper__WEBPACK_IMPORTED_MODULE_4__.Helper.compareData(this.data, newData, model.options.data.dataSource)) {\r\n                for (let source in newData) {\r\n                    this.data[source] = newData[source];\r\n                }\r\n                _contentManager__WEBPACK_IMPORTED_MODULE_2__.ContentManager.updateData(this.block, model, newData);\r\n            }\r\n        }\r\n    }\r\n    renderCharts(model, data) {\r\n        _contentManager__WEBPACK_IMPORTED_MODULE_2__.ContentManager.render(model, data, this);\r\n    }\r\n    setFilterEventManager(options) {\r\n        var _a, _b, _c;\r\n        let highlightIds = [];\r\n        if (this.initializeSelected instanceof Array && this.initializeSelected.length > 0)\r\n            highlightIds = [...this.initializeSelected];\r\n        if ((_a = options === null || options === void 0 ? void 0 : options.data) === null || _a === void 0 ? void 0 : _a.dataSource)\r\n            this.filterEventManager = new _filterManager_filterEventManager__WEBPACK_IMPORTED_MODULE_3__.FilterEventManager(this.filterCallback, this.data[options.data.dataSource], options.selectable, options.data.keyField.name, highlightIds);\r\n        else\r\n            this.filterEventManager = new _filterManager_filterEventManager__WEBPACK_IMPORTED_MODULE_3__.FilterEventManager(this.filterCallback, [], options === null || options === void 0 ? void 0 : options.selectable, (_c = (_b = options === null || options === void 0 ? void 0 : options.data) === null || _b === void 0 ? void 0 : _b.keyField) === null || _c === void 0 ? void 0 : _c.name, highlightIds);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/engine.ts?");

/***/ }),

/***/ "./src/engine/features/axis/axis.ts":
/*!******************************************!*\
  !*** ./src/engine/features/axis/axis.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Axis\": () => /* binding */ Axis\n/* harmony export */ });\n/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-format */ \"./node_modules/d3-format/src/defaultLocale.js\");\n/* harmony import */ var _scale_scale__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../scale/scale */ \"./src/engine/features/scale/scale.ts\");\n/* harmony import */ var _model_marginModel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../model/marginModel */ \"./src/model/marginModel.ts\");\n/* harmony import */ var _namesManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../namesManager */ \"./src/engine/namesManager.ts\");\n/* harmony import */ var _axisHelper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./axisHelper */ \"./src/engine/features/axis/axisHelper.ts\");\n/* harmony import */ var _axisLabelDomHelper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./axisLabelDomHelper */ \"./src/engine/features/axis/axisLabelDomHelper.ts\");\n/* harmony import */ var _axisDomHelper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./axisDomHelper */ \"./src/engine/features/axis/axisDomHelper.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst MINIMAL_STEP_SIZE_FOR_WRAPPING = 38;\r\nclass Axis {\r\n    static render(block, scales, scaleModel, axisModel, margin, blockSize) {\r\n        if (axisModel.value.visibility)\r\n            this.renderAxis(block, scales.value, scaleModel.value, axisModel.value, margin, blockSize);\r\n        if (axisModel.key.visibility)\r\n            this.renderAxis(block, scales.key, scaleModel.key, axisModel.key, margin, blockSize);\r\n    }\r\n    static update(block, scales, scalesOptions, axisModel, blockSize, keyDomainsEquality) {\r\n        if (axisModel.value.visibility)\r\n            this.updateValueAxis(block, scales.value, scalesOptions.value, axisModel.value);\r\n        if (axisModel.key.visibility)\r\n            this.updateKeyAxis(block, scales.key, scalesOptions.key, axisModel.key, blockSize, keyDomainsEquality);\r\n    }\r\n    static updateValueAxis(block, scaleValue, scaleOptions, axisOptions) {\r\n        const axisGenerator = this.getBaseAxisGenerator(axisOptions, scaleValue, scaleOptions);\r\n        const axisElement = block.getSvg()\r\n            .select(`g.${axisOptions.cssClass}`);\r\n        _axisDomHelper__WEBPACK_IMPORTED_MODULE_5__.AxisDomHelper.updateAxisElement(axisGenerator, axisElement, axisOptions.translate, block.transitionManager.durations.chartUpdate);\r\n    }\r\n    static updateKeyAxis(block, scaleKey, scaleOptions, axisOptions, blockSize, domainNotUpdated) {\r\n        const axisGenerator = this.getBaseAxisGenerator(axisOptions, scaleKey, scaleOptions);\r\n        if (axisOptions.labels.positition === 'rotated') { // Задание координат для перевернутых лейблов (если до этого они не были перевернуты)\r\n            if (axisOptions.orient === 'bottom')\r\n                axisGenerator.tickPadding(-4);\r\n            else if (axisOptions.orient === 'top')\r\n                axisGenerator.tickPadding(-6);\r\n        }\r\n        const axisElement = block.getSvg()\r\n            .select(`g.${axisOptions.cssClass}`);\r\n        if (axisOptions.orient === 'left' || axisOptions.orient === 'right') {\r\n            axisElement.selectAll('.tick text').attr('y', null);\r\n            if (axisOptions.orient === 'left')\r\n                axisGenerator.tickPadding(axisOptions.labels.maxSize + _model_marginModel__WEBPACK_IMPORTED_MODULE_1__.AXIS_VERTICAL_LABEL_PADDING);\r\n        }\r\n        // Если ключи оси не меняются, то обновление происходит без анимации\r\n        _axisDomHelper__WEBPACK_IMPORTED_MODULE_5__.AxisDomHelper.updateAxisElement(axisGenerator, axisElement, axisOptions.translate, domainNotUpdated ? 0 : block.transitionManager.durations.chartUpdate)\r\n            .then(() => {\r\n            if (axisOptions.orient === 'bottom' || axisOptions.orient === 'top') {\r\n                _axisLabelDomHelper__WEBPACK_IMPORTED_MODULE_4__.AxisLabelHelper.cropLabels(block, scaleKey, scaleOptions, axisOptions, blockSize);\r\n            }\r\n            _axisLabelDomHelper__WEBPACK_IMPORTED_MODULE_4__.AxisLabelHelper.setTitles(axisElement, axisGenerator.scale().domain());\r\n        });\r\n        // Ведется отсчет нескольких кадров, чтобы получить уже 100%-отрендеренные лейблы оси.\r\n        let frame = 0;\r\n        const labelHandle = () => {\r\n            frame++;\r\n            if (frame < 10)\r\n                requestAnimationFrame(labelHandle);\r\n            if (axisOptions.orient === 'left' || axisOptions.orient === 'right') {\r\n                if (_scale_scale__WEBPACK_IMPORTED_MODULE_0__.Scale.getScaleStep(scaleKey) >= MINIMAL_STEP_SIZE_FOR_WRAPPING)\r\n                    axisElement.selectAll('.tick text').call(_axisLabelDomHelper__WEBPACK_IMPORTED_MODULE_4__.AxisLabelHelper.wrapHandler, axisOptions.labels.maxSize);\r\n                else\r\n                    _axisLabelDomHelper__WEBPACK_IMPORTED_MODULE_4__.AxisLabelHelper.cropLabels(block, scaleKey, scaleOptions, axisOptions, blockSize);\r\n                _axisLabelDomHelper__WEBPACK_IMPORTED_MODULE_4__.AxisLabelHelper.alignLabelsInKeyAxis(axisOptions, axisElement);\r\n            }\r\n            if (axisOptions.orient === 'bottom' || axisOptions.orient === 'top') {\r\n                axisElement.selectAll('.tick > text').attr('text-anchor', 'center');\r\n                if (axisOptions.labels.positition === 'rotated')\r\n                    _axisLabelDomHelper__WEBPACK_IMPORTED_MODULE_4__.AxisLabelHelper.rotateLabels(axisElement, axisOptions.orient);\r\n                // Обратное выравнивание лейблов, если они были перевернуты, но теперь могут отображаться прямо\r\n                if (axisOptions.labels.positition === 'straight')\r\n                    _axisDomHelper__WEBPACK_IMPORTED_MODULE_5__.AxisDomHelper.rotateElementsBack(axisElement, axisOptions.labels.positition);\r\n                _axisLabelDomHelper__WEBPACK_IMPORTED_MODULE_4__.AxisLabelHelper.cropLabels(block, scaleKey, scaleOptions, axisOptions, blockSize);\r\n            }\r\n        };\r\n        requestAnimationFrame(labelHandle);\r\n    }\r\n    static renderAxis(block, scale, scaleOptions, axisOptions, margin, blockSize) {\r\n        const axisGenerator = this.getBaseAxisGenerator(axisOptions, scale, scaleOptions);\r\n        if (axisOptions.type === 'value')\r\n            _axisHelper__WEBPACK_IMPORTED_MODULE_3__.AxisHelper.setStepSize(axisGenerator, scaleOptions.domain, scale.range());\r\n        const axisElement = block.getSvg()\r\n            .append('g')\r\n            .attr('class', `${this.axesClass} ${axisOptions.cssClass} data-label`);\r\n        _axisDomHelper__WEBPACK_IMPORTED_MODULE_5__.AxisDomHelper.updateAxisElement(axisGenerator, axisElement, axisOptions.translate);\r\n        if (axisOptions.labels.visible) {\r\n            if (axisOptions.type === 'key' && axisOptions.labels.positition === 'rotated' && (axisOptions.orient === 'top' || axisOptions.orient === 'bottom'))\r\n                _axisLabelDomHelper__WEBPACK_IMPORTED_MODULE_4__.AxisLabelHelper.rotateLabels(axisElement, axisOptions.orient);\r\n            if ((axisOptions.orient === 'left' || axisOptions.orient === 'right') && axisOptions.type === 'key' && _scale_scale__WEBPACK_IMPORTED_MODULE_0__.Scale.getScaleStep(scale) >= MINIMAL_STEP_SIZE_FOR_WRAPPING)\r\n                axisElement.selectAll('.tick text').call(_axisLabelDomHelper__WEBPACK_IMPORTED_MODULE_4__.AxisLabelHelper.wrapHandler, axisOptions.labels.maxSize);\r\n            else\r\n                _axisLabelDomHelper__WEBPACK_IMPORTED_MODULE_4__.AxisLabelHelper.cropLabels(block, scale, scaleOptions, axisOptions, blockSize);\r\n            if (axisOptions.type === 'key') {\r\n                _axisLabelDomHelper__WEBPACK_IMPORTED_MODULE_4__.AxisLabelHelper.setTitles(axisElement, axisGenerator.scale().domain());\r\n                _axisLabelDomHelper__WEBPACK_IMPORTED_MODULE_4__.AxisLabelHelper.alignLabelsInKeyAxis(axisOptions, axisElement);\r\n            }\r\n        }\r\n        else {\r\n            _axisLabelDomHelper__WEBPACK_IMPORTED_MODULE_4__.AxisLabelHelper.hideLabels(axisElement);\r\n        }\r\n    }\r\n    static getBaseAxisGenerator(axisOptions, scale, scaleOptions) {\r\n        const axis = _axisHelper__WEBPACK_IMPORTED_MODULE_3__.AxisHelper.getAxisByOrient(axisOptions.orient, scale);\r\n        if (!axisOptions.ticks.flag)\r\n            this.removeTicks(axis);\r\n        _axisLabelDomHelper__WEBPACK_IMPORTED_MODULE_4__.AxisLabelHelper.setAxisLabelPaddingByOrient(axis, axisOptions);\r\n        this.setTickFormat(scale, scaleOptions, axis);\r\n        return axis;\r\n    }\r\n    static removeTicks(axis) {\r\n        axis.tickSize(0);\r\n    }\r\n    static setTickFormat(scale, scaleOptions, axis) {\r\n        if (scaleOptions.type === 'linear') {\r\n            axis.tickFormat((0,d3_format__WEBPACK_IMPORTED_MODULE_6__.format)('~s'));\r\n        }\r\n    }\r\n}\r\nAxis.axesClass = _namesManager__WEBPACK_IMPORTED_MODULE_2__.NamesManager.getClassName('axis');\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/features/axis/axis.ts?");

/***/ }),

/***/ "./src/engine/features/axis/axisDomHelper.ts":
/*!***************************************************!*\
  !*** ./src/engine/features/axis/axisDomHelper.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AxisDomHelper\": () => /* binding */ AxisDomHelper\n/* harmony export */ });\nclass AxisDomHelper {\r\n    static updateAxisElement(axisGenerator, axisElement, translate, transitionDuration = 0) {\r\n        return new Promise(resolve => {\r\n            let axisHandler = axisElement;\r\n            if (transitionDuration > 0) {\r\n                axisHandler = axisHandler\r\n                    .interrupt()\r\n                    .transition()\r\n                    .duration(transitionDuration)\r\n                    .on('end', () => resolve('updated'));\r\n            }\r\n            axisHandler.attr('transform', `translate(${translate.translateX}, ${translate.translateY})`)\r\n                .call(axisGenerator.bind(this));\r\n            if (transitionDuration <= 0)\r\n                resolve('updated');\r\n        });\r\n    }\r\n    static rotateElementsBack(axisElement, labelPostion) {\r\n        axisElement.selectAll('.tick text')\r\n            .attr('transform', null)\r\n            .attr('text-anchor', 'middle')\r\n            .attr('x', null);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/features/axis/axisDomHelper.ts?");

/***/ }),

/***/ "./src/engine/features/axis/axisHelper.ts":
/*!************************************************!*\
  !*** ./src/engine/features/axis/axisHelper.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AxisHelper\": () => /* binding */ AxisHelper\n/* harmony export */ });\n/* harmony import */ var d3_axis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-axis */ \"./node_modules/d3-axis/src/axis.js\");\n/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-array */ \"./node_modules/d3-array/src/min.js\");\n/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-array */ \"./node_modules/d3-array/src/max.js\");\n\r\n\r\nconst MINIMAL_STEP_SIZE = 40;\r\nclass AxisHelper {\r\n    static getAxisByOrient(orient, scale) {\r\n        if (orient === 'top')\r\n            return (0,d3_axis__WEBPACK_IMPORTED_MODULE_0__.axisTop)(scale);\r\n        if (orient === 'bottom')\r\n            return (0,d3_axis__WEBPACK_IMPORTED_MODULE_0__.axisBottom)(scale);\r\n        if (orient === 'left')\r\n            return (0,d3_axis__WEBPACK_IMPORTED_MODULE_0__.axisLeft)(scale);\r\n        if (orient === 'right')\r\n            return (0,d3_axis__WEBPACK_IMPORTED_MODULE_0__.axisRight)(scale);\r\n    }\r\n    static setStepSize(axis, scaleDomain, range) {\r\n        const axisLength = range[1] - range[0];\r\n        if (axisLength / 10 < MINIMAL_STEP_SIZE) {\r\n            if (Math.floor(axisLength / MINIMAL_STEP_SIZE) > 2)\r\n                axis.ticks(Math.floor(axisLength / MINIMAL_STEP_SIZE));\r\n            else\r\n                axis.tickValues([(0,d3_array__WEBPACK_IMPORTED_MODULE_1__.default)(scaleDomain), (0,d3_array__WEBPACK_IMPORTED_MODULE_2__.default)(scaleDomain)]);\r\n        }\r\n    }\r\n    static getRecalcedTickValuesWithLastValue(minValue, maxValue, countValues) {\r\n        let valuesArray = [];\r\n        let step = 1;\r\n        let numbers = [1, 2, 5];\r\n        let numberIndex = 0;\r\n        // В случае если количество интервалов полученных при разбиении отрезка от 0 до максимального значения\r\n        // будет меньше или равно количеству возможных для отрисовки интервалов поиск подходящего шага завершится\r\n        while ((maxValue / step) > countValues) {\r\n            step = numbers[(numberIndex % numbers.length)]; // получение числа 1, 2 или 5 по очередно с каждым проходом цикла\r\n            step = step * Math.pow(10, Math.floor(numberIndex / numbers.length)); // произведение шага на 10-ки \r\n            numberIndex++;\r\n        }\r\n        valuesArray.push(minValue);\r\n        let currentValue = 0;\r\n        // Если цикл дошел до предпоследнего элемента, цикл завершается\r\n        while (currentValue + step * 2 < maxValue) {\r\n            currentValue += step;\r\n            valuesArray.push(currentValue);\r\n        }\r\n        currentValue += step; // получение значения предпоследнего элемента\r\n        if (maxValue - currentValue > step / 3) // Если расстояние между последним и предпоследним больше, чем 1/3 шага\r\n            valuesArray.push(currentValue);\r\n        valuesArray.push(maxValue);\r\n        valuesArray = valuesArray.reverse(); // Reverse массива для корректного отображения гридов\r\n        return valuesArray;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/features/axis/axisHelper.ts?");

/***/ }),

/***/ "./src/engine/features/axis/axisLabelDomHelper.ts":
/*!********************************************************!*\
  !*** ./src/engine/features/axis/axisLabelDomHelper.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AxisLabelHelper\": () => /* binding */ AxisLabelHelper\n/* harmony export */ });\n/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-selection */ \"./node_modules/d3-selection/src/select.js\");\n/* harmony import */ var _model_marginModel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../model/marginModel */ \"./src/model/marginModel.ts\");\n/* harmony import */ var _helpers_domHelper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../helpers/domHelper */ \"./src/engine/helpers/domHelper.ts\");\n/* harmony import */ var _helpers_helper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../helpers/helper */ \"./src/engine/helpers/helper.ts\");\n\r\n\r\n\r\n\r\nclass AxisLabelHelper {\r\n    static setTitles(axisElement, tickValues) {\r\n        axisElement.selectAll('.tick text')\r\n            .each(function (d, i) {\r\n            const tickTitle = (0,d3_selection__WEBPACK_IMPORTED_MODULE_3__.default)(this).select('title');\r\n            if (tickTitle.empty())\r\n                (0,d3_selection__WEBPACK_IMPORTED_MODULE_3__.default)(this)\r\n                    .append('title')\r\n                    .text(tickValues[i]);\r\n            else\r\n                tickTitle.text(tickValues[i]);\r\n        });\r\n    }\r\n    static alignLabelsInKeyAxis(axisOptions, axisElement) {\r\n        if (axisOptions.orient === 'left')\r\n            this.alignLabelsInVerticalAxis(axisElement, 'start', axisOptions.labels.maxSize, true);\r\n        else if (axisOptions.orient === 'right')\r\n            this.alignLabelsInVerticalAxis(axisElement, 'start', axisOptions.labels.maxSize, false);\r\n    }\r\n    static setAxisLabelPaddingByOrient(axis, axisOptions) {\r\n        let axisLabelPadding = _model_marginModel__WEBPACK_IMPORTED_MODULE_0__.AXIS_HORIZONTAL_LABEL_PADDING;\r\n        if (axisOptions.orient === 'left' || axisOptions.orient === 'right')\r\n            axisLabelPadding = _model_marginModel__WEBPACK_IMPORTED_MODULE_0__.AXIS_VERTICAL_LABEL_PADDING;\r\n        axis.tickPadding(axisLabelPadding);\r\n    }\r\n    static rotateLabels(axisElement, keyAxisOrient) {\r\n        const labelBlocks = axisElement.selectAll('text');\r\n        labelBlocks.attr('transform', 'rotate(-90)');\r\n        if (keyAxisOrient === 'bottom') {\r\n            labelBlocks\r\n                .attr('text-anchor', 'end')\r\n                .attr('x', -_model_marginModel__WEBPACK_IMPORTED_MODULE_0__.AXIS_HORIZONTAL_LABEL_PADDING)\r\n                .attr('y', -4);\r\n        }\r\n        else if (keyAxisOrient === 'top') {\r\n            labelBlocks\r\n                .attr('text-anchor', 'start')\r\n                .attr('x', _model_marginModel__WEBPACK_IMPORTED_MODULE_0__.AXIS_HORIZONTAL_LABEL_PADDING)\r\n                .attr('y', 6);\r\n        }\r\n    }\r\n    static cropLabels(block, scale, scaleOptions, axisOptions, blockSize) {\r\n        if (scaleOptions.type === 'point' || scaleOptions.type === 'band') {\r\n            const axisTextBlocks = block.getSvg().select(`.${axisOptions.cssClass}`).selectAll('text');\r\n            let maxLabelSize;\r\n            if ((axisOptions.orient === 'left' || axisOptions.orient === 'right') || (axisOptions.type === 'key' && axisOptions.labels.positition === 'rotated'))\r\n                maxLabelSize = axisOptions.labels.maxSize;\r\n            else\r\n                maxLabelSize = scale.step() - 4;\r\n            _helpers_domHelper__WEBPACK_IMPORTED_MODULE_1__.DomHelper.cropSvgLabels(axisTextBlocks, maxLabelSize);\r\n            if (scaleOptions.type === 'point' && axisOptions.labels.positition === 'straight' && (axisOptions.orient === 'top' || axisOptions.orient === 'bottom')) {\r\n                this.cropAndAlignExtremeLabels(block, maxLabelSize, axisOptions, blockSize);\r\n            }\r\n        }\r\n    }\r\n    static hideLabels(axisElement) {\r\n        axisElement.selectAll('.tick text').style('display', 'none');\r\n    }\r\n    static alignLabelsInVerticalAxis(axisElement, anchor, maxLabelSize, changeCoordinate) {\r\n        const axisTextBlocks = axisElement.selectAll('text');\r\n        const spans = axisElement.selectAll('tspan');\r\n        axisTextBlocks.attr('text-anchor', anchor);\r\n        spans.attr('text-anchor', anchor);\r\n        if (changeCoordinate) {\r\n            axisTextBlocks.attr('x', -(maxLabelSize + _model_marginModel__WEBPACK_IMPORTED_MODULE_0__.AXIS_VERTICAL_LABEL_PADDING));\r\n            spans.attr('x', -(maxLabelSize + _model_marginModel__WEBPACK_IMPORTED_MODULE_0__.AXIS_VERTICAL_LABEL_PADDING));\r\n        }\r\n        else {\r\n            spans.attr('x', _model_marginModel__WEBPACK_IMPORTED_MODULE_0__.AXIS_VERTICAL_LABEL_PADDING);\r\n        }\r\n    }\r\n    static cropAndAlignExtremeLabels(block, maxLabelSize, axisOptions, blockSize) {\r\n        const lastTick = block.getSvg().select(`.${axisOptions.cssClass}`).select('.tick:last-of-type');\r\n        const lastLabel = lastTick.select('text');\r\n        const tickTranslateX = _helpers_helper__WEBPACK_IMPORTED_MODULE_2__.Helper.getTranslateNumbers(lastTick.attr('transform'))[0];\r\n        const marginRight = blockSize.width - axisOptions.translate.translateX - tickTranslateX;\r\n        if (tickTranslateX + lastLabel.node().getBBox().width + axisOptions.translate.translateX > blockSize.width) {\r\n            lastLabel.attr('text-anchor', 'start');\r\n            lastLabel.attr('transform', `translate(${-Math.min(maxLabelSize / 2, lastLabel.node().getBBox().width - marginRight)}, 0)`);\r\n            _helpers_domHelper__WEBPACK_IMPORTED_MODULE_1__.DomHelper.cropSvgLabels(lastLabel, maxLabelSize / 2 + marginRight);\r\n        }\r\n        const firstLabel = block.getSvg()\r\n            .select(`.${axisOptions.cssClass}`)\r\n            .select('.tick:first-of-type')\r\n            .select('text');\r\n        const axisElementTranslate = _helpers_helper__WEBPACK_IMPORTED_MODULE_2__.Helper.getTranslateNumbers(block.getSvg().select(`.${axisOptions.cssClass}`).attr('transform'))[0];\r\n        if (axisOptions.translate.translateX - firstLabel.node().getBBox().width < 0) {\r\n            firstLabel.attr('text-anchor', 'start');\r\n            firstLabel.attr('transform', `translate(${-axisOptions.translate.translateX}, 0)`);\r\n            _helpers_domHelper__WEBPACK_IMPORTED_MODULE_1__.DomHelper.cropSvgLabels(firstLabel, maxLabelSize / 2 + axisElementTranslate);\r\n        }\r\n    }\r\n    static wrapHandler(textBlocks, maxWidth) {\r\n        textBlocks.each(function () {\r\n            let textBlock = (0,d3_selection__WEBPACK_IMPORTED_MODULE_3__.default)(this);\r\n            if (!textBlock.selectAll('tspan').empty())\r\n                return;\r\n            textBlock.select('title').remove();\r\n            let textContent = textBlock.text();\r\n            if (textBlock.node().getBBox().width > maxWidth) {\r\n                let letters = textBlock.text().split('').reverse(), // split text to letters.\r\n                letter, line = [], // one line. letters from this var into tpsans.\r\n                lineNumber = 0, y = textBlock.attr(\"y\"), dy = 1.4, tspan = textBlock.text(null).append(\"tspan\").attr(\"dy\", dy + \"em\");\r\n                while (letter = letters.pop()) {\r\n                    line.push(letter);\r\n                    tspan.text(line.join(''));\r\n                    if (tspan.node().getComputedTextLength() > maxWidth && line.length > 1 && letters.length > 0) {\r\n                        line.pop();\r\n                        tspan.text(line.join(''));\r\n                        if (lineNumber === 0 && line[line.length - 1] !== ' ')\r\n                            tspan.text(tspan.text() + '-');\r\n                        line = [letter];\r\n                        if (lineNumber >= 1) { // If text block has 2 lines, text cropped.\r\n                            if (letters.length > 0)\r\n                                tspan.text(tspan.text().substr(0, tspan.text().length - 1) + '...');\r\n                            break;\r\n                        }\r\n                        tspan = textBlock.append(\"tspan\").attr(\"dy\", dy * lineNumber + 1 + \"em\").text(letter);\r\n                        lineNumber++;\r\n                    }\r\n                }\r\n                if (textBlock.selectAll('tspan').size() === 1) {\r\n                    textBlock.text(textContent).attr('y', null);\r\n                }\r\n                if (!textBlock.selectAll('tspan').empty())\r\n                    textBlock.attr('y', -(textBlock.node().getBBox().height / 2 + 4.8));\r\n            }\r\n        });\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/features/axis/axisLabelDomHelper.ts?");

/***/ }),

/***/ "./src/engine/features/embeddedLabels/embeddedLabels.ts":
/*!**************************************************************!*\
  !*** ./src/engine/features/embeddedLabels/embeddedLabels.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EmbeddedLabels\": () => /* binding */ EmbeddedLabels\n/* harmony export */ });\n/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-selection */ \"./node_modules/d3-selection/src/select.js\");\n/* harmony import */ var _helpers_domHelper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../helpers/domHelper */ \"./src/engine/helpers/domHelper.ts\");\n/* harmony import */ var _helpers_helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../helpers/helper */ \"./src/engine/helpers/helper.ts\");\n/* harmony import */ var _valueFormatter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../valueFormatter */ \"./src/engine/valueFormatter.ts\");\n/* harmony import */ var _embeddedLabelsDomHelper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./embeddedLabelsDomHelper */ \"./src/engine/features/embeddedLabels/embeddedLabelsDomHelper.ts\");\n/* harmony import */ var _embeddedLabelsHelper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./embeddedLabelsHelper */ \"./src/engine/features/embeddedLabels/embeddedLabelsHelper.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\nclass EmbeddedLabels {\r\n    static render(block, bars, barAttrsHelper, field, type, keyAxisOrient, blockSize, margin, index, cssClasses) {\r\n        const labelsGroup = this.renderGroup(block, _helpers_helper__WEBPACK_IMPORTED_MODULE_1__.Helper.getCssClassesWithElementIndex(cssClasses, index));\r\n        _helpers_domHelper__WEBPACK_IMPORTED_MODULE_0__.DomHelper.setCssClasses(labelsGroup, _helpers_helper__WEBPACK_IMPORTED_MODULE_1__.Helper.getCssClassesWithElementIndex(cssClasses, index));\r\n        bars.each(dataRow => {\r\n            this.renderLabel(labelsGroup, barAttrsHelper, dataRow, field, type, keyAxisOrient, blockSize, margin);\r\n        });\r\n    }\r\n    static restoreRemoved(block, bars, barAttrsHelper, field, type, keyAxisOrient, blockSize, margin, index, cssClasses, keyFieldName) {\r\n        const untaggedBars = bars.filter(d => {\r\n            return block.getChartBlock()\r\n                .selectAll(`.${EmbeddedLabels.embeddedLabelsGroupClass}${_helpers_helper__WEBPACK_IMPORTED_MODULE_1__.Helper.getCssClassesLine(cssClasses)}.chart-element-${index}`)\r\n                .selectAll(`.${this.embeddedLabelClass}`)\r\n                .filter(row => row[keyFieldName] === d[keyFieldName])\r\n                .empty();\r\n        });\r\n        if (!untaggedBars.empty()) {\r\n            this.render(block, untaggedBars, barAttrsHelper, field, type, keyAxisOrient, blockSize, margin, index, cssClasses);\r\n        }\r\n    }\r\n    static removeUnused(block, chartCssClasses, fieldIndex, indexes) {\r\n        block.getChartBlock()\r\n            .selectAll(`.${EmbeddedLabels.embeddedLabelsGroupClass}${_helpers_helper__WEBPACK_IMPORTED_MODULE_1__.Helper.getCssClassesLine(chartCssClasses)}.chart-element-${fieldIndex}`)\r\n            .selectAll(`.${this.embeddedLabelClass}`)\r\n            .filter((d, i) => indexes.findIndex(ind => ind === i) !== -1)\r\n            .remove();\r\n    }\r\n    static update(block, bars, keyAxisOrient, barAttrsHelper, margin, valueField, type, blockSize, newData, index, cssClasses) {\r\n        const labelsGroup = block.getChartBlock()\r\n            .selectAll(`.${EmbeddedLabels.embeddedLabelsGroupClass}${_helpers_helper__WEBPACK_IMPORTED_MODULE_1__.Helper.getCssClassesLine(cssClasses)}.chart-element-${index}`);\r\n        labelsGroup.selectAll(`.${this.embeddedLabelBgClass}`)\r\n            .remove();\r\n        const labelsSelection = labelsGroup\r\n            .selectAll(`.${this.embeddedLabelClass}`)\r\n            .data(newData);\r\n        bars.each((dataRow, barIndex) => {\r\n            const labelBlock = this.getLabelByIndex(labelsSelection, barIndex, valueField, dataRow);\r\n            if (labelBlock)\r\n                this.updateLabel(block, dataRow, keyAxisOrient, barAttrsHelper, margin, type, blockSize, labelBlock, labelsGroup);\r\n        });\r\n    }\r\n    static raiseGroups(block) {\r\n        block.getChartBlock().selectAll(`.${this.embeddedLabelsGroupClass}`).raise();\r\n    }\r\n    static renderLabel(labelsGroup, barAttrsHelper, dataRow, field, type, keyAxisOrient, blockSize, margin) {\r\n        const labelBlock = labelsGroup.append('text').datum(dataRow);\r\n        labelBlock\r\n            .classed(EmbeddedLabels.embeddedLabelClass, true)\r\n            .style('pointer-events', 'none')\r\n            .text(_valueFormatter__WEBPACK_IMPORTED_MODULE_2__.ValueFormatter.formatField(field.format, dataRow[field.name]));\r\n        const barAttrs = {\r\n            x: barAttrsHelper.x(dataRow),\r\n            width: barAttrsHelper.width(dataRow),\r\n            y: barAttrsHelper.y(dataRow),\r\n            height: barAttrsHelper.height(dataRow)\r\n        };\r\n        const labelUnserveFlag = _embeddedLabelsHelper__WEBPACK_IMPORTED_MODULE_4__.EmbeddedLabelsHelper.getLabelUnserveFlag(barAttrs.height); // if bar is too small to serve label inside. This flag is needed for set outside postion and change text anchor if bar wide as whole chart block\r\n        const position = _embeddedLabelsHelper__WEBPACK_IMPORTED_MODULE_4__.EmbeddedLabelsHelper.getLabelPosition(barAttrs, labelBlock.node().getBBox().width, margin, blockSize, labelUnserveFlag);\r\n        const attrs = _embeddedLabelsHelper__WEBPACK_IMPORTED_MODULE_4__.EmbeddedLabelsHelper.getLabelAttrs(barAttrs, type, position, keyAxisOrient, labelBlock.node().getBBox().width);\r\n        if (position === 'outside') {\r\n            attrs.x = this.checkLabelToResetTextAnchor(attrs.x, labelBlock.node().getBBox().width, margin, blockSize, keyAxisOrient);\r\n            this.renderBackground(labelsGroup, labelBlock, attrs);\r\n        }\r\n        _embeddedLabelsDomHelper__WEBPACK_IMPORTED_MODULE_3__.EmbeddedLabelsDomHelper.setLabelBlockAttrs(attrs, labelBlock);\r\n        if (position === 'inside')\r\n            labelBlock.style('fill', this.innerLabelColor);\r\n        _embeddedLabelsDomHelper__WEBPACK_IMPORTED_MODULE_3__.EmbeddedLabelsDomHelper.cropText(labelBlock, barAttrs, position, labelUnserveFlag, margin, blockSize);\r\n    }\r\n    static updateLabel(block, dataRow, keyAxisOrient, barAttrsHelper, margin, type, blockSize, labelBlock, labelsGroup) {\r\n        const barAttrs = {\r\n            x: barAttrsHelper.x(dataRow),\r\n            width: barAttrsHelper.width(dataRow),\r\n            y: barAttrsHelper.y(dataRow),\r\n            height: barAttrsHelper.height(dataRow)\r\n        };\r\n        const labelUnserveFlag = _embeddedLabelsHelper__WEBPACK_IMPORTED_MODULE_4__.EmbeddedLabelsHelper.getLabelUnserveFlag(barAttrs.height); // if bar is too small to serve label inside. This flag is needed for set outside postion and change text anchor if bar wide as whole chart block\r\n        const position = _embeddedLabelsHelper__WEBPACK_IMPORTED_MODULE_4__.EmbeddedLabelsHelper.getLabelPosition(barAttrs, labelBlock.node().getBBox().width, margin, blockSize, labelUnserveFlag);\r\n        const attrs = _embeddedLabelsHelper__WEBPACK_IMPORTED_MODULE_4__.EmbeddedLabelsHelper.getLabelAttrs(barAttrs, type, position, keyAxisOrient, labelBlock.node().getBBox().width);\r\n        _embeddedLabelsDomHelper__WEBPACK_IMPORTED_MODULE_3__.EmbeddedLabelsDomHelper.cropText(labelBlock, barAttrs, position, labelUnserveFlag, margin, blockSize);\r\n        if (position === 'outside') {\r\n            attrs.x = this.checkLabelToResetTextAnchor(attrs.x, labelBlock.node().getBBox().width, margin, blockSize, keyAxisOrient);\r\n            labelBlock.style('fill', this.outerLabelColor);\r\n        }\r\n        _embeddedLabelsDomHelper__WEBPACK_IMPORTED_MODULE_3__.EmbeddedLabelsDomHelper.setLabelBlockAttrs(attrs, labelBlock, block.transitionManager.durations.chartUpdate)\r\n            .then(() => {\r\n            if (position === 'outside')\r\n                this.renderBackground(labelsGroup, labelBlock, attrs);\r\n            if (position === 'inside')\r\n                labelBlock.style('fill', this.innerLabelColor);\r\n        });\r\n    }\r\n    static checkLabelToResetTextAnchor(x, width, margin, blockSize, keyAxisOrient) {\r\n        if (keyAxisOrient === 'left') {\r\n            if (x + width > blockSize.width - margin.right)\r\n                return blockSize.width - margin.right - width;\r\n            return x;\r\n        }\r\n        if (keyAxisOrient === 'right') {\r\n            if (x < margin.left)\r\n                return margin.left;\r\n            return x;\r\n        }\r\n    }\r\n    static renderGroup(block, cssClasses) {\r\n        let group = block.getChartBlock()\r\n            .select(`.${this.embeddedLabelsGroupClass}${_helpers_helper__WEBPACK_IMPORTED_MODULE_1__.Helper.getCssClassesLine(cssClasses)}`)\r\n            .raise();\r\n        if (group.empty())\r\n            group = block.getChartBlock()\r\n                .append('g')\r\n                .attr('class', this.embeddedLabelsGroupClass)\r\n                .raise();\r\n        return group;\r\n    }\r\n    static renderBackground(labelsGroup, labelBlock, attrs) {\r\n        labelsGroup.append('rect')\r\n            .attr('class', this.embeddedLabelBgClass)\r\n            .attr('x', attrs.x)\r\n            .attr('y', attrs.y - labelBlock.node().getBBox().height / 2)\r\n            .attr('width', labelBlock.node().getBBox().width)\r\n            .attr('height', labelBlock.node().getBBox().height)\r\n            .style('fill', 'rgba(255, 255, 255, 0.8)')\r\n            .lower();\r\n    }\r\n    static getLabelByIndex(labelsSelection, barIndex, valueField, dataRow) {\r\n        let labelBlock;\r\n        labelsSelection.each(function (d, indexLabel) {\r\n            if (barIndex === indexLabel) {\r\n                labelBlock = (0,d3_selection__WEBPACK_IMPORTED_MODULE_5__.default)(this)\r\n                    .datum(dataRow)\r\n                    .text(_valueFormatter__WEBPACK_IMPORTED_MODULE_2__.ValueFormatter.formatField(valueField.format, d[valueField.name]));\r\n            }\r\n        });\r\n        return labelBlock;\r\n    }\r\n}\r\nEmbeddedLabels.embeddedLabelsGroupClass = 'embedded-labels-group';\r\nEmbeddedLabels.embeddedLabelClass = 'embedded-label';\r\nEmbeddedLabels.embeddedLabelBgClass = 'embedded-label-bg';\r\nEmbeddedLabels.innerLabelColor = '#FFFFFF';\r\nEmbeddedLabels.outerLabelColor = '#000000';\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/features/embeddedLabels/embeddedLabels.ts?");

/***/ }),

/***/ "./src/engine/features/embeddedLabels/embeddedLabelsDomHelper.ts":
/*!***********************************************************************!*\
  !*** ./src/engine/features/embeddedLabels/embeddedLabelsDomHelper.ts ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EmbeddedLabelsDomHelper\": () => /* binding */ EmbeddedLabelsDomHelper\n/* harmony export */ });\n/* harmony import */ var _embeddedLabelsHelper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./embeddedLabelsHelper */ \"./src/engine/features/embeddedLabels/embeddedLabelsHelper.ts\");\n/* harmony import */ var _helpers_domHelper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../helpers/domHelper */ \"./src/engine/helpers/domHelper.ts\");\n\r\n\r\nclass EmbeddedLabelsDomHelper {\r\n    static setLabelBlockAttrs(attrs, labelBlock, transitionDuration = 0) {\r\n        return new Promise((resolve) => {\r\n            let labelBlockHandler = labelBlock;\r\n            if (transitionDuration > 0) {\r\n                labelBlockHandler = labelBlockHandler\r\n                    .interrupt()\r\n                    .transition()\r\n                    .duration(transitionDuration)\r\n                    .on('end', () => resolve('updated'));\r\n            }\r\n            labelBlockHandler\r\n                .attr('x', attrs.x)\r\n                .attr('y', attrs.y)\r\n                .attr('dominant-baseline', 'middle');\r\n            if (transitionDuration <= 0)\r\n                resolve('updated');\r\n        });\r\n    }\r\n    static cropText(labelBlock, barAttrs, position, labelUnserveFlag, margin, blockSize) {\r\n        let labelTextSpace;\r\n        if (labelUnserveFlag)\r\n            labelTextSpace = blockSize.width - margin.left - margin.right;\r\n        else\r\n            labelTextSpace = _embeddedLabelsHelper__WEBPACK_IMPORTED_MODULE_0__.EmbeddedLabelsHelper.getSpaceSizeForType(position, barAttrs.width, margin, blockSize);\r\n        _helpers_domHelper__WEBPACK_IMPORTED_MODULE_1__.DomHelper.cropSvgLabels(labelBlock, labelTextSpace);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/features/embeddedLabels/embeddedLabelsDomHelper.ts?");

/***/ }),

/***/ "./src/engine/features/embeddedLabels/embeddedLabelsHelper.ts":
/*!********************************************************************!*\
  !*** ./src/engine/features/embeddedLabels/embeddedLabelsHelper.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LABEL_BAR_PADDING\": () => /* binding */ LABEL_BAR_PADDING,\n/* harmony export */   \"MIN_BAR_HEIGHT_FOR_LABEL_SERVE\": () => /* binding */ MIN_BAR_HEIGHT_FOR_LABEL_SERVE,\n/* harmony export */   \"EmbeddedLabelsHelper\": () => /* binding */ EmbeddedLabelsHelper\n/* harmony export */ });\nconst LABEL_BAR_PADDING = 6;\r\nconst MIN_BAR_HEIGHT_FOR_LABEL_SERVE = 12;\r\nclass EmbeddedLabelsHelper {\r\n    static getLabelPosition(barAttrs, labelBlockWidth, margin, blockSize, labelUnserveFlag) {\r\n        if (labelUnserveFlag || this.getSpaceSizeForType('inside', barAttrs.width, margin, blockSize) < labelBlockWidth\r\n            && this.getSpaceSizeForType('inside', barAttrs.width, margin, blockSize) < this.getSpaceSizeForType('outside', barAttrs.width, margin, blockSize))\r\n            return 'outside';\r\n        return 'inside';\r\n    }\r\n    static getSpaceSizeForType(position, barWidth, margin, blockSize) {\r\n        if (position === 'outside')\r\n            return blockSize.width - margin.left - margin.right - barWidth - LABEL_BAR_PADDING;\r\n        return barWidth - LABEL_BAR_PADDING * 2;\r\n    }\r\n    static getLabelAttrs(barAttrs, type, position, keyAxisOrient, labelWidth) {\r\n        const textAnchor = this.getTextAnchor(type, position, keyAxisOrient);\r\n        const y = this.getLabelAttrY(barAttrs.y, barAttrs.height);\r\n        let x = this.getLabelAttrX(barAttrs, type, position, keyAxisOrient);\r\n        if (textAnchor === 'end') {\r\n            x = x - labelWidth;\r\n        }\r\n        return {\r\n            x,\r\n            y,\r\n            textAnchor\r\n        };\r\n    }\r\n    static getLabelField(type, valueFields, keyField, index) {\r\n        if (type === 'key')\r\n            return keyField;\r\n        if (type === 'value')\r\n            return valueFields[index];\r\n        return null;\r\n    }\r\n    static getLabelUnserveFlag(barHeight) {\r\n        return barHeight < MIN_BAR_HEIGHT_FOR_LABEL_SERVE;\r\n    }\r\n    static getLabelAttrX(barAttrs, type, position, keyAxisOrient) {\r\n        if (keyAxisOrient === 'left') {\r\n            if (position === 'outside')\r\n                return barAttrs.x + barAttrs.width + LABEL_BAR_PADDING;\r\n            if (type === 'key')\r\n                return barAttrs.x + LABEL_BAR_PADDING;\r\n            return barAttrs.x + barAttrs.width - LABEL_BAR_PADDING;\r\n        }\r\n        if (position === 'outside')\r\n            return barAttrs.x - LABEL_BAR_PADDING;\r\n        if (type === 'key')\r\n            return barAttrs.x + barAttrs.width - LABEL_BAR_PADDING;\r\n        return barAttrs.x + LABEL_BAR_PADDING;\r\n    }\r\n    static getLabelAttrY(barY, barHeight) {\r\n        return barY + barHeight / 2 + 1;\r\n    }\r\n    static getTextAnchor(type, position, keyAxisOrient) {\r\n        if (keyAxisOrient === 'left') {\r\n            if (position === 'outside' || type === 'key')\r\n                return 'start';\r\n            return 'end';\r\n        }\r\n        if (position === 'outside' || type === 'key')\r\n            return 'end';\r\n        return 'start';\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/features/embeddedLabels/embeddedLabelsHelper.ts?");

/***/ }),

/***/ "./src/engine/features/gridLine/gidLineHelper.ts":
/*!*******************************************************!*\
  !*** ./src/engine/features/gridLine/gidLineHelper.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GridLineHelper\": () => /* binding */ GridLineHelper\n/* harmony export */ });\nclass GridLineHelper {\r\n    static getGridLineLength(gridLineType, keyAxis, valueAxis, blockSize, margin) {\r\n        let axis;\r\n        let axisLength;\r\n        if (gridLineType === 'key')\r\n            axis = keyAxis;\r\n        else\r\n            axis = valueAxis;\r\n        if (axis.orient === 'left' || axis.orient === 'right')\r\n            axisLength = blockSize.width - margin.left - margin.right;\r\n        else\r\n            axisLength = blockSize.height - margin.top - margin.bottom;\r\n        if (axis.orient === 'right' || axis.orient === 'bottom')\r\n            axisLength = -axisLength;\r\n        return axisLength;\r\n    }\r\n    static getLineAttributes(axis, lineLength) {\r\n        const attributes = {\r\n            x1: 0,\r\n            y1: 0,\r\n            x2: 0,\r\n            y2: 0\r\n        };\r\n        if (axis.orient === 'left' || axis.orient === 'right')\r\n            attributes.x2 = lineLength;\r\n        else\r\n            attributes.y2 = lineLength;\r\n        return attributes;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/features/gridLine/gidLineHelper.ts?");

/***/ }),

/***/ "./src/engine/features/gridLine/gridLine.ts":
/*!**************************************************!*\
  !*** ./src/engine/features/gridLine/gridLine.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GridLine\": () => /* binding */ GridLine\n/* harmony export */ });\n/* harmony import */ var _gidLineHelper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gidLineHelper */ \"./src/engine/features/gridLine/gidLineHelper.ts\");\n\r\nclass GridLine {\r\n    static render(block, gridLineFlag, keyAxis, valueAxis, blockSize, margin, scaleKey) {\r\n        if (gridLineFlag.value) {\r\n            const lineLength = _gidLineHelper__WEBPACK_IMPORTED_MODULE_0__.GridLineHelper.getGridLineLength('value', keyAxis, valueAxis, blockSize, margin);\r\n            const lineAttributes = _gidLineHelper__WEBPACK_IMPORTED_MODULE_0__.GridLineHelper.getLineAttributes(valueAxis, lineLength);\r\n            this.renderLine(block, valueAxis, lineAttributes);\r\n        }\r\n        if (gridLineFlag.key) {\r\n            const lineLength = _gidLineHelper__WEBPACK_IMPORTED_MODULE_0__.GridLineHelper.getGridLineLength('key', keyAxis, valueAxis, blockSize, margin);\r\n            const lineAttributes = _gidLineHelper__WEBPACK_IMPORTED_MODULE_0__.GridLineHelper.getLineAttributes(keyAxis, lineLength);\r\n            this.renderLine(block, keyAxis, lineAttributes);\r\n        }\r\n        if (scaleKey.type === 'point' && (gridLineFlag.key || gridLineFlag.value))\r\n            this.removeGridLinesOnAxes(block, keyAxis, valueAxis, false);\r\n        else if (gridLineFlag.key || gridLineFlag.value)\r\n            this.removeGridLinesOnAxes(block, keyAxis, valueAxis, true);\r\n    }\r\n    static update(block, gridLineFlag, keyAxis, valueAxis, blockSize, margin, scaleKey) {\r\n        this.clear(block, keyAxis.cssClass, valueAxis.cssClass);\r\n        this.render(block, gridLineFlag, keyAxis, valueAxis, blockSize, margin, scaleKey);\r\n    }\r\n    static renderLine(block, axis, lineAttributes) {\r\n        block\r\n            .getSvg()\r\n            .selectAll(`.${axis.cssClass}`)\r\n            .selectAll('g.tick')\r\n            .append('line')\r\n            .attr('class', this.gridLineClass)\r\n            .attr('x1', lineAttributes.x1)\r\n            .attr('y1', lineAttributes.y1)\r\n            .attr('x2', lineAttributes.x2)\r\n            .attr('y2', lineAttributes.y2);\r\n    }\r\n    static clear(block, keyAxisClass, valueAxisClass) {\r\n        block.getSvg()\r\n            .selectAll(`.${keyAxisClass} `)\r\n            .selectAll('g.tick')\r\n            .selectAll(`.${this.gridLineClass}`)\r\n            .remove();\r\n        block.getSvg()\r\n            .selectAll(`.${valueAxisClass}`)\r\n            .selectAll('g.tick')\r\n            .selectAll(`.${this.gridLineClass}`)\r\n            .remove();\r\n    }\r\n    static removeGridLinesOnAxes(block, keyAxis, valueAxis, excludeKey) {\r\n        let tickOnKeyAxisSelector = '';\r\n        let tickOnValueAxisSelector = '';\r\n        if (valueAxis.orient === 'right' || valueAxis.orient === 'bottom')\r\n            tickOnValueAxisSelector = ':last-of-type';\r\n        if (keyAxis.orient === 'bottom' || keyAxis.orient === 'right')\r\n            tickOnKeyAxisSelector = ':last-of-type';\r\n        block.getSvg()\r\n            .select(`.${valueAxis.cssClass}`)\r\n            .select(`g.tick${tickOnKeyAxisSelector}`)\r\n            .select(`.${this.gridLineClass}`)\r\n            .remove();\r\n        if (!excludeKey)\r\n            block.getSvg()\r\n                .select(`.${keyAxis.cssClass}`)\r\n                .select(`g.tick${tickOnValueAxisSelector}`)\r\n                .select(`.${this.gridLineClass}`)\r\n                .remove();\r\n    }\r\n}\r\nGridLine.gridLineClass = 'grid-line';\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/features/gridLine/gridLine.ts?");

/***/ }),

/***/ "./src/engine/features/legend/legend.ts":
/*!**********************************************!*\
  !*** ./src/engine/features/legend/legend.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Legend\": () => /* binding */ Legend\n/* harmony export */ });\n/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-selection */ \"./node_modules/d3-selection/src/select.js\");\n/* harmony import */ var _helpers_domHelper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../helpers/domHelper */ \"./src/engine/helpers/domHelper.ts\");\n/* harmony import */ var _legendDomHelper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./legendDomHelper */ \"./src/engine/features/legend/legendDomHelper.ts\");\n/* harmony import */ var _legendEventsManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./legendEventsManager */ \"./src/engine/features/legend/legendEventsManager.ts\");\n/* harmony import */ var _legendHelper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./legendHelper */ \"./src/engine/features/legend/legendHelper.ts\");\n\r\n\r\n\r\n\r\n\r\nclass Legend {\r\n    static render(block, data, options, model) {\r\n        if (options.legend.position !== 'off') {\r\n            const items = _legendHelper__WEBPACK_IMPORTED_MODULE_3__.LegendHelper.getLegendItemsContent(options, data);\r\n            const colors = _legendHelper__WEBPACK_IMPORTED_MODULE_3__.LegendHelper.getMarksColor(options);\r\n            const itemsDirection = _legendHelper__WEBPACK_IMPORTED_MODULE_3__.LegendHelper.getLegendItemsDirection(options.type, options.legend.position);\r\n            const legendObject = this.renderObject(block, options.legend.position, model.otherComponents.legendBlock, model.blockCanvas.size);\r\n            const itemBlocks = this.renderContent(legendObject, items, colors, itemsDirection, options.legend.position);\r\n            if (options.type === 'polar') {\r\n                _legendEventsManager__WEBPACK_IMPORTED_MODULE_2__.LegendEventsManager.setListeners(block, options.data.keyField.name, itemBlocks, options.selectable);\r\n            }\r\n        }\r\n    }\r\n    static update(block, data, options) {\r\n        if (options.legend.position !== 'off') {\r\n            const legendItemsContent = _legendHelper__WEBPACK_IMPORTED_MODULE_3__.LegendHelper.getLegendItemsContent(options, data);\r\n            const chartElementsColor = _legendHelper__WEBPACK_IMPORTED_MODULE_3__.LegendHelper.getMarksColor(options);\r\n            const legendItemsDirection = _legendHelper__WEBPACK_IMPORTED_MODULE_3__.LegendHelper.getLegendItemsDirection(options.type, options.legend.position);\r\n            const legendObject = this.getObject(block);\r\n            this.removeContent(legendObject);\r\n            const legendItems = this.renderContent(legendObject, legendItemsContent, chartElementsColor, legendItemsDirection, options.legend.position);\r\n            if (options.type === 'polar') {\r\n                _legendEventsManager__WEBPACK_IMPORTED_MODULE_2__.LegendEventsManager.setListeners(block, options.data.keyField.name, legendItems, options.selectable);\r\n            }\r\n        }\r\n    }\r\n    static getItemsByKeys(block, keys, condition = _helpers_domHelper__WEBPACK_IMPORTED_MODULE_0__.SelectionCondition.Include) {\r\n        return block\r\n            .getSvg()\r\n            .selectAll(`.${this.itemClass}`)\r\n            .filter(d => {\r\n            const index = keys.findIndex(k => k === d);\r\n            return condition === _helpers_domHelper__WEBPACK_IMPORTED_MODULE_0__.SelectionCondition.Include ? index !== -1 : index === -1;\r\n        });\r\n    }\r\n    static renderObject(block, legendPosition, legendBlockModel, blockSize) {\r\n        const legendObject = block.getSvg()\r\n            .append('foreignObject')\r\n            .attr('class', Legend.objectClass);\r\n        const legendCoordinate = _legendHelper__WEBPACK_IMPORTED_MODULE_3__.LegendHelper.getLegendCoordinateByPosition(legendPosition, legendBlockModel, blockSize);\r\n        this.fillCoordinate(legendObject, legendCoordinate);\r\n        return legendObject;\r\n    }\r\n    static renderContent(legendObject, items, colorPalette, itemsDirection, position) {\r\n        const wrapper = legendObject.append('xhtml:div')\r\n            .attr('class', Legend.legendBlockClass);\r\n        wrapper\r\n            .style('height', '100%')\r\n            .style('display', 'flex');\r\n        if (itemsDirection === 'column') {\r\n            wrapper.style('flex-direction', 'column');\r\n            if (position === 'right')\r\n                wrapper.style('justify-content', 'center');\r\n        }\r\n        const itemWrappers = wrapper\r\n            .selectAll(`.${this.itemClass}`)\r\n            .data(items)\r\n            .enter()\r\n            .append('div');\r\n        const thisClass = this;\r\n        itemWrappers.each(function (d, i) {\r\n            (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__.default)(this).attr('class', `${thisClass.itemClass} ${_legendHelper__WEBPACK_IMPORTED_MODULE_3__.LegendHelper.getItemClasses(itemsDirection, position, i)}`);\r\n        });\r\n        itemWrappers\r\n            .append('span')\r\n            .attr('class', 'legend-circle')\r\n            .style('background-color', (d, i) => colorPalette[i % colorPalette.length]);\r\n        itemWrappers\r\n            .append('span')\r\n            .attr('class', _legendHelper__WEBPACK_IMPORTED_MODULE_3__.LegendHelper.getLegendLabelClassByPosition(position))\r\n            .attr('title', d => d)\r\n            .text(d => d);\r\n        if (itemsDirection === 'row')\r\n            _legendDomHelper__WEBPACK_IMPORTED_MODULE_1__.LegendDomHelper.cropRowLabels(legendObject, itemWrappers);\r\n        return itemWrappers;\r\n    }\r\n    static getObject(block) {\r\n        return block.getSvg()\r\n            .select(`foreignObject.${Legend.objectClass}`);\r\n    }\r\n    static removeContent(legendObject) {\r\n        legendObject.select(`.${Legend.legendBlockClass}`).remove();\r\n    }\r\n    static fillCoordinate(legendBlock, coordinate) {\r\n        legendBlock\r\n            .attr('x', coordinate.x)\r\n            .attr('y', coordinate.y)\r\n            .attr('width', coordinate.width)\r\n            .attr('height', coordinate.height);\r\n    }\r\n}\r\nLegend.objectClass = 'legend-object';\r\nLegend.labelClass = 'legend-label';\r\nLegend.itemClass = 'legend-item';\r\nLegend.legendBlockClass = 'legend-block';\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/features/legend/legend.ts?");

/***/ }),

/***/ "./src/engine/features/legend/legendDomHelper.ts":
/*!*******************************************************!*\
  !*** ./src/engine/features/legend/legendDomHelper.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LegendDomHelper\": () => /* binding */ LegendDomHelper\n/* harmony export */ });\n/* harmony import */ var _helpers_domHelper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../helpers/domHelper */ \"./src/engine/helpers/domHelper.ts\");\n/* harmony import */ var _helpers_helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../helpers/helper */ \"./src/engine/helpers/helper.ts\");\n/* harmony import */ var _legend__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./legend */ \"./src/engine/features/legend/legend.ts\");\n/* harmony import */ var _legendHelper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./legendHelper */ \"./src/engine/features/legend/legendHelper.ts\");\n\r\n\r\n\r\n\r\nclass LegendDomHelper {\r\n    static cropRowLabels(legendBlock, items) {\r\n        const maxWidth = legendBlock.node().getBoundingClientRect().width;\r\n        let itemsLeftMargins = this.getItemsLeftMargins(items);\r\n        let itemsWidth = this.getItemsWidth(items);\r\n        let sumOfItemsWidth = _legendHelper__WEBPACK_IMPORTED_MODULE_3__.LegendHelper.getSumOfItemsWidths(itemsWidth, itemsLeftMargins);\r\n        const maxItemWidth = _legendHelper__WEBPACK_IMPORTED_MODULE_3__.LegendHelper.getMaxItemWidth(legendBlock.attr('width'), itemsLeftMargins, 'row');\r\n        let index = 0;\r\n        let loopFlag = true; // if at least one label has no text, loop ends\r\n        while (sumOfItemsWidth > maxWidth && loopFlag) {\r\n            items.nodes().forEach(node => {\r\n                const textBlock = node.querySelector(`.${_legend__WEBPACK_IMPORTED_MODULE_2__.Legend.labelClass}`);\r\n                if (node.getBoundingClientRect().width > maxItemWidth && textBlock.textContent) {\r\n                    let labelText = index > 0\r\n                        ? textBlock.textContent.substr(0, textBlock.textContent.length - 3)\r\n                        : textBlock.textContent;\r\n                    labelText = labelText.substr(0, labelText.length - 1);\r\n                    textBlock.textContent = labelText + '...';\r\n                    itemsLeftMargins = this.getItemsLeftMargins(items);\r\n                    itemsWidth = this.getItemsWidth(items);\r\n                    sumOfItemsWidth = _legendHelper__WEBPACK_IMPORTED_MODULE_3__.LegendHelper.getSumOfItemsWidths(itemsWidth, itemsLeftMargins);\r\n                    if (labelText.length === 0) {\r\n                        textBlock.textContent = '';\r\n                        loopFlag = false;\r\n                    }\r\n                }\r\n            });\r\n            index++;\r\n        }\r\n    }\r\n    static getItemsLeftMargins(items) {\r\n        return items.nodes().map(node => _helpers_helper__WEBPACK_IMPORTED_MODULE_1__.Helper.getPXValueFromString(_helpers_domHelper__WEBPACK_IMPORTED_MODULE_0__.DomHelper.getCssPropertyValue(node, 'margin-left')));\r\n    }\r\n    static getItemsWidth(items) {\r\n        return items.nodes().map(node => node.getBoundingClientRect().width);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/features/legend/legendDomHelper.ts?");

/***/ }),

/***/ "./src/engine/features/legend/legendEventsManager.ts":
/*!***********************************************************!*\
  !*** ./src/engine/features/legend/legendEventsManager.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LegendEventsManager\": () => /* binding */ LegendEventsManager\n/* harmony export */ });\n/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ \"./node_modules/d3-selection/src/pointer.js\");\n/* harmony import */ var _polarNotation_donut_donut__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../polarNotation/donut/donut */ \"./src/engine/polarNotation/donut/donut.ts\");\n\r\n\r\nclass LegendEventsManager {\r\n    /**\r\n     * @param block\r\n     * @param keyFieldName\r\n     * @param legendItems айтемы легенды полара, которые привязаны к ключам\r\n     */\r\n    static setListeners(block, keyFieldName, legendItems, selectable) {\r\n        this.setHoverListeners(block, keyFieldName, legendItems);\r\n        if (selectable)\r\n            this.setClickListeners(block, keyFieldName, legendItems);\r\n    }\r\n    static setHoverListeners(block, keyFieldName, legendItems) {\r\n        const arcItems = _polarNotation_donut_donut__WEBPACK_IMPORTED_MODULE_0__.Donut.getAllArcGroups(block);\r\n        legendItems.on('mousemove', function (e, keyValue) {\r\n            arcItems.filter((row) => row.data[keyFieldName] === keyValue)\r\n                .dispatch('mousemove', {\r\n                bubbles: false,\r\n                cancelable: true,\r\n                detail: {\r\n                    pointer: (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__.default)(e, block.getWrapper().node()),\r\n                    ignoreTranslate: true\r\n                }\r\n            });\r\n        });\r\n        legendItems.on('mouseover', (e, keyValue) => {\r\n            arcItems.filter((row) => row.data[keyFieldName] === keyValue)\r\n                .dispatch('mouseover');\r\n        });\r\n        legendItems.on('mouseleave', (e, keyValue) => {\r\n            arcItems.filter((row) => row.data[keyFieldName] === keyValue)\r\n                .dispatch('mouseleave');\r\n        });\r\n    }\r\n    static setClickListeners(block, keyFieldName, legendItems) {\r\n        const arcItems = _polarNotation_donut_donut__WEBPACK_IMPORTED_MODULE_0__.Donut.getAllArcGroups(block);\r\n        legendItems.on('click', (e, keyValue) => {\r\n            arcItems.filter((row) => row.data[keyFieldName] === keyValue)\r\n                .dispatch('click', { bubbles: false, cancelable: true, detail: { multySelect: e.ctrlKey || e.metaKey } });\r\n        });\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/features/legend/legendEventsManager.ts?");

/***/ }),

/***/ "./src/engine/features/legend/legendHelper.ts":
/*!****************************************************!*\
  !*** ./src/engine/features/legend/legendHelper.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LegendHelper\": () => /* binding */ LegendHelper\n/* harmony export */ });\n/* harmony import */ var _helpers_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../helpers/helper */ \"./src/engine/helpers/helper.ts\");\n/* harmony import */ var _legend__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./legend */ \"./src/engine/features/legend/legend.ts\");\n\r\n\r\nclass LegendHelper {\r\n    static getLegendItemsContent(options, data) {\r\n        if (options.type === '2d') {\r\n            let texts = [];\r\n            options.charts.forEach(chart => {\r\n                texts = texts.concat(chart.data.valueFields.map(field => field.title));\r\n            });\r\n            return texts;\r\n        }\r\n        else if (options.type === 'polar') {\r\n            return data[options.data.dataSource].map((record) => record[options.data.keyField.name]);\r\n        }\r\n        else if (options.type === 'interval') {\r\n            return options.charts.map(chart => chart.data.valueField1.name);\r\n        }\r\n    }\r\n    static getMarksColor(options) {\r\n        if (options.type === '2d') {\r\n            let colors = [];\r\n            options.charts.forEach(chart => {\r\n                colors = colors.concat(chart.style.elementColors);\r\n            });\r\n            return colors;\r\n        }\r\n        else if (options.type === 'polar') {\r\n            return options.charts.map(chart => chart.style.elementColors)[0];\r\n        }\r\n        else if (options.type === 'interval') {\r\n            return options.charts.map(chart => chart.style.elementColors[0]);\r\n        }\r\n    }\r\n    static getMaxItemWidth(legendBlockWidth, marginsLeft, itemsDirection) {\r\n        if (itemsDirection === 'row') {\r\n            const sumOfMargins = _helpers_helper__WEBPACK_IMPORTED_MODULE_0__.Helper.getSumOfNumeric(marginsLeft);\r\n            return (parseFloat(legendBlockWidth) - sumOfMargins) / marginsLeft.length;\r\n        }\r\n        return parseFloat(legendBlockWidth);\r\n    }\r\n    static getItemClasses(itemsDirection, position, index) {\r\n        let cssClasses = this.getLegendItemClassByDirection(itemsDirection);\r\n        if (itemsDirection === 'column' && index !== 0)\r\n            cssClasses += ` ${this.getLegendItemsMarginClass(position)}`;\r\n        return cssClasses;\r\n    }\r\n    static getLegendItemClassByDirection(itemsDirection) {\r\n        return itemsDirection === 'column' ? 'legend-item-row' : 'legend-item-inline';\r\n    }\r\n    static getLegendItemsMarginClass(legendPosition) {\r\n        return legendPosition === 'right' ? 'mt-15' : 'mt-10';\r\n    }\r\n    static getLegendLabelClassByPosition(position) {\r\n        if (position === 'top' || position === 'bottom')\r\n            return `${_legend__WEBPACK_IMPORTED_MODULE_1__.Legend.labelClass} ${_legend__WEBPACK_IMPORTED_MODULE_1__.Legend.labelClass + '-nowrap'}`;\r\n        return _legend__WEBPACK_IMPORTED_MODULE_1__.Legend.labelClass;\r\n    }\r\n    static getLegendItemsDirection(chartNotation, legendPosition) {\r\n        if (legendPosition === 'right' || legendPosition === 'left')\r\n            return 'column';\r\n        else\r\n            return chartNotation === 'polar' ? 'column' : 'row';\r\n    }\r\n    static getSumOfItemsWidths(itemsWidth, marginsLeft) {\r\n        let sumOfItemsWidth = _helpers_helper__WEBPACK_IMPORTED_MODULE_0__.Helper.getSumOfNumeric(itemsWidth);\r\n        sumOfItemsWidth += _helpers_helper__WEBPACK_IMPORTED_MODULE_0__.Helper.getSumOfNumeric(marginsLeft);\r\n        return sumOfItemsWidth;\r\n    }\r\n    static getLegendCoordinateByPosition(legendPosition, legendBlockModel, blockSize) {\r\n        const legendModel = legendBlockModel[legendPosition];\r\n        const coordinate = {\r\n            x: 0,\r\n            y: 0,\r\n            width: 0,\r\n            height: 0\r\n        };\r\n        if (legendPosition === 'left' || legendPosition === 'right') {\r\n            coordinate.y = legendModel.margin.top + legendModel.pad;\r\n            coordinate.width = legendModel.size;\r\n            coordinate.height = blockSize.height - legendModel.margin.top - legendModel.margin.bottom;\r\n        }\r\n        else if (legendPosition === 'bottom' || legendPosition === 'top') {\r\n            coordinate.x = legendModel.margin.left;\r\n            coordinate.width = blockSize.width - legendModel.margin.left - legendModel.margin.right;\r\n            coordinate.height = legendModel.size;\r\n        }\r\n        if (legendPosition === 'left')\r\n            coordinate.x = legendModel.margin.left;\r\n        else if (legendPosition === 'right')\r\n            coordinate.x = blockSize.width - legendModel.size - legendModel.margin.right;\r\n        else if (legendPosition === 'top')\r\n            coordinate.y = legendModel.margin.top + legendModel.pad;\r\n        else if (legendPosition === 'bottom')\r\n            coordinate.y = blockSize.height - legendModel.size - legendModel.margin.bottom;\r\n        return coordinate;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/features/legend/legendHelper.ts?");

/***/ }),

/***/ "./src/engine/features/markDots/markDot.ts":
/*!*************************************************!*\
  !*** ./src/engine/features/markDots/markDot.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MarkDot\": () => /* binding */ MarkDot\n/* harmony export */ });\n/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-selection */ \"./node_modules/d3-selection/src/select.js\");\n/* harmony import */ var d3_transition__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-transition */ \"./node_modules/d3-transition/src/index.js\");\n/* harmony import */ var _helpers_domHelper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../helpers/domHelper */ \"./src/engine/helpers/domHelper.ts\");\n/* harmony import */ var _helpers_helper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../helpers/helper */ \"./src/engine/helpers/helper.ts\");\n/* harmony import */ var _markDotsHelper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./markDotsHelper */ \"./src/engine/features/markDots/markDotsHelper.ts\");\n\r\n\r\n\r\n\r\n\r\nd3_selection__WEBPACK_IMPORTED_MODULE_4__.default.prototype.transition = d3_transition__WEBPACK_IMPORTED_MODULE_0__.transition;\r\nclass MarkDot {\r\n    static render(block, data, keyAxisOrient, scales, margin, keyField, valueFieldIndex, valueFieldName, chart) {\r\n        const dotsWrapper = block.getChartGroup(chart.index)\r\n            .selectAll(`.${this.markerDotClass}${_helpers_helper__WEBPACK_IMPORTED_MODULE_2__.Helper.getCssClassesLine(chart.cssClasses)}.chart-index-${valueFieldIndex}`)\r\n            .data(data)\r\n            .enter();\r\n        const attrs = _markDotsHelper__WEBPACK_IMPORTED_MODULE_3__.MarkDotHelper.getDotAttrs(keyAxisOrient, scales, margin, keyField, valueFieldName, chart.isSegmented);\r\n        const dots = dotsWrapper.append('circle')\r\n            .attr('class', this.markerDotClass)\r\n            .attr('cx', d => attrs.cx(d))\r\n            .attr('cy', d => attrs.cy(d))\r\n            .attr('r', this.dotRadius)\r\n            .style('stroke-width', '3px')\r\n            .style('fill', 'white')\r\n            .style('clip-path', `url(#${block.getClipPathId()})`);\r\n        _helpers_domHelper__WEBPACK_IMPORTED_MODULE_1__.DomHelper.setCssClasses(dots, _helpers_helper__WEBPACK_IMPORTED_MODULE_2__.Helper.getCssClassesWithElementIndex(chart.cssClasses, valueFieldIndex));\r\n        _helpers_domHelper__WEBPACK_IMPORTED_MODULE_1__.DomHelper.setChartElementColor(dots, chart.style.elementColors, valueFieldIndex, 'stroke');\r\n    }\r\n    static updateDotsCoordinateByValueAxis(block, newData, keyAxisOrient, scales, margin, keyField, valueFieldIndex, valueFieldName, chart) {\r\n        const dots = block.getChartGroup(chart.index)\r\n            .selectAll(`.${this.markerDotClass}${_helpers_helper__WEBPACK_IMPORTED_MODULE_2__.Helper.getCssClassesLine(chart.cssClasses)}.chart-element-${valueFieldIndex}`)\r\n            .data(newData);\r\n        const attrs = _markDotsHelper__WEBPACK_IMPORTED_MODULE_3__.MarkDotHelper.getDotAttrs(keyAxisOrient, scales, margin, keyField, valueFieldName, chart.isSegmented);\r\n        dots.exit().remove();\r\n        const newDots = dots\r\n            .enter()\r\n            .append('circle')\r\n            .attr('class', this.markerDotClass)\r\n            .attr('cx', d => attrs.cx(d))\r\n            .attr('cy', d => attrs.cy(d))\r\n            .attr('r', this.dotRadius)\r\n            .style('stroke-width', '3px')\r\n            .style('fill', 'white')\r\n            .style('clip-path', `url(#${block.getClipPathId()})`);\r\n        _helpers_domHelper__WEBPACK_IMPORTED_MODULE_1__.DomHelper.setCssClasses(newDots, _helpers_helper__WEBPACK_IMPORTED_MODULE_2__.Helper.getCssClassesWithElementIndex(chart.cssClasses, valueFieldIndex));\r\n        _helpers_domHelper__WEBPACK_IMPORTED_MODULE_1__.DomHelper.setChartElementColor(newDots, chart.style.elementColors, valueFieldIndex, 'stroke');\r\n        const animationName = 'data-updating';\r\n        dots\r\n            .interrupt(animationName)\r\n            .transition(animationName)\r\n            .duration(block.transitionManager.durations.chartUpdate)\r\n            .attr('cx', d => attrs.cx(d))\r\n            .attr('cy', d => attrs.cy(d));\r\n    }\r\n    static getAllDots(block) {\r\n        return block.getSvg().selectAll(`.${this.markerDotClass}`);\r\n    }\r\n    static getMarkDotForChart(block, chartCssClasses) {\r\n        return block.getSvg()\r\n            .selectAll(`.${MarkDot.markerDotClass}${_helpers_helper__WEBPACK_IMPORTED_MODULE_2__.Helper.getCssClassesLine(chartCssClasses)}`);\r\n    }\r\n}\r\nMarkDot.markerDotClass = 'dot';\r\nMarkDot.dotRadius = 4;\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/features/markDots/markDot.ts?");

/***/ }),

/***/ "./src/engine/features/markDots/markDotsHelper.ts":
/*!********************************************************!*\
  !*** ./src/engine/features/markDots/markDotsHelper.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MarkDotHelper\": () => /* binding */ MarkDotHelper\n/* harmony export */ });\n/* harmony import */ var _helpers_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../helpers/helper */ \"./src/engine/helpers/helper.ts\");\n/* harmony import */ var _scale_scale__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../scale/scale */ \"./src/engine/features/scale/scale.ts\");\n\r\n\r\nclass MarkDotHelper {\r\n    static getDotAttrs(keyAxisOrient, scales, margin, keyField, valueField, isSegmented) {\r\n        const attrs = { cx: null, cy: null };\r\n        if (keyAxisOrient === 'left' || keyAxisOrient === 'right') {\r\n            attrs.cx = d => scales.value(d[valueField]) + margin.left;\r\n            attrs.cy = d => _scale_scale__WEBPACK_IMPORTED_MODULE_1__.Scale.getScaledValue(scales.key, _helpers_helper__WEBPACK_IMPORTED_MODULE_0__.Helper.getKeyFieldValue(d, keyField, isSegmented)) + margin.top;\r\n        }\r\n        else if (keyAxisOrient === 'bottom' || keyAxisOrient === 'top') {\r\n            attrs.cx = d => _scale_scale__WEBPACK_IMPORTED_MODULE_1__.Scale.getScaledValue(scales.key, _helpers_helper__WEBPACK_IMPORTED_MODULE_0__.Helper.getKeyFieldValue(d, keyField, isSegmented)) + margin.left;\r\n            attrs.cy = d => scales.value(d[valueField]) + margin.top;\r\n        }\r\n        return attrs;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/features/markDots/markDotsHelper.ts?");

/***/ }),

/***/ "./src/engine/features/recordOverflowAlert/recordOverflowAlert.ts":
/*!************************************************************************!*\
  !*** ./src/engine/features/recordOverflowAlert/recordOverflowAlert.ts ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RecordOverflowAlert\": () => /* binding */ RecordOverflowAlert\n/* harmony export */ });\n/* harmony import */ var _helpers_domHelper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../helpers/domHelper */ \"./src/engine/helpers/domHelper.ts\");\n/* harmony import */ var _legend_legend__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../legend/legend */ \"./src/engine/features/legend/legend.ts\");\n\r\n\r\nclass RecordOverflowAlert {\r\n    static render(block, hidedRecordsAmount, position, chartOrientation = null) {\r\n        const alertBlock = block.getWrapper()\r\n            .append('div')\r\n            .attr('class', this.blockClass)\r\n            .text(this.getAlertText(hidedRecordsAmount, chartOrientation));\r\n        const attrs = this.getBlockPositionAttrs(position, block);\r\n        this.setAlertPosition(alertBlock, attrs);\r\n    }\r\n    static update(block, hidedRecordsAmount, position, chartOrientation = null) {\r\n        let alertBlock = block.getWrapper()\r\n            .select(`div.${this.blockClass}`);\r\n        if (alertBlock.empty()) {\r\n            if (hidedRecordsAmount === 0)\r\n                return;\r\n            else\r\n                this.render(block, hidedRecordsAmount, position, chartOrientation);\r\n        }\r\n        else {\r\n            if (hidedRecordsAmount === 0)\r\n                alertBlock.remove();\r\n            else\r\n                alertBlock.text(this.getAlertText(hidedRecordsAmount, chartOrientation));\r\n        }\r\n    }\r\n    static setAlertPosition(alertBlock, attrs) {\r\n        alertBlock\r\n            .style('position', 'absolute')\r\n            .style('left', attrs.left)\r\n            .style('right', attrs.right)\r\n            .style('top', attrs.top)\r\n            .style('bottom', attrs.bottom);\r\n    }\r\n    static getAlertText(hidedRecordsAmount, chartOrientation) {\r\n        return `+ ${hidedRecordsAmount} ${this.getWordTextEndingByAmount(hidedRecordsAmount, chartOrientation)}`;\r\n    }\r\n    static getWordTextEndingByAmount(hidedRecordsAmount, chartOrientation) {\r\n        const lastDigit = hidedRecordsAmount % 10;\r\n        if (chartOrientation === 'vertical') {\r\n            if (hidedRecordsAmount >= 10 && hidedRecordsAmount <= 20)\r\n                return 'столбцов';\r\n            if (lastDigit === 1)\r\n                return 'столбец';\r\n            if (lastDigit >= 2 && lastDigit <= 4)\r\n                return 'столбца';\r\n            return 'столбцов';\r\n        }\r\n        else if (chartOrientation === 'horizontal') {\r\n            if (hidedRecordsAmount >= 10 && hidedRecordsAmount <= 20)\r\n                return 'строк';\r\n            if (lastDigit === 1)\r\n                return 'строка';\r\n            if (lastDigit >= 2 && lastDigit <= 4)\r\n                return 'строки';\r\n            return 'строк';\r\n        }\r\n        else {\r\n            if (hidedRecordsAmount >= 10 && hidedRecordsAmount <= 20)\r\n                return 'категорий';\r\n            if (lastDigit === 1)\r\n                return 'категория';\r\n            if (lastDigit >= 2 && lastDigit <= 4)\r\n                return 'категории';\r\n            return 'категорий';\r\n        }\r\n    }\r\n    static getBlockPositionAttrs(position, block) {\r\n        const attrs = {\r\n            bottom: null,\r\n            top: null,\r\n            right: null,\r\n            left: null\r\n        };\r\n        if (position === 'top') {\r\n            attrs.right = '17px';\r\n            attrs.top = '1rem';\r\n        }\r\n        if (position === 'right') {\r\n            attrs.bottom = '20px';\r\n            attrs.left = this.getLeftAttrForRightBlock(block) + 'px';\r\n        }\r\n        if (position === 'bottom') {\r\n            attrs.left = '20px';\r\n            attrs.bottom = '20px';\r\n        }\r\n        return attrs;\r\n    }\r\n    static getLeftAttrForRightBlock(block) {\r\n        const legendBlock = block.getSvg().select(`.${_legend_legend__WEBPACK_IMPORTED_MODULE_1__.Legend.objectClass}`);\r\n        if (legendBlock.empty())\r\n            return null;\r\n        return _helpers_domHelper__WEBPACK_IMPORTED_MODULE_0__.DomHelper.getSelectionNumericAttr(legendBlock, 'x');\r\n    }\r\n}\r\nRecordOverflowAlert.blockClass = 'record-overflow-alert';\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/features/recordOverflowAlert/recordOverflowAlert.ts?");

/***/ }),

/***/ "./src/engine/features/scale/scale.ts":
/*!********************************************!*\
  !*** ./src/engine/features/scale/scale.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Scale\": () => /* binding */ Scale\n/* harmony export */ });\n/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-scale */ \"./node_modules/d3-scale/src/band.js\");\n/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-scale */ \"./node_modules/d3-scale/src/linear.js\");\n/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-scale */ \"./node_modules/d3-scale/src/time.js\");\n\r\nclass Scale {\r\n    static getScales(scaleKey, scaleValue, bandSettings) {\r\n        const scales = {\r\n            key: null,\r\n            value: null\r\n        };\r\n        if (scaleKey.type === 'band')\r\n            scales.key = this.getScaleBand(scaleKey.domain, scaleKey.range, bandSettings, scaleKey.elementsAmount);\r\n        else if (scaleKey.type === 'point')\r\n            scales.key = this.getScalePoint(scaleKey.domain, scaleKey.range);\r\n        if (scaleValue.type === 'linear')\r\n            scales.value = this.getScaleLinear(scaleValue.domain, scaleValue.range);\r\n        else if (scaleValue.type === 'datetime')\r\n            scales.value = this.getScaleTime(scaleValue.domain, scaleValue.range);\r\n        return scales;\r\n    }\r\n    static getScaleBandWidth(scale) {\r\n        if (scale.bandwidth && scale.bandwidth() !== 0) {\r\n            return scale.bandwidth();\r\n        }\r\n        else if (scale.step) {\r\n            return scale.step();\r\n        }\r\n    }\r\n    static getScaleStep(scale) {\r\n        if (scale.step) {\r\n            return scale.step();\r\n        }\r\n    }\r\n    static getScaledValue(scale, value) {\r\n        if (scale.bandwidth && scale.bandwidth() !== 0) {\r\n            return scale(value) + this.getScaleBandWidth(scale) / 2;\r\n        }\r\n        return scale(value);\r\n    }\r\n    static getScaleBand(domain, range, bandSettings, elementsInGroupAmount) {\r\n        const scale = (0,d3_scale__WEBPACK_IMPORTED_MODULE_0__.default)()\r\n            .domain(domain)\r\n            .range([range.start, range.end]);\r\n        const bandSize = scale.bandwidth();\r\n        if (bandSettings.groupMinDistance < bandSize) {\r\n            scale.paddingInner(bandSettings.groupMinDistance / bandSize);\r\n            scale.paddingOuter(bandSettings.groupMinDistance / bandSize / 2);\r\n        }\r\n        // Padding inner = 10. If bandwidth more than needed, paddingInner is increased to number less than 35 \r\n        let paddingInner = bandSettings.groupMinDistance;\r\n        while (scale.bandwidth() > bandSettings.maxBarWidth * elementsInGroupAmount + bandSettings.barDistance * (elementsInGroupAmount - 1) && paddingInner < bandSettings.groupMaxDistance) {\r\n            scale.paddingInner(++paddingInner / bandSize);\r\n        }\r\n        // if bandwidth more than all bars widths in group + distance between it + distance between groups\r\n        let paddingOuter = 1;\r\n        while (scale.step() > bandSettings.maxBarWidth * elementsInGroupAmount + bandSettings.groupMaxDistance + bandSettings.barDistance * (elementsInGroupAmount - 1)) {\r\n            scale.paddingOuter(++paddingOuter / bandSize);\r\n        }\r\n        return scale;\r\n    }\r\n    static getScaleLinear(domain, range) {\r\n        return (0,d3_scale__WEBPACK_IMPORTED_MODULE_1__.default)()\r\n            .domain(domain)\r\n            .range([range.start, range.end]);\r\n    }\r\n    static getScalePoint(domain, range) {\r\n        return (0,d3_scale__WEBPACK_IMPORTED_MODULE_0__.point)()\r\n            .domain(domain)\r\n            .range([range.start, range.end]);\r\n    }\r\n    static getScaleTime(domain, range) {\r\n        return (0,d3_scale__WEBPACK_IMPORTED_MODULE_2__.default)()\r\n            .domain(domain)\r\n            .range([range.start, range.end])\r\n            .nice();\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/features/scale/scale.ts?");

/***/ }),

/***/ "./src/engine/features/tipBox/tipBox.ts":
/*!**********************************************!*\
  !*** ./src/engine/features/tipBox/tipBox.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TipBox\": () => /* binding */ TipBox\n/* harmony export */ });\nclass TipBox {\r\n    static renderOrGet(block, margin, blockSize) {\r\n        const attributes = this.getAttributes(margin, blockSize);\r\n        return this.renderBlock(block, attributes);\r\n    }\r\n    static renderBlock(block, attributes) {\r\n        let tipBox = block.getSvg()\r\n            .select(`rect.${this.tipBoxClass}`);\r\n        if (tipBox.empty())\r\n            tipBox = block.getSvg()\r\n                .append('rect')\r\n                .attr('class', this.tipBoxClass)\r\n                .attr('x', attributes.x)\r\n                .attr('y', attributes.y)\r\n                .attr('width', attributes.width)\r\n                .attr('height', attributes.height)\r\n                .style('opacity', 0);\r\n        return tipBox;\r\n    }\r\n    static getAttributes(margin, blockSize) {\r\n        const pad = 5;\r\n        return {\r\n            x: margin.left - pad,\r\n            y: margin.top - pad,\r\n            width: blockSize.width - margin.left - margin.right + pad * 2,\r\n            height: blockSize.height - margin.top - margin.bottom + pad * 2,\r\n        };\r\n    }\r\n}\r\nTipBox.tipBoxClass = 'tipbox';\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/features/tipBox/tipBox.ts?");

/***/ }),

/***/ "./src/engine/features/tipBox/tipBoxHelper.ts":
/*!****************************************************!*\
  !*** ./src/engine/features/tipBox/tipBoxHelper.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TipBoxHelper\": () => /* binding */ TipBoxHelper\n/* harmony export */ });\n/* harmony import */ var _scale_scale__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../scale/scale */ \"./src/engine/features/scale/scale.ts\");\n\r\nclass TipBoxHelper {\r\n    static getKeyValueByPointer(pointer, chartOrient, margin, blockSize, scaleKey, scaleKeyType, t = 'hover') {\r\n        const index = TipBoxHelper.getKeyIndex(pointer, chartOrient, margin, blockSize, scaleKey, scaleKeyType);\r\n        let keyValue = scaleKey.domain()[index];\r\n        if (index >= scaleKey.domain().length)\r\n            keyValue = scaleKey.domain()[scaleKey.domain().length - 1];\r\n        return keyValue;\r\n    }\r\n    static getKeyIndex(pointer, chartOrient, margin, blockSize, scaleKey, scaleKeyType) {\r\n        const pointerAxisType = chartOrient === 'vertical' ? 0 : 1; // 0 - координата поинтера по оси x, 1 - по оси y\r\n        const marginByOrient = chartOrient === 'vertical' ? margin.left : margin.top;\r\n        const scaleStep = _scale_scale__WEBPACK_IMPORTED_MODULE_0__.Scale.getScaleStep(scaleKey);\r\n        if (scaleKeyType === 'point') {\r\n            return this.getKeyIndexOfPoint(pointer, scaleStep, marginByOrient, pointerAxisType);\r\n        }\r\n        else {\r\n            return this.getKeyIndexOfBand(pointer, scaleStep, marginByOrient, pointerAxisType, blockSize, margin, chartOrient, scaleKey);\r\n        }\r\n    }\r\n    static getKeyIndexOfPoint(pointer, scaleStep, marginByOrient, pointerAxisType) {\r\n        const point = pointer[pointerAxisType] - marginByOrient + scaleStep / 2;\r\n        if (point < 0)\r\n            return 0;\r\n        return Math.floor(point / scaleStep);\r\n    }\r\n    static getKeyIndexOfBand(pointer, scaleStep, marginByOrient, pointerAxisType, blockSize, margin, chartOrient, scaleKey) {\r\n        const chartBlockSizeByDir = chartOrient === 'vertical'\r\n            ? blockSize.width - margin.left - margin.right\r\n            : blockSize.height - margin.top - margin.bottom;\r\n        const outerPadding = chartBlockSizeByDir - scaleStep * scaleKey.domain().length;\r\n        if (pointer[pointerAxisType] - marginByOrient - 1 < outerPadding / 2)\r\n            return 0; // Самый первый элемент\r\n        if (pointer[pointerAxisType] - marginByOrient - 1 + outerPadding / 2 > chartBlockSizeByDir)\r\n            return scaleKey.domain().length - 1; // последний индекс\r\n        const point = pointer[pointerAxisType] - outerPadding / 2 - marginByOrient - 1;\r\n        return Math.floor(point / scaleStep);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/features/tipBox/tipBoxHelper.ts?");

/***/ }),

/***/ "./src/engine/features/title/title.ts":
/*!********************************************!*\
  !*** ./src/engine/features/title/title.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Title\": () => /* binding */ Title\n/* harmony export */ });\n/* harmony import */ var _helpers_domHelper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../helpers/domHelper */ \"./src/engine/helpers/domHelper.ts\");\n\r\nclass Title {\r\n    static render(block, text, titleBlockModel, blockSize) {\r\n        const titleBlock = block.getSvg()\r\n            .append('text')\r\n            .attr('class', 'chart-title');\r\n        const titleCoordinate = this.getTitleAttributes(blockSize, titleBlockModel);\r\n        this.fillTitleBlockAttributes(titleBlock, titleCoordinate, text);\r\n        this.setTitleTooltip(titleBlock, text);\r\n    }\r\n    static fillTitleBlockAttributes(titleBlock, attributes, text) {\r\n        titleBlock\r\n            .attr('x', attributes.x)\r\n            .attr('y', attributes.y)\r\n            .attr('width', attributes.width)\r\n            .attr('height', attributes.height)\r\n            .attr('dominant-baseline', attributes.dominantBaseline)\r\n            .text(text);\r\n        _helpers_domHelper__WEBPACK_IMPORTED_MODULE_0__.DomHelper.cropSvgLabels(titleBlock, attributes.width);\r\n    }\r\n    static getTitleAttributes(blockSize, titleBlockModel) {\r\n        const coordinate = {\r\n            x: 0,\r\n            y: 0,\r\n            width: 0,\r\n            height: 0,\r\n            dominantBaseline: \"hanging\"\r\n        };\r\n        coordinate.x = titleBlockModel.margin.left;\r\n        coordinate.y = titleBlockModel.margin.top;\r\n        coordinate.width = blockSize.width - titleBlockModel.margin.left - titleBlockModel.margin.right;\r\n        coordinate.height = titleBlockModel.size;\r\n        return coordinate;\r\n    }\r\n    static setTitleTooltip(titleBlock, text) {\r\n        titleBlock.append('title')\r\n            .text(text);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/features/title/title.ts?");

/***/ }),

/***/ "./src/engine/features/tolltip/tooltip.ts":
/*!************************************************!*\
  !*** ./src/engine/features/tolltip/tooltip.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Tooltip\": () => /* binding */ Tooltip\n/* harmony export */ });\n/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-selection */ \"./node_modules/d3-selection/src/pointer.js\");\n/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-selection */ \"./node_modules/d3-selection/src/select.js\");\n/* harmony import */ var _tooltipDomHelper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tooltipDomHelper */ \"./src/engine/features/tolltip/tooltipDomHelper.ts\");\n/* harmony import */ var _polarNotation_donut_donut__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../polarNotation/donut/donut */ \"./src/engine/polarNotation/donut/donut.ts\");\n/* harmony import */ var _tooltipComponentsManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tooltipComponentsManager */ \"./src/engine/features/tolltip/tooltipComponentsManager.ts\");\n/* harmony import */ var _elementHighlighter_elementHighlighter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../elementHighlighter/elementHighlighter */ \"./src/engine/elementHighlighter/elementHighlighter.ts\");\n/* harmony import */ var _polarNotation_donut_DonutHelper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../polarNotation/donut/DonutHelper */ \"./src/engine/polarNotation/donut/DonutHelper.ts\");\n/* harmony import */ var _tipBox_tipBox__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../tipBox/tipBox */ \"./src/engine/features/tipBox/tipBox.ts\");\n/* harmony import */ var _tipBox_tipBoxHelper__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../tipBox/tipBoxHelper */ \"./src/engine/features/tipBox/tipBoxHelper.ts\");\n/* harmony import */ var _helpers_helper__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../helpers/helper */ \"./src/engine/helpers/helper.ts\");\n/* harmony import */ var _tooltipHelper__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./tooltipHelper */ \"./src/engine/features/tolltip/tooltipHelper.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass Tooltip {\r\n    static render(block, model, data, tooltipOptions, scales) {\r\n        _tooltipComponentsManager__WEBPACK_IMPORTED_MODULE_2__.TooltipComponentsManager.renderTooltipWrapper(block);\r\n        const withTooltipIndex = model.options.charts.findIndex((chart) => chart.tooltip.show);\r\n        if (withTooltipIndex !== -1) {\r\n            if (model.options.type === '2d') {\r\n                this.renderTooltipFor2DCharts(block, data, model.blockCanvas.size, model.chartBlock.margin, scales.key, model.options, tooltipOptions);\r\n            }\r\n            else if (model.options.type === 'polar') {\r\n                this.renderTooltipForPolar(block, model.options.charts, data, model.options.data, model.blockCanvas.size, model.chartBlock.margin, _polarNotation_donut_DonutHelper__WEBPACK_IMPORTED_MODULE_4__.DonutHelper.getThickness(model.chartSettings.donut, model.blockCanvas.size, model.chartBlock.margin), model.otherComponents.tooltipBlock);\r\n            }\r\n        }\r\n    }\r\n    static hide(block) {\r\n        _tooltipComponentsManager__WEBPACK_IMPORTED_MODULE_2__.TooltipComponentsManager.hideTooltipBlock(block.getWrapper().select(`.${this.tooltipBlockClass}`));\r\n    }\r\n    static renderTooltipFor2DCharts(block, data, blockSize, margin, scaleKey, options, tooltipOptions) {\r\n        if (scaleKey.domain().length === 0)\r\n            return;\r\n        this.renderLineTooltip(block, scaleKey, margin, blockSize, options.charts, options.orient, options.axis.key.orient, data, options.data, options.scale.key, tooltipOptions);\r\n    }\r\n    static renderTooltipForPolar(block, charts, data, dataOptions, blockSize, margin, chartThickness, tooltipOptions) {\r\n        charts.forEach(chart => {\r\n            const attrTransform = block.getSvg().select(`.${_polarNotation_donut_donut__WEBPACK_IMPORTED_MODULE_1__.Donut.donutBlockClass}`).attr('transform');\r\n            const translateNums = _helpers_helper__WEBPACK_IMPORTED_MODULE_7__.Helper.getTranslateNumbers(attrTransform);\r\n            const arcItems = _polarNotation_donut_donut__WEBPACK_IMPORTED_MODULE_1__.Donut.getAllArcGroups(block);\r\n            this.renderTooltipForDonut(block, arcItems, data, dataOptions, chart, blockSize, margin, chartThickness, tooltipOptions, translateNums[0], translateNums[1]);\r\n        });\r\n    }\r\n    static renderLineTooltip(block, scaleKey, margin, blockSize, charts, chartOrientation, keyAxisOrient, data, dataOptions, scaleKeyModel, tooltipOptions) {\r\n        const tooltipBlock = _tooltipComponentsManager__WEBPACK_IMPORTED_MODULE_2__.TooltipComponentsManager.renderTooltipBlock(block);\r\n        const tooltipContent = _tooltipComponentsManager__WEBPACK_IMPORTED_MODULE_2__.TooltipComponentsManager.renderTooltipContentBlock(tooltipBlock);\r\n        const tooltipLine = _tooltipComponentsManager__WEBPACK_IMPORTED_MODULE_2__.TooltipComponentsManager.renderTooltipLine(block);\r\n        const tipBox = _tipBox_tipBox__WEBPACK_IMPORTED_MODULE_5__.TipBox.renderOrGet(block, margin, blockSize);\r\n        _elementHighlighter_elementHighlighter__WEBPACK_IMPORTED_MODULE_3__.ElementHighlighter.renderShadowFilter(block);\r\n        let currentKey = null;\r\n        tipBox.on('mousemove', function (e) {\r\n            const keyValue = _tipBox_tipBoxHelper__WEBPACK_IMPORTED_MODULE_6__.TipBoxHelper.getKeyValueByPointer((0,d3_selection__WEBPACK_IMPORTED_MODULE_9__.default)(e, this), chartOrientation, margin, blockSize, scaleKey, scaleKeyModel.type, 'hover');\r\n            if (tooltipOptions.position === 'followCursor') {\r\n                const tooltipCoordinate = _tooltipHelper__WEBPACK_IMPORTED_MODULE_8__.TooltipHelper.getTooltipCursorCoordinate((0,d3_selection__WEBPACK_IMPORTED_MODULE_9__.default)(e, this), block.getSvg().node().getBoundingClientRect(), tooltipContent.node().getBoundingClientRect(), window.innerWidth, window.innerHeight);\r\n                _tooltipComponentsManager__WEBPACK_IMPORTED_MODULE_2__.TooltipComponentsManager.setLineTooltipCoordinate(tooltipBlock, tooltipCoordinate, chartOrientation, 0);\r\n            }\r\n            if (!currentKey || currentKey !== keyValue) {\r\n                currentKey = keyValue;\r\n                _tooltipComponentsManager__WEBPACK_IMPORTED_MODULE_2__.TooltipComponentsManager.showTooltipBlock(tooltipBlock);\r\n                _tooltipDomHelper__WEBPACK_IMPORTED_MODULE_0__.TooltipDomHelper.fillForMulty2DCharts(tooltipContent, charts.filter(ch => ch.tooltip.show), data, dataOptions, keyValue);\r\n                if (tooltipOptions.position === 'fixed') {\r\n                    const tooltipCoordinate = _tooltipHelper__WEBPACK_IMPORTED_MODULE_8__.TooltipHelper.getTooltipFixedCoordinate(scaleKey, margin, keyValue, block.getSvg().node().getBoundingClientRect(), tooltipContent.node().getBoundingClientRect(), keyAxisOrient, window.innerWidth, window.innerHeight);\r\n                    _tooltipComponentsManager__WEBPACK_IMPORTED_MODULE_2__.TooltipComponentsManager.setLineTooltipCoordinate(tooltipBlock, tooltipCoordinate, chartOrientation, block.transitionManager.durations.tooltipSlide);\r\n                }\r\n                const tooltipLineAttributes = _tooltipHelper__WEBPACK_IMPORTED_MODULE_8__.TooltipHelper.getTooltipLineAttributes(scaleKey, margin, keyValue, chartOrientation, blockSize);\r\n                _tooltipComponentsManager__WEBPACK_IMPORTED_MODULE_2__.TooltipComponentsManager.setTooltipLineAttributes(tooltipLine, tooltipLineAttributes, block.transitionManager.durations.tooltipSlide);\r\n                _tooltipComponentsManager__WEBPACK_IMPORTED_MODULE_2__.TooltipComponentsManager.showTooltipLine(tooltipLine);\r\n                _elementHighlighter_elementHighlighter__WEBPACK_IMPORTED_MODULE_3__.ElementHighlighter.highlight2DElementsHover(block, dataOptions.keyField.name, keyValue, charts, block.transitionManager.durations.markerHover);\r\n            }\r\n        });\r\n        tipBox.on('mouseleave', function () {\r\n            _tooltipComponentsManager__WEBPACK_IMPORTED_MODULE_2__.TooltipComponentsManager.hideTooltipBlock(tooltipBlock);\r\n            _tooltipComponentsManager__WEBPACK_IMPORTED_MODULE_2__.TooltipComponentsManager.hideTooltipLine(tooltipLine);\r\n            currentKey = null;\r\n            _elementHighlighter_elementHighlighter__WEBPACK_IMPORTED_MODULE_3__.ElementHighlighter.removeUnselected2DHighlight(block, dataOptions.keyField.name, charts, block.transitionManager.durations.markerHover);\r\n        });\r\n    }\r\n    static renderTooltipForDonut(block, elements, data, dataOptions, chart, blockSize, margin, donutThickness, tooltipOptions, translateX = 0, translateY = 0) {\r\n        const tooltipBlock = _tooltipComponentsManager__WEBPACK_IMPORTED_MODULE_2__.TooltipComponentsManager.renderTooltipBlock(block);\r\n        const tooltipContent = _tooltipComponentsManager__WEBPACK_IMPORTED_MODULE_2__.TooltipComponentsManager.renderTooltipContentBlock(tooltipBlock);\r\n        let tooltipArrow;\r\n        if (tooltipOptions.position === 'fixed')\r\n            tooltipArrow = _tooltipComponentsManager__WEBPACK_IMPORTED_MODULE_2__.TooltipComponentsManager.renderTooltipArrow(tooltipBlock);\r\n        _elementHighlighter_elementHighlighter__WEBPACK_IMPORTED_MODULE_3__.ElementHighlighter.renderShadowFilter(block);\r\n        if (tooltipOptions.position === 'followCursor') {\r\n            elements.on('mousemove', function (e) {\r\n                const pointerCoordinate = !(0,d3_selection__WEBPACK_IMPORTED_MODULE_9__.default)(e, block.getSvg().node())[0] ? e.detail.pointer : (0,d3_selection__WEBPACK_IMPORTED_MODULE_9__.default)(e, block.getSvg().node());\r\n                const tooltipCoordinate = _tooltipHelper__WEBPACK_IMPORTED_MODULE_8__.TooltipHelper.getTooltipCursorCoordinate(pointerCoordinate, block.getSvg().node().getBoundingClientRect(), tooltipContent.node().getBoundingClientRect(), window.innerWidth, window.innerHeight);\r\n                _tooltipComponentsManager__WEBPACK_IMPORTED_MODULE_2__.TooltipComponentsManager.setBlockCoordinate(tooltipBlock, tooltipCoordinate);\r\n            });\r\n        }\r\n        elements.on('mouseover', function (e, dataRow) {\r\n            _tooltipComponentsManager__WEBPACK_IMPORTED_MODULE_2__.TooltipComponentsManager.showTooltipBlock(tooltipBlock);\r\n            _tooltipDomHelper__WEBPACK_IMPORTED_MODULE_0__.TooltipDomHelper.fillTextForPolarChart(tooltipContent, chart, data, dataOptions, dataRow.data[dataOptions.keyField.name], (0,d3_selection__WEBPACK_IMPORTED_MODULE_10__.default)(this).select('path').style('fill'));\r\n            if (tooltipOptions.position === 'fixed') {\r\n                const coordinatePointer = _tooltipDomHelper__WEBPACK_IMPORTED_MODULE_0__.TooltipDomHelper.getRecalcedCoordinateByArrow(_polarNotation_donut_DonutHelper__WEBPACK_IMPORTED_MODULE_4__.DonutHelper.getArcCentroid(blockSize, margin, dataRow, donutThickness), tooltipBlock, blockSize, tooltipArrow, translateX, translateY);\r\n                coordinatePointer[0] = coordinatePointer[0] + translateX;\r\n                coordinatePointer[1] = coordinatePointer[1] + translateY;\r\n                const tooltipCoordinate = _tooltipHelper__WEBPACK_IMPORTED_MODULE_8__.TooltipHelper.getCoordinateByPointer(coordinatePointer);\r\n                _tooltipComponentsManager__WEBPACK_IMPORTED_MODULE_2__.TooltipComponentsManager.setBlockCoordinate(tooltipBlock, tooltipCoordinate);\r\n            }\r\n            _elementHighlighter_elementHighlighter__WEBPACK_IMPORTED_MODULE_3__.ElementHighlighter.toggleActivityStyle((0,d3_selection__WEBPACK_IMPORTED_MODULE_10__.default)(this), true);\r\n            const clones = _polarNotation_donut_donut__WEBPACK_IMPORTED_MODULE_1__.Donut.getAllArcClones(block)\r\n                .filter((d) => d.data[dataOptions.keyField.name] === dataRow.data[dataOptions.keyField.name]);\r\n            if (clones.nodes().length === 0 && (block.filterEventManager.getSelectedKeys().length === 0 || block.filterEventManager.isSelected(dataRow.data[dataOptions.keyField.name]))) {\r\n                _elementHighlighter_elementHighlighter__WEBPACK_IMPORTED_MODULE_3__.ElementHighlighter.renderArcCloneAndHighlight(block, margin, (0,d3_selection__WEBPACK_IMPORTED_MODULE_10__.default)(this), blockSize, donutThickness);\r\n            }\r\n        });\r\n        elements.on('mouseleave', function (e, dataRow) {\r\n            _tooltipComponentsManager__WEBPACK_IMPORTED_MODULE_2__.TooltipComponentsManager.hideTooltipBlock(tooltipBlock);\r\n            if (!block.filterEventManager.isSelected(dataRow.data[dataOptions.keyField.name])) {\r\n                _elementHighlighter_elementHighlighter__WEBPACK_IMPORTED_MODULE_3__.ElementHighlighter.removeCloneForElem(block, dataOptions.keyField.name, (0,d3_selection__WEBPACK_IMPORTED_MODULE_10__.default)(this));\r\n                _elementHighlighter_elementHighlighter__WEBPACK_IMPORTED_MODULE_3__.ElementHighlighter.toggleDonutHighlightState((0,d3_selection__WEBPACK_IMPORTED_MODULE_10__.default)(this), margin, blockSize, donutThickness, block.transitionManager.durations.donutHover, false);\r\n                if (block.filterEventManager.getSelectedKeys().length > 0) {\r\n                    _elementHighlighter_elementHighlighter__WEBPACK_IMPORTED_MODULE_3__.ElementHighlighter.toggleActivityStyle((0,d3_selection__WEBPACK_IMPORTED_MODULE_10__.default)(this), false);\r\n                }\r\n            }\r\n        });\r\n    }\r\n}\r\nTooltip.tooltipBlockClass = 'tooltip-block';\r\nTooltip.tooltipLineClass = 'tooltip-line';\r\nTooltip.tooltipWrapperClass = 'tooltip-wrapper';\r\nTooltip.tooltipContentClass = 'tooltip-content';\r\nTooltip.tooltipArrowClass = 'tooltip-arrow';\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/features/tolltip/tooltip.ts?");

/***/ }),

/***/ "./src/engine/features/tolltip/tooltipComponentsManager.ts":
/*!*****************************************************************!*\
  !*** ./src/engine/features/tolltip/tooltipComponentsManager.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TooltipComponentsManager\": () => /* binding */ TooltipComponentsManager\n/* harmony export */ });\n/* harmony import */ var _tooltipDomHelper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tooltipDomHelper */ \"./src/engine/features/tolltip/tooltipDomHelper.ts\");\n/* harmony import */ var d3_ease__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-ease */ \"./node_modules/d3-ease/src/linear.js\");\n/* harmony import */ var d3_transition__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-transition */ \"./node_modules/d3-transition/src/index.js\");\n/* harmony import */ var _tooltip__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tooltip */ \"./src/engine/features/tolltip/tooltip.ts\");\n\r\n\r\n\r\n\r\nclass TooltipComponentsManager {\r\n    static showTooltipBlock(tooltipBlock) {\r\n        tooltipBlock.style('display', 'block');\r\n    }\r\n    static hideTooltipBlock(tooltipBlock) {\r\n        tooltipBlock.style('display', 'none');\r\n    }\r\n    static renderTooltipWrapper(block) {\r\n        let tooltipWrapper = block.getWrapper()\r\n            .select(`.${_tooltip__WEBPACK_IMPORTED_MODULE_2__.Tooltip.tooltipWrapperClass}`);\r\n        if (tooltipWrapper.empty())\r\n            block.getWrapper()\r\n                .append('div')\r\n                .attr('class', _tooltip__WEBPACK_IMPORTED_MODULE_2__.Tooltip.tooltipWrapperClass);\r\n    }\r\n    static renderTooltipBlock(block, translateX = 0, translateY = 0) {\r\n        const wrapper = block.getWrapper().select(`.${_tooltip__WEBPACK_IMPORTED_MODULE_2__.Tooltip.tooltipWrapperClass}`);\r\n        let tooltipBlock = wrapper.select(`.${_tooltip__WEBPACK_IMPORTED_MODULE_2__.Tooltip.tooltipBlockClass}`);\r\n        if (tooltipBlock.empty()) {\r\n            tooltipBlock = wrapper\r\n                .append('div')\r\n                .attr('class', _tooltip__WEBPACK_IMPORTED_MODULE_2__.Tooltip.tooltipBlockClass)\r\n                .style('position', 'absolute')\r\n                .style('display', 'none');\r\n        }\r\n        if (translateX !== 0 || translateY !== 0)\r\n            tooltipBlock.style('transform', `translate(${translateX}px, ${translateY}px)`);\r\n        return tooltipBlock;\r\n    }\r\n    static renderTooltipContentBlock(tooltipBlock) {\r\n        let tooltipContentBlock = tooltipBlock.select(`.${_tooltip__WEBPACK_IMPORTED_MODULE_2__.Tooltip.tooltipContentClass}`);\r\n        if (tooltipContentBlock.empty())\r\n            tooltipContentBlock = tooltipBlock.append('div')\r\n                .attr('class', _tooltip__WEBPACK_IMPORTED_MODULE_2__.Tooltip.tooltipContentClass);\r\n        return tooltipContentBlock;\r\n    }\r\n    static renderTooltipLine(block) {\r\n        let tooltipLine = block.getChartBlock()\r\n            .select(`.${_tooltip__WEBPACK_IMPORTED_MODULE_2__.Tooltip.tooltipLineClass}`);\r\n        if (tooltipLine.empty())\r\n            tooltipLine = block.getChartBlock()\r\n                .append('line')\r\n                .attr('class', _tooltip__WEBPACK_IMPORTED_MODULE_2__.Tooltip.tooltipLineClass)\r\n                .lower();\r\n        return tooltipLine;\r\n    }\r\n    static showTooltipLine(tooltipLine) {\r\n        tooltipLine.style('display', 'block');\r\n    }\r\n    static hideTooltipLine(tooltipLine) {\r\n        tooltipLine.style('display', 'none');\r\n    }\r\n    static setTooltipLineAttributes(tooltipLine, attributes, transition) {\r\n        (0,d3_transition__WEBPACK_IMPORTED_MODULE_1__.interrupt)(tooltipLine.node());\r\n        if (transition > 0 && tooltipLine.style('display') === 'block') {\r\n            tooltipLine\r\n                .interrupt()\r\n                .transition()\r\n                .duration(transition)\r\n                .ease(d3_ease__WEBPACK_IMPORTED_MODULE_3__.linear)\r\n                .attr('x1', attributes.x1)\r\n                .attr('x2', attributes.x2)\r\n                .attr('y1', attributes.y1)\r\n                .attr('y2', attributes.y2);\r\n        }\r\n        else {\r\n            tooltipLine\r\n                .attr('x1', attributes.x1)\r\n                .attr('x2', attributes.x2)\r\n                .attr('y1', attributes.y1)\r\n                .attr('y2', attributes.y2);\r\n        }\r\n    }\r\n    static renderTooltipArrow(tooltipBlock) {\r\n        let arrowSize = _tooltipDomHelper__WEBPACK_IMPORTED_MODULE_0__.ARROW_SIZE / 2;\r\n        let tooltipArrow = tooltipBlock.select(`.${_tooltip__WEBPACK_IMPORTED_MODULE_2__.Tooltip.tooltipArrowClass}`);\r\n        if (tooltipArrow.empty())\r\n            tooltipArrow = tooltipBlock\r\n                .append('div')\r\n                .attr('class', _tooltip__WEBPACK_IMPORTED_MODULE_2__.Tooltip.tooltipArrowClass)\r\n                .style('position', 'absolute')\r\n                .style('left', `${_tooltipDomHelper__WEBPACK_IMPORTED_MODULE_0__.ARROW_DEFAULT_POSITION}px`)\r\n                .style('border-top-width', `${arrowSize}px`)\r\n                .style('border-right-width', `${arrowSize}px`)\r\n                .style('border-bottom-width', `0px`)\r\n                .style('border-left-width', `${arrowSize}px`);\r\n        return tooltipArrow;\r\n    }\r\n    static setBlockCoordinate(tooltipBlock, tooltipCoordinate) {\r\n        tooltipBlock\r\n            .style('right', tooltipCoordinate.right)\r\n            .style('bottom', tooltipCoordinate.bottom)\r\n            .style('left', tooltipCoordinate.left)\r\n            .style('top', tooltipCoordinate.top);\r\n    }\r\n    static setLineTooltipCoordinate(tooltipBlock, tooltipCoordinate, chartOrientation, transition = null) {\r\n        (0,d3_transition__WEBPACK_IMPORTED_MODULE_1__.interrupt)(tooltipBlock.node());\r\n        if (!transition || transition <= 0)\r\n            this.setBlockCoordinate(tooltipBlock, tooltipCoordinate);\r\n        if (chartOrientation === 'vertical' && tooltipBlock.style('left') !== '0px' && tooltipBlock.style('right') !== '0px' && tooltipCoordinate.right !== '0px' && tooltipCoordinate.left !== null) {\r\n            tooltipBlock\r\n                .style('right', tooltipCoordinate.right)\r\n                .style('bottom', tooltipCoordinate.bottom)\r\n                .style('top', tooltipCoordinate.top)\r\n                .interrupt()\r\n                .transition()\r\n                .duration(transition)\r\n                .ease(d3_ease__WEBPACK_IMPORTED_MODULE_3__.linear)\r\n                .style('left', tooltipCoordinate.left);\r\n        }\r\n        else if (chartOrientation === 'horizontal' && tooltipBlock.style('top') !== '0px' && parseInt(tooltipBlock.style('bottom')) > 0 && tooltipCoordinate.bottom === null) {\r\n            tooltipBlock\r\n                .style('left', tooltipCoordinate.left)\r\n                .style('bottom', tooltipCoordinate.bottom)\r\n                .style('right', tooltipCoordinate.right)\r\n                .interrupt()\r\n                .transition()\r\n                .duration(transition)\r\n                .ease(d3_ease__WEBPACK_IMPORTED_MODULE_3__.linear)\r\n                .style('top', tooltipCoordinate.top);\r\n        }\r\n        else {\r\n            this.setBlockCoordinate(tooltipBlock, tooltipCoordinate);\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/features/tolltip/tooltipComponentsManager.ts?");

/***/ }),

/***/ "./src/engine/features/tolltip/tooltipDomHelper.ts":
/*!*********************************************************!*\
  !*** ./src/engine/features/tolltip/tooltipDomHelper.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ARROW_SIZE\": () => /* binding */ ARROW_SIZE,\n/* harmony export */   \"ARROW_DEFAULT_POSITION\": () => /* binding */ ARROW_DEFAULT_POSITION,\n/* harmony export */   \"TOOLTIP_ARROW_PADDING_X\": () => /* binding */ TOOLTIP_ARROW_PADDING_X,\n/* harmony export */   \"TOOLTIP_ARROW_PADDING_Y\": () => /* binding */ TOOLTIP_ARROW_PADDING_Y,\n/* harmony export */   \"TooltipDomHelper\": () => /* binding */ TooltipDomHelper\n/* harmony export */ });\n/* harmony import */ var _valueFormatter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../valueFormatter */ \"./src/engine/valueFormatter.ts\");\n/* harmony import */ var _tooltipHelper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tooltipHelper */ \"./src/engine/features/tolltip/tooltipHelper.ts\");\n\r\n\r\nconst ARROW_SIZE = 20;\r\nconst ARROW_DEFAULT_POSITION = 9;\r\nconst TOOLTIP_ARROW_PADDING_X = ARROW_DEFAULT_POSITION - (ARROW_SIZE * Math.sqrt(2) - ARROW_SIZE) / 2 + 14;\r\nconst TOOLTIP_ARROW_PADDING_Y = 13;\r\nclass TooltipDomHelper {\r\n    static fillForMulty2DCharts(contentBlock, charts, data, dataOptions, keyValue) {\r\n        contentBlock.html('');\r\n        contentBlock.append('div')\r\n            .attr('class', `${this.tooltipGroupClass} ${this.tooltipHeadClass}`)\r\n            .style('white-space', 'nowrap')\r\n            .text(keyValue);\r\n        charts.forEach(chart => {\r\n            chart.data.valueFields.forEach((field, index) => {\r\n                const html = this.getTooltipItemHtml(data, dataOptions, keyValue, field);\r\n                this.fillTooltipContent(contentBlock, chart.style.elementColors[index % chart.style.elementColors.length], html);\r\n            });\r\n        });\r\n    }\r\n    static fillTextForPolarChart(contentBlock, chart, data, dataOptions, keyValue, markColor) {\r\n        contentBlock.html('');\r\n        contentBlock.append('div')\r\n            .attr('class', `${this.tooltipGroupClass} ${this.tooltipHeadClass}`)\r\n            .text(keyValue);\r\n        const text = this.getTooltipItemHtml(data, dataOptions, keyValue, chart.data.valueField);\r\n        this.fillTooltipContent(contentBlock, markColor, text);\r\n    }\r\n    static getRecalcedCoordinateByArrow(coordinate, tooltipBlock, blockSize, tooltipArrow, translateX = 0, translateY = 0) {\r\n        const tooltipBlockNode = tooltipBlock.node();\r\n        const horizontalPad = _tooltipHelper__WEBPACK_IMPORTED_MODULE_1__.TooltipHelper.getHorizontalPad(coordinate[0], tooltipBlockNode.getBoundingClientRect().width, blockSize, translateX);\r\n        const verticalPad = _tooltipHelper__WEBPACK_IMPORTED_MODULE_1__.TooltipHelper.getVerticalPad(coordinate[1], tooltipBlockNode.getBoundingClientRect().height, translateY);\r\n        this.setTooltipArrowCoordinate(tooltipArrow, _tooltipHelper__WEBPACK_IMPORTED_MODULE_1__.TooltipHelper.getTooltipArrowPadding(tooltipBlockNode.getBoundingClientRect().width, horizontalPad));\r\n        return [coordinate[0] - TOOLTIP_ARROW_PADDING_X - horizontalPad,\r\n            coordinate[1] - TOOLTIP_ARROW_PADDING_Y - tooltipBlockNode.getBoundingClientRect().height - verticalPad];\r\n    }\r\n    static fillTooltipContent(contentBlock, markColor, tooltipText) {\r\n        const group = contentBlock.append('div')\r\n            .attr('class', this.tooltipGroupClass);\r\n        group.append('div')\r\n            .attr('class', 'tooltip-color')\r\n            .append('span')\r\n            .attr('class', 'tooltip-circle')\r\n            .style('background-color', markColor);\r\n        const textBlock = group.append('div')\r\n            .attr('class', 'tooltip-texts')\r\n            .append('div')\r\n            .attr('class', 'tooltip-text-item')\r\n            .html(tooltipText)\r\n            .style('white-space', 'nowrap');\r\n        if (textBlock.node().getBoundingClientRect().width >= 450) {\r\n            textBlock.style('white-space', 'normal');\r\n            contentBlock.select(`.${this.tooltipHeadClass}`).style('white-space', 'normal');\r\n        }\r\n    }\r\n    static getTooltipItemHtml(data, dataOptions, keyValue, valueField) {\r\n        const row = data[dataOptions.dataSource].find(d => d[dataOptions.keyField.name] === keyValue);\r\n        let text;\r\n        text = `<span class=\"tooltip-field-title\">${valueField.title}</span><span class=\"tooltip-field-value\">${_valueFormatter__WEBPACK_IMPORTED_MODULE_0__.ValueFormatter.formatField(valueField.format, row[valueField.name])}</span>`;\r\n        return text;\r\n    }\r\n    static setTooltipArrowCoordinate(tooltipArrow, horizontalPad) {\r\n        if (horizontalPad !== 0)\r\n            tooltipArrow.style('left', `${ARROW_DEFAULT_POSITION + Math.floor(horizontalPad)}px`);\r\n        else\r\n            tooltipArrow.style('left', `${ARROW_DEFAULT_POSITION}px`);\r\n    }\r\n}\r\nTooltipDomHelper.tooltipGroupClass = 'tooltip-group';\r\nTooltipDomHelper.tooltipHeadClass = 'tooltip-head';\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/features/tolltip/tooltipDomHelper.ts?");

/***/ }),

/***/ "./src/engine/features/tolltip/tooltipHelper.ts":
/*!******************************************************!*\
  !*** ./src/engine/features/tolltip/tooltipHelper.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TooltipHelper\": () => /* binding */ TooltipHelper\n/* harmony export */ });\n/* harmony import */ var _helpers_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../helpers/helper */ \"./src/engine/helpers/helper.ts\");\n/* harmony import */ var _scale_scale__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../scale/scale */ \"./src/engine/features/scale/scale.ts\");\n/* harmony import */ var _tooltipDomHelper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tooltipDomHelper */ \"./src/engine/features/tolltip/tooltipDomHelper.ts\");\n\r\n\r\n\r\nclass TooltipHelper {\r\n    static getHorizontalPad(coordinateX, tooltipBlockWidth, blockSize, translateX) {\r\n        let pad = 0;\r\n        if (tooltipBlockWidth + coordinateX - _tooltipDomHelper__WEBPACK_IMPORTED_MODULE_2__.TOOLTIP_ARROW_PADDING_X + translateX > blockSize.width)\r\n            pad = tooltipBlockWidth + coordinateX - _tooltipDomHelper__WEBPACK_IMPORTED_MODULE_2__.TOOLTIP_ARROW_PADDING_X + translateX - blockSize.width;\r\n        return pad;\r\n    }\r\n    static getVerticalPad(coordinateY, tooltipBlockHeight, translateY) {\r\n        let pad = 0;\r\n        if (coordinateY - _tooltipDomHelper__WEBPACK_IMPORTED_MODULE_2__.TOOLTIP_ARROW_PADDING_Y - tooltipBlockHeight + translateY < -tooltipBlockHeight - _tooltipDomHelper__WEBPACK_IMPORTED_MODULE_2__.TOOLTIP_ARROW_PADDING_Y)\r\n            pad = coordinateY;\r\n        return pad; // return zero or sub zero\r\n    }\r\n    static getTooltipArrowPadding(tooltipBlockWidth, horizontalPad) {\r\n        return horizontalPad > tooltipBlockWidth\r\n            ? tooltipBlockWidth - _tooltipDomHelper__WEBPACK_IMPORTED_MODULE_2__.ARROW_DEFAULT_POSITION - 20 * Math.sqrt(2)\r\n            : horizontalPad; // If tooltip arrow has coordinate outside svg, it take X position in end of tooltip block\r\n    }\r\n    static getCoordinateByPointer(pointer) {\r\n        const coordinate = {\r\n            left: null,\r\n            top: null,\r\n            right: null,\r\n            bottom: null\r\n        };\r\n        coordinate.left = pointer[0] + 'px';\r\n        coordinate.top = pointer[1] + 'px';\r\n        return coordinate;\r\n    }\r\n    static getTooltipFixedCoordinate(scaleKey, margin, keyValue, blockBoundingRect, tooltipBoundingRect, keyAxisOrient, winWidth, winHeight) {\r\n        const coordinate = {\r\n            top: null,\r\n            bottom: null,\r\n            left: null,\r\n            right: null\r\n        };\r\n        if (keyAxisOrient === 'bottom' || keyAxisOrient === 'top') {\r\n            coordinate.left = _scale_scale__WEBPACK_IMPORTED_MODULE_1__.Scale.getScaledValue(scaleKey, keyValue) + margin.left - tooltipBoundingRect.width / 2 + 'px';\r\n            if (keyAxisOrient === 'bottom')\r\n                coordinate.top = margin.top - 5 - tooltipBoundingRect.height + 'px';\r\n            else\r\n                coordinate.top = blockBoundingRect.height - margin.bottom + 'px';\r\n        }\r\n        if (keyAxisOrient === 'left' || keyAxisOrient === 'right') {\r\n            coordinate.top = _scale_scale__WEBPACK_IMPORTED_MODULE_1__.Scale.getScaledValue(scaleKey, keyValue) + margin.top - tooltipBoundingRect.height / 2 + 'px';\r\n            if (keyAxisOrient === 'left')\r\n                coordinate.left = blockBoundingRect.width - margin.right + 'px';\r\n            else\r\n                coordinate.left = margin.left - tooltipBoundingRect.width + 'px';\r\n        }\r\n        return this.recalcToolTipCoordinateByViewPort(blockBoundingRect, tooltipBoundingRect, coordinate, winWidth, winHeight);\r\n    }\r\n    static getTooltipCursorCoordinate(pointer, blockBoundingRect, tooltipBoundingRect, winWidth, winHeight) {\r\n        const pad = 10;\r\n        const coordinate = {\r\n            top: pointer[1] + pad + 'px',\r\n            bottom: null,\r\n            left: pointer[0] + pad + 'px',\r\n            right: null\r\n        };\r\n        return this.recalcToolTipCoordinateByViewPort(blockBoundingRect, tooltipBoundingRect, coordinate, winWidth, winHeight);\r\n    }\r\n    static getTooltipLineAttributes(scaleKey, margin, key, chartOrientation, blockSize) {\r\n        const attributes = {\r\n            x1: 0, x2: 0, y1: 0, y2: 0\r\n        };\r\n        if (chartOrientation === 'vertical') {\r\n            attributes.x1 = Math.ceil(_scale_scale__WEBPACK_IMPORTED_MODULE_1__.Scale.getScaledValue(scaleKey, key) + margin.left) - 0.5;\r\n            attributes.x2 = Math.ceil(_scale_scale__WEBPACK_IMPORTED_MODULE_1__.Scale.getScaledValue(scaleKey, key) + margin.left) - 0.5;\r\n            attributes.y1 = margin.top - this.convexsize;\r\n            attributes.y2 = blockSize.height - margin.bottom + this.convexsize * 2;\r\n        }\r\n        else {\r\n            attributes.x1 = margin.left - this.convexsize;\r\n            attributes.x2 = blockSize.width - margin.right + this.convexsize * 2;\r\n            attributes.y1 = _scale_scale__WEBPACK_IMPORTED_MODULE_1__.Scale.getScaledValue(scaleKey, key) + margin.top;\r\n            attributes.y2 = _scale_scale__WEBPACK_IMPORTED_MODULE_1__.Scale.getScaledValue(scaleKey, key) + margin.top;\r\n        }\r\n        return attributes;\r\n    }\r\n    static recalcToolTipCoordinateByViewPort(blockBounding, tooltipBounding, coordinate, winWidth, winHeight) {\r\n        const scrollPad = 18;\r\n        const tooltipLeftAtBlock = _helpers_helper__WEBPACK_IMPORTED_MODULE_0__.Helper.getPXValueFromString(coordinate.left);\r\n        if (tooltipLeftAtBlock < 0 && -tooltipLeftAtBlock > blockBounding.left)\r\n            coordinate.left = -blockBounding.left + 'px';\r\n        if (blockBounding.left + tooltipLeftAtBlock + tooltipBounding.width > winWidth - scrollPad)\r\n            coordinate.left = winWidth - blockBounding.left - tooltipBounding.width - scrollPad + 'px';\r\n        const tooltipTopAtBlock = _helpers_helper__WEBPACK_IMPORTED_MODULE_0__.Helper.getPXValueFromString(coordinate.top);\r\n        if (tooltipTopAtBlock + blockBounding.top < 0 && -tooltipTopAtBlock > blockBounding.top)\r\n            coordinate.top = -blockBounding.top + 'px';\r\n        if (blockBounding.top + tooltipTopAtBlock + tooltipBounding.height > winHeight)\r\n            coordinate.top = blockBounding.height - tooltipBounding.height - (blockBounding.bottom - winHeight) + 'px';\r\n        return coordinate;\r\n    }\r\n}\r\nTooltipHelper.convexsize = 5;\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/features/tolltip/tooltipHelper.ts?");

/***/ }),

/***/ "./src/engine/filterManager/filterEventManager.ts":
/*!********************************************************!*\
  !*** ./src/engine/filterManager/filterEventManager.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FilterEventManager\": () => /* binding */ FilterEventManager\n/* harmony export */ });\n/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-selection */ \"./node_modules/d3-selection/src/pointer.js\");\n/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-selection */ \"./node_modules/d3-selection/src/select.js\");\n/* harmony import */ var _elementHighlighter_selectHighlighter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../elementHighlighter/selectHighlighter */ \"./src/engine/elementHighlighter/selectHighlighter.ts\");\n/* harmony import */ var _features_tipBox_tipBox__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../features/tipBox/tipBox */ \"./src/engine/features/tipBox/tipBox.ts\");\n/* harmony import */ var _features_tipBox_tipBoxHelper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../features/tipBox/tipBoxHelper */ \"./src/engine/features/tipBox/tipBoxHelper.ts\");\n/* harmony import */ var _helpers_helper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers/helper */ \"./src/engine/helpers/helper.ts\");\n/* harmony import */ var _polarNotation_donut_donut__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../polarNotation/donut/donut */ \"./src/engine/polarNotation/donut/donut.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\n//TODO: вынести в отдельную папку / продумать разделение ID-менеджера и менеджера событий\r\nclass FilterEventManager {\r\n    constructor(callback, fullDataset, filtrable, keyFieldName, selectedIds = []) {\r\n        this.callback = callback;\r\n        this.fullDataset = fullDataset;\r\n        this.selectedKeys = _helpers_helper__WEBPACK_IMPORTED_MODULE_3__.Helper.getKeysByIds(selectedIds, keyFieldName, fullDataset);\r\n        this.filterable = filtrable;\r\n    }\r\n    setBlock(block) {\r\n        this.block = block;\r\n    }\r\n    getSelectedKeys() {\r\n        return this.selectedKeys;\r\n    }\r\n    updateData(newDataset) {\r\n        this.fullDataset = newDataset;\r\n    }\r\n    isSelected(keyValue) {\r\n        return this.selectedKeys.findIndex(key => key === keyValue) !== -1;\r\n    }\r\n    setKey(key) {\r\n        this.selectedKeys = [key];\r\n    }\r\n    addId(key) {\r\n        this.selectedKeys.push(key);\r\n    }\r\n    removeId(key) {\r\n        this.selectedKeys.splice(this.selectedKeys.findIndex(k => k === key), 1);\r\n    }\r\n    processKey(multySelect, keyValue) {\r\n        if (multySelect) {\r\n            if (this.getSelectedKeys().findIndex(key => key === keyValue) === -1) {\r\n                this.addId(keyValue);\r\n                return true;\r\n            }\r\n            else {\r\n                this.removeId(keyValue);\r\n                return false;\r\n            }\r\n        }\r\n        else {\r\n            if (this.getSelectedKeys()[0] === keyValue && this.getSelectedKeys().length === 1) {\r\n                this.removeId(keyValue);\r\n                return false;\r\n            }\r\n            else {\r\n                this.setKey(keyValue);\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    setListenerPolar(margin, blockSize, options, donutSettings) {\r\n        if (this.filterable) {\r\n            this.registerEventToDonut(margin, blockSize, options, donutSettings);\r\n            const selectedElems = _polarNotation_donut_donut__WEBPACK_IMPORTED_MODULE_4__.Donut.getAllArcGroups(this.block).filter(d => this.selectedKeys.findIndex(sid => sid === d.data[options.data.keyField.name]) !== -1);\r\n            this.selectedKeys = [];\r\n            selectedElems.dispatch('click', { bubbles: false, cancelable: true, detail: { multySelect: true } });\r\n        }\r\n    }\r\n    event2DUpdate(options) {\r\n        if (this.filterable) {\r\n            const removedKeys = [];\r\n            this.selectedKeys.forEach(key => {\r\n                if (this.fullDataset.findIndex(row => row[options.data.keyField.name] === key) === -1)\r\n                    removedKeys.push(key);\r\n                else\r\n                    _elementHighlighter_selectHighlighter__WEBPACK_IMPORTED_MODULE_0__.SelectHighlighter.click2DHandler(true, true, key, this.block, options);\r\n            });\r\n            removedKeys.forEach(rKey => this.selectedKeys.splice(this.selectedKeys.findIndex(sKey => sKey === rKey), 1));\r\n        }\r\n    }\r\n    registerEventFor2D(scaleKey, margin, blockSize, options) {\r\n        if (this.filterable) {\r\n            const tipBox = _features_tipBox_tipBox__WEBPACK_IMPORTED_MODULE_1__.TipBox.renderOrGet(this.block, margin, blockSize);\r\n            const thisClass = this;\r\n            tipBox.on('click', function (e) {\r\n                const multySelect = e.ctrlKey || e.metaKey;\r\n                const keyValue = _features_tipBox_tipBoxHelper__WEBPACK_IMPORTED_MODULE_2__.TipBoxHelper.getKeyValueByPointer((0,d3_selection__WEBPACK_IMPORTED_MODULE_5__.default)(e, this), options.orient, margin, blockSize, scaleKey, options.scale.key.type, 'click');\r\n                const appended = thisClass.processKey(multySelect, keyValue);\r\n                _elementHighlighter_selectHighlighter__WEBPACK_IMPORTED_MODULE_0__.SelectHighlighter.click2DHandler(multySelect, appended, keyValue, thisClass.block, options);\r\n                if (thisClass.callback) {\r\n                    thisClass.callback(_helpers_helper__WEBPACK_IMPORTED_MODULE_3__.Helper.getRowsByKeys(thisClass.selectedKeys, options.data.keyField.name, thisClass.fullDataset));\r\n                }\r\n            });\r\n        }\r\n    }\r\n    registerEventToDonut(margin, blockSize, options, donutSettings) {\r\n        const arcItems = _polarNotation_donut_donut__WEBPACK_IMPORTED_MODULE_4__.Donut.getAllArcGroups(this.block);\r\n        const thisClass = this;\r\n        arcItems.on('click', function (e, dataRow) {\r\n            const multySelect = thisClass.getMultySelectParam(e);\r\n            const keyValue = dataRow.data[options.data.keyField.name];\r\n            const appended = thisClass.processKey(multySelect, keyValue);\r\n            _elementHighlighter_selectHighlighter__WEBPACK_IMPORTED_MODULE_0__.SelectHighlighter.clickPolarHandler(multySelect, appended, (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__.default)(this), thisClass.getSelectedKeys(), margin, blockSize, thisClass.block, options, arcItems, donutSettings);\r\n            if (thisClass.callback) {\r\n                thisClass.callback(_helpers_helper__WEBPACK_IMPORTED_MODULE_3__.Helper.getRowsByKeys(thisClass.selectedKeys, options.data.keyField.name, thisClass.fullDataset));\r\n            }\r\n        });\r\n    }\r\n    getMultySelectParam(e) {\r\n        const isMultyButtonToggle = e.ctrlKey || e.metaKey;\r\n        return isMultyButtonToggle === undefined\r\n            ? (e.detail.multySelect === undefined ? false : e.detail.multySelect)\r\n            : isMultyButtonToggle;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/filterManager/filterEventManager.ts?");

/***/ }),

/***/ "./src/engine/helpers/domHelper.ts":
/*!*****************************************!*\
  !*** ./src/engine/helpers/domHelper.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SelectionCondition\": () => /* binding */ SelectionCondition,\n/* harmony export */   \"DomHelper\": () => /* binding */ DomHelper\n/* harmony export */ });\n/* harmony import */ var _features_markDots_markDot__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../features/markDots/markDot */ \"./src/engine/features/markDots/markDot.ts\");\n/* harmony import */ var _twoDimensionalNotation_bar_bar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../twoDimensionalNotation/bar/bar */ \"./src/engine/twoDimensionalNotation/bar/bar.ts\");\n\r\n\r\nvar SelectionCondition;\r\n(function (SelectionCondition) {\r\n    SelectionCondition[SelectionCondition[\"Include\"] = 0] = \"Include\";\r\n    SelectionCondition[SelectionCondition[\"Exclude\"] = 1] = \"Exclude\";\r\n})(SelectionCondition || (SelectionCondition = {}));\r\nclass DomHelper {\r\n    static setCssClasses(elem, cssClasses) {\r\n        cssClasses.forEach(cssClass => {\r\n            elem.classed(cssClass, true);\r\n        });\r\n    }\r\n    static get2DChartElements(block, chart) {\r\n        if (chart.type === 'line' || chart.type === 'area')\r\n            return _features_markDots_markDot__WEBPACK_IMPORTED_MODULE_0__.MarkDot.getMarkDotForChart(block, chart.cssClasses);\r\n        else\r\n            return _twoDimensionalNotation_bar_bar__WEBPACK_IMPORTED_MODULE_1__.Bar.getAllBarItems(block, chart.cssClasses);\r\n    }\r\n    static getCssPropertyValue(node, propertyName) {\r\n        return window.getComputedStyle(node).getPropertyValue(propertyName);\r\n    }\r\n    static getSelectionNumericAttr(selection, attrName) {\r\n        return parseFloat(selection.attr(attrName));\r\n    }\r\n    static setChartStyle(elements, chartStyle, fieldIndex, styleType) {\r\n        this.setChartElementColor(elements, chartStyle.elementColors, fieldIndex, styleType);\r\n        this.setChartOpacity(elements, chartStyle.opacity);\r\n    }\r\n    static setChartElementColor(elements, colorPalette, fieldIndex, styleType) {\r\n        elements.style(styleType, colorPalette[fieldIndex % colorPalette.length]);\r\n    }\r\n    static cropSvgLabels(labelBlocks, maxWidth) {\r\n        labelBlocks.nodes().forEach(node => {\r\n            if (node.getBBox().width > maxWidth) {\r\n                const text = node.textContent;\r\n                let textLength = text.length;\r\n                while (node.getBBox().width > maxWidth && textLength > 0) {\r\n                    node.textContent = text.substring(0, --textLength) + '...';\r\n                }\r\n                if (textLength === 0)\r\n                    node.textContent = '';\r\n            }\r\n        });\r\n    }\r\n    static get2DElementsByKey(initialSelection, isSegmented, keyFieldName, keyValue) {\r\n        if (!isSegmented)\r\n            return initialSelection.filter(d => d[keyFieldName] === keyValue);\r\n        else\r\n            return initialSelection.filter(d => d.data[keyFieldName] === keyValue);\r\n    }\r\n    /**\r\n     * Возвращает выборку элементов, ключи которых содержатся или НЕ содержатся в переданном массиве\r\n     * @param initialSelection Изначальная выборка\r\n     * @param dataWrapped Содержаться ли данные в обертке .data\r\n     * @param keyFieldName название поля ключей\r\n     * @param keyValues значения ключей\r\n     * @param condition включать или исключать элменты по ключам\r\n     * @returns\r\n     */\r\n    static getChartElementsByKeys(initialSelection, dataWrapped, keyFieldName, keyValues, condition) {\r\n        return initialSelection.filter(d => {\r\n            let i;\r\n            if (dataWrapped)\r\n                i = keyValues.findIndex(kv => kv === d.data[keyFieldName]);\r\n            else\r\n                i = keyValues.findIndex(kv => kv === d[keyFieldName]);\r\n            return condition === SelectionCondition.Exclude ? i === -1 : i !== -1;\r\n        });\r\n    }\r\n    static setChartOpacity(elements, opacity) {\r\n        elements.attr('opacity', opacity);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/helpers/domHelper.ts?");

/***/ }),

/***/ "./src/engine/helpers/helper.ts":
/*!**************************************!*\
  !*** ./src/engine/helpers/helper.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Helper\": () => /* binding */ Helper\n/* harmony export */ });\nclass Helper {\r\n    static getRowsByIds(ids, dataSet) {\r\n        return dataSet.filter(row => ids.findIndex(id => id === row.$id) !== -1);\r\n    }\r\n    static getRowsByKeys(keys, keyFieldName, dataSet) {\r\n        return dataSet.filter(row => keys.findIndex(key => key === row[keyFieldName]) !== -1);\r\n    }\r\n    static extractKeysFromRows(keyFieldName, dataSet) {\r\n        return dataSet.map(row => row[keyFieldName]);\r\n    }\r\n    static getIdFromRowByKey(keyFieldName, keyValue, dataSet) {\r\n        return dataSet.find(row => row[keyFieldName] === keyValue).$id;\r\n    }\r\n    static getKeysByIds(ids, keyFieldName, dataSet) {\r\n        return this.extractKeysFromRows(keyFieldName, this.getRowsByIds(ids, dataSet));\r\n    }\r\n    static getKeyById(id, keyFieldName, dataSet) {\r\n        return this.getKeysByIds([id], keyFieldName, dataSet)[0];\r\n    }\r\n    static getCssClassesLine(cssClasses) {\r\n        return '.' + cssClasses.join('.');\r\n    }\r\n    static getCssClassesArray(cssClass) {\r\n        return cssClass.split(' ');\r\n    }\r\n    static getCssClassesWithElementIndex(cssClasses, index) {\r\n        return cssClasses.concat([`chart-element-${index}`]);\r\n    }\r\n    static getTranslateNumbers(transformValue) {\r\n        if (!transformValue)\r\n            return [0, 0];\r\n        const translateNumbers = transformValue.substring(10, transformValue.length - 1).split(', ');\r\n        const translateX = parseFloat(translateNumbers[0]);\r\n        const translateY = parseFloat(translateNumbers[1]);\r\n        return [translateX, translateY];\r\n    }\r\n    static getSumOfNumeric(numbers) {\r\n        return numbers.reduce((acc, value) => acc + value, 0);\r\n    }\r\n    static parseFormattedToNumber(value, rankSpliter) {\r\n        return parseFloat(value.replace(rankSpliter, '.').split(/\\s/).join(''));\r\n    }\r\n    static calcDigitsAfterDot(value) {\r\n        const valueInString = value.toString();\r\n        const dotIndex = valueInString.lastIndexOf('.') === -1 ? valueInString.length : valueInString.lastIndexOf('.') + 1;\r\n        return valueInString.substring(dotIndex).length;\r\n    }\r\n    static checkDomainsEquality(oldDomain, newDomain) {\r\n        if (oldDomain.length !== newDomain.length)\r\n            return false;\r\n        let isEqual = true;\r\n        oldDomain.forEach((keyValue, index) => {\r\n            if (keyValue !== newDomain[index])\r\n                isEqual = false;\r\n        });\r\n        return isEqual;\r\n    }\r\n    static getValueOrZero(value) {\r\n        return value > 0 ? value : 0;\r\n    }\r\n    static getPXValueFromString(propertyValue) {\r\n        return parseFloat(propertyValue);\r\n    }\r\n    /**\r\n     * Возвращает значение ключа в зависимости от того, сегментированный ли график\r\n     * @param row\r\n     * @param keyFieldName\r\n     * @param isSegmented\r\n     * @returns\r\n     */\r\n    static getKeyFieldValue(row, keyFieldName, isSegmented) {\r\n        return isSegmented ? row.data[keyFieldName] : row[keyFieldName];\r\n    }\r\n    /**\r\n     * Сравнивает старые и новые данные\r\n     */\r\n    static compareData(oldSource, newSource, sourceName) {\r\n        if (!oldSource || !newSource || !sourceName || !oldSource[sourceName] || !newSource[sourceName] || oldSource[sourceName].length !== newSource[sourceName].length)\r\n            return false;\r\n        const oldData = oldSource[sourceName];\r\n        const newData = newSource[sourceName];\r\n        let isEqual = true;\r\n        oldData.forEach((row, i) => {\r\n            for (let key in row) {\r\n                if (row[key] !== newData[i][key] && isEqual)\r\n                    isEqual = false;\r\n            }\r\n        });\r\n        return isEqual;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/helpers/helper.ts?");

/***/ }),

/***/ "./src/engine/intervalNotation/gantt.ts":
/*!**********************************************!*\
  !*** ./src/engine/intervalNotation/gantt.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Gantt\": () => /* binding */ Gantt\n/* harmony export */ });\n/* harmony import */ var _features_scale_scale__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../features/scale/scale */ \"./src/engine/features/scale/scale.ts\");\n/* harmony import */ var _helpers_domHelper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/domHelper */ \"./src/engine/helpers/domHelper.ts\");\n\r\n\r\nclass Gantt {\r\n    static render(block, data, dataOptions, scales, margin, keyAxisOrient, chart, barSettings) {\r\n        const ganttItems = block.getChartBlock()\r\n            .selectAll(`.${this.ganttItemClass}`)\r\n            .data(data)\r\n            .enter()\r\n            .append('rect')\r\n            .attr('class', this.ganttItemClass)\r\n            .style('clip-path', `url(#${block.getClipPathId()})`);\r\n        const itemsAttrs = this.getItemsAttrsByKeyOrient(keyAxisOrient, scales, margin, dataOptions.keyField.name, chart.data.valueField1.name, chart.data.valueField2.name, barSettings);\r\n        this.fillItemsAttrs(ganttItems, itemsAttrs);\r\n        _helpers_domHelper__WEBPACK_IMPORTED_MODULE_1__.DomHelper.setCssClasses(ganttItems, chart.cssClasses);\r\n        _helpers_domHelper__WEBPACK_IMPORTED_MODULE_1__.DomHelper.setChartStyle(ganttItems, chart.style, 0, 'fill');\r\n    }\r\n    static fillItemsAttrs(ganttItems, attrs) {\r\n        ganttItems\r\n            .attr('x', d => attrs.x(d))\r\n            .attr('y', d => attrs.y(d))\r\n            .attr('width', d => attrs.width(d))\r\n            .attr('height', d => attrs.height(d));\r\n    }\r\n    static getItemsAttrsByKeyOrient(axisOrient, scales, margin, keyField, valueField1, valueField2, barSettings) {\r\n        const attrs = {\r\n            x: null,\r\n            y: null,\r\n            width: null,\r\n            height: null\r\n        };\r\n        const itemSize = _features_scale_scale__WEBPACK_IMPORTED_MODULE_0__.Scale.getScaleBandWidth(scales.key) > barSettings.maxBarWidth\r\n            ? barSettings.maxBarWidth\r\n            : _features_scale_scale__WEBPACK_IMPORTED_MODULE_0__.Scale.getScaleBandWidth(scales.key);\r\n        const sizeDiff = (_features_scale_scale__WEBPACK_IMPORTED_MODULE_0__.Scale.getScaleBandWidth(scales.key) - itemSize) / 2;\r\n        if (axisOrient === 'top' || axisOrient === 'bottom') {\r\n            attrs.x = d => scales.key(d[keyField]) + margin.left + sizeDiff;\r\n            attrs.width = d => itemSize;\r\n        }\r\n        if (axisOrient === 'left' || axisOrient === 'right') {\r\n            attrs.y = d => scales.key(d[keyField]) + margin.top + sizeDiff;\r\n            attrs.height = d => itemSize;\r\n        }\r\n        if (axisOrient === 'top') {\r\n            attrs.y = d => scales.value(d[valueField1]) + margin.top;\r\n            attrs.height = d => scales.value(d[valueField2]) - scales.value(d[valueField1]);\r\n        }\r\n        else if (axisOrient === 'bottom') {\r\n            attrs.y = d => scales.value(d[valueField2]) + margin.top;\r\n            attrs.height = d => scales.value(d[valueField1]) - scales.value(d[valueField2]);\r\n        }\r\n        else if (axisOrient === 'left') {\r\n            attrs.x = d => scales.value(d[valueField1]) + margin.left;\r\n            attrs.width = d => scales.value(d[valueField2]) - scales.value(d[valueField1]);\r\n        }\r\n        else if (axisOrient === 'right') {\r\n            attrs.x = d => scales.value(d[valueField2]) + margin.left;\r\n            attrs.width = d => scales.value(d[valueField1]) - scales.value(d[valueField2]);\r\n        }\r\n        return attrs;\r\n    }\r\n}\r\nGantt.ganttItemClass = 'gantt-item';\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/intervalNotation/gantt.ts?");

/***/ }),

/***/ "./src/engine/intervalNotation/intervalManager.ts":
/*!********************************************************!*\
  !*** ./src/engine/intervalNotation/intervalManager.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"IntervalManager\": () => /* binding */ IntervalManager\n/* harmony export */ });\n/* harmony import */ var _features_axis_axis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../features/axis/axis */ \"./src/engine/features/axis/axis.ts\");\n/* harmony import */ var _features_gridLine_gridLine__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../features/gridLine/gridLine */ \"./src/engine/features/gridLine/gridLine.ts\");\n/* harmony import */ var _features_legend_legend__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../features/legend/legend */ \"./src/engine/features/legend/legend.ts\");\n/* harmony import */ var _features_recordOverflowAlert_recordOverflowAlert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../features/recordOverflowAlert/recordOverflowAlert */ \"./src/engine/features/recordOverflowAlert/recordOverflowAlert.ts\");\n/* harmony import */ var _features_scale_scale__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../features/scale/scale */ \"./src/engine/features/scale/scale.ts\");\n/* harmony import */ var _features_title_title__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../features/title/title */ \"./src/engine/features/title/title.ts\");\n/* harmony import */ var _features_tolltip_tooltip__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../features/tolltip/tooltip */ \"./src/engine/features/tolltip/tooltip.ts\");\n/* harmony import */ var _gantt__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./gantt */ \"./src/engine/intervalNotation/gantt.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass IntervalManager {\r\n    static render(block, model, data) {\r\n        const options = model.options;\r\n        block.renderSvg(model.blockCanvas.size);\r\n        const scales = _features_scale_scale__WEBPACK_IMPORTED_MODULE_4__.Scale.getScales(options.scale.key, options.scale.value, model.chartSettings.bar);\r\n        _features_axis_axis__WEBPACK_IMPORTED_MODULE_0__.Axis.render(block, scales, options.scale, options.axis, model.chartBlock.margin, model.blockCanvas.size);\r\n        _features_gridLine_gridLine__WEBPACK_IMPORTED_MODULE_1__.GridLine.render(block, options.additionalElements.gridLine.flag, options.axis.key, options.axis.value, model.blockCanvas.size, model.chartBlock.margin, options.scale.key);\r\n        this.renderCharts(block, options.charts, scales, data, options.data, model.chartBlock.margin, options.axis.key.orient, model.chartSettings);\r\n        _features_title_title__WEBPACK_IMPORTED_MODULE_5__.Title.render(block, options.title, model.otherComponents.titleBlock, model.blockCanvas.size);\r\n        _features_legend_legend__WEBPACK_IMPORTED_MODULE_2__.Legend.render(block, data, options, model);\r\n        _features_tolltip_tooltip__WEBPACK_IMPORTED_MODULE_6__.Tooltip.render(block, model, data, model.otherComponents.tooltipBlock);\r\n        if (model.dataSettings.scope.hidedRecordsAmount !== 0)\r\n            _features_recordOverflowAlert_recordOverflowAlert__WEBPACK_IMPORTED_MODULE_3__.RecordOverflowAlert.render(block, model.dataSettings.scope.hidedRecordsAmount, 'top', options.orient);\r\n    }\r\n    static renderCharts(block, charts, scales, data, dataOptions, margin, keyAxisOrient, chartSettings) {\r\n        block.renderChartsBlock();\r\n        charts.forEach(chart => {\r\n            if (chart.type === 'gantt')\r\n                _gantt__WEBPACK_IMPORTED_MODULE_7__.Gantt.render(block, data[dataOptions.dataSource], dataOptions, scales, margin, keyAxisOrient, chart, chartSettings.bar);\r\n        });\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/intervalNotation/intervalManager.ts?");

/***/ }),

/***/ "./src/engine/namesManager.ts":
/*!************************************!*\
  !*** ./src/engine/namesManager.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"NamesManager\": () => /* binding */ NamesManager\n/* harmony export */ });\nclass NamesManager {\r\n    static getClassName(classOfElem) {\r\n        return this.prefix + classOfElem;\r\n    }\r\n    static getId(idName, blockId) {\r\n        return this.prefix + idName + '-' + blockId;\r\n    }\r\n}\r\nNamesManager.prefix = 'charts-';\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/namesManager.ts?");

/***/ }),

/***/ "./src/engine/polarNotation/aggregator.ts":
/*!************************************************!*\
  !*** ./src/engine/polarNotation/aggregator.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Aggregator\": () => /* binding */ Aggregator\n/* harmony export */ });\n/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-array */ \"./node_modules/d3-array/src/sum.js\");\n/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-interpolate */ \"./node_modules/d3-interpolate/src/number.js\");\n/* harmony import */ var _helpers_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/helper */ \"./src/engine/helpers/helper.ts\");\n/* harmony import */ var _valueFormatter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../valueFormatter */ \"./src/engine/valueFormatter.ts\");\n\r\n\r\n\r\n\r\nclass Aggregator {\r\n    static render(block, data, valueField, innerRadius, translate, fontSize, pad) {\r\n        const aggregator = {\r\n            name: 'Сумма',\r\n            value: (0,d3_array__WEBPACK_IMPORTED_MODULE_2__.default)(data.map(d => d[valueField.name])),\r\n            format: valueField.format\r\n        };\r\n        this.renderText(block, innerRadius, aggregator, translate, fontSize, pad);\r\n    }\r\n    static update(block, data, valueField, pad) {\r\n        const aggregator = {\r\n            name: 'Сумма',\r\n            value: (0,d3_array__WEBPACK_IMPORTED_MODULE_2__.default)(data.map(d => d[valueField.name])),\r\n            format: valueField.format\r\n        };\r\n        this.updateText(block, aggregator, pad);\r\n    }\r\n    static renderText(block, innerRadius, aggregatorInfo, translate, fontSize, pad) {\r\n        if (innerRadius > 50) {\r\n            const aggregatorObject = this.renderAggregatorObject(block, innerRadius, translate);\r\n            const wrapper = this.renderWrapper(aggregatorObject);\r\n            wrapper\r\n                .append('div')\r\n                .attr('class', this.aggregatorValueClass)\r\n                .style('text-align', 'center')\r\n                .style('font-size', `${fontSize}px`)\r\n                .text(_valueFormatter__WEBPACK_IMPORTED_MODULE_1__.ValueFormatter.formatField(aggregatorInfo.format, aggregatorInfo.value));\r\n            wrapper\r\n                .append('div')\r\n                .attr('class', this.aggregatorNameClass)\r\n                .style('text-align', 'center')\r\n                .style('font-size', '18px')\r\n                .text(aggregatorInfo.name);\r\n            this.reCalculateAggregatorFontSize(aggregatorObject.node().getBoundingClientRect().width, block, pad);\r\n        }\r\n    }\r\n    static updateText(block, newAggregator, pad) {\r\n        const aggregatorObject = block.getSvg()\r\n            .select(`.${this.aggregatorObjectClass}`);\r\n        const thisClass = this;\r\n        block.getSvg()\r\n            .select(`.${this.aggregatorValueClass}`)\r\n            .interrupt()\r\n            .transition()\r\n            .duration(block.transitionManager.durations.chartUpdate)\r\n            .tween(\"text\", function () {\r\n            const oldValue = _helpers_helper__WEBPACK_IMPORTED_MODULE_0__.Helper.parseFormattedToNumber(this.textContent, ',');\r\n            const precision = _helpers_helper__WEBPACK_IMPORTED_MODULE_0__.Helper.calcDigitsAfterDot(newAggregator.value);\r\n            const interpolateFunc = (0,d3_interpolate__WEBPACK_IMPORTED_MODULE_3__.default)(oldValue, newAggregator.value);\r\n            return t => {\r\n                this.textContent = _valueFormatter__WEBPACK_IMPORTED_MODULE_1__.ValueFormatter.formatField(newAggregator.format, (interpolateFunc(t)).toFixed(precision));\r\n                thisClass.reCalculateAggregatorFontSize(aggregatorObject.node().getBoundingClientRect().width, block, pad);\r\n            };\r\n        });\r\n    }\r\n    static reCalculateAggregatorFontSize(wrapperSize, block, pad) {\r\n        const aggreggatorValue = block.getSvg()\r\n            .select(`.${this.aggregatorValueClass}`);\r\n        let fontSize = parseInt(aggreggatorValue.style('font-size'));\r\n        while (aggreggatorValue.node().getBoundingClientRect().width > wrapperSize - pad * 2 && fontSize > 15) {\r\n            aggreggatorValue.style('font-size', `${fontSize -= 2}px`);\r\n        }\r\n        while (aggreggatorValue.node().getBoundingClientRect().width < wrapperSize - pad * 2 && fontSize < 60) {\r\n            aggreggatorValue.style('font-size', `${fontSize += 2}px`);\r\n        }\r\n    }\r\n    static renderAggregatorObject(block, innerRadius, translate) {\r\n        return block.getSvg()\r\n            .append('foreignObject')\r\n            .attr('class', this.aggregatorObjectClass)\r\n            .attr('transform-origin', 'center')\r\n            .attr('width', innerRadius * 2)\r\n            .attr('height', innerRadius * 2)\r\n            .attr('transform', `translate(${translate.x - innerRadius}, ${translate.y - innerRadius})`)\r\n            .style('pointer-events', `none`);\r\n    }\r\n    static renderWrapper(aggregatorObject) {\r\n        return aggregatorObject\r\n            .append('xhtml:div')\r\n            .style('width', '100%')\r\n            .style('height', '100%')\r\n            .style('border-radius', '50%')\r\n            .style('display', 'flex')\r\n            .style('flex-direction', 'column')\r\n            .style('justify-content', 'center')\r\n            .style('align-items', 'center');\r\n    }\r\n}\r\nAggregator.aggregatorValueClass = 'aggregator-value';\r\nAggregator.aggregatorNameClass = 'aggregator-name';\r\nAggregator.aggregatorObjectClass = 'aggregator-object';\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/polarNotation/aggregator.ts?");

/***/ }),

/***/ "./src/engine/polarNotation/donut/DonutHelper.ts":
/*!*******************************************************!*\
  !*** ./src/engine/polarNotation/donut/DonutHelper.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DonutHelper\": () => /* binding */ DonutHelper\n/* harmony export */ });\n/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-array */ \"./node_modules/d3-array/src/merge.js\");\n/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-shape */ \"./node_modules/d3-shape/src/arc.js\");\n/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-shape */ \"./node_modules/d3-shape/src/pie.js\");\n\r\n\r\nclass DonutHelper {\r\n    static getThickness(donutSettings, blockSize, margin) {\r\n        if (Math.min(blockSize.width - margin.left - margin.right, blockSize.height - margin.bottom - margin.top) > 400)\r\n            return donutSettings.maxThickness;\r\n        return donutSettings.minThickness;\r\n    }\r\n    static getArcCentroid(blockSize, margin, dataItem, donutThickness) {\r\n        const arc = this.getArcGeneratorObject(blockSize, margin, donutThickness);\r\n        return arc.centroid(dataItem);\r\n    }\r\n    static getArcGeneratorObject(blockSize, margin, donutThickness) {\r\n        const outerRadius = this.getOuterRadius(margin, blockSize);\r\n        const arc = this.getArcGenerator(outerRadius, outerRadius - donutThickness);\r\n        return arc;\r\n    }\r\n    static getOuterRadius(margin, blockSize) {\r\n        return Math.min(blockSize.width - margin.left - margin.right, blockSize.height - margin.top - margin.bottom) / 2;\r\n    }\r\n    static getInnerRadius(outerRadius, thickness) {\r\n        return outerRadius - thickness;\r\n    }\r\n    static getTranslate(margin, blockSize) {\r\n        return {\r\n            x: (blockSize.width - margin.left - margin.right) / 2 + margin.left,\r\n            y: (blockSize.height - margin.top - margin.bottom) / 2 + margin.top\r\n        };\r\n    }\r\n    static getArcGenerator(outerRadius, innerRadius) {\r\n        return (0,d3_shape__WEBPACK_IMPORTED_MODULE_0__.default)()\r\n            .innerRadius(innerRadius)\r\n            .outerRadius(outerRadius);\r\n    }\r\n    static getPieGenerator(valueField, padAngle) {\r\n        return (0,d3_shape__WEBPACK_IMPORTED_MODULE_1__.default)()\r\n            .padAngle(padAngle)\r\n            .sort(null)\r\n            .value(d => d[valueField]);\r\n    }\r\n    static mergeDataWithZeros(firstDataset, secondDataset, keyField) {\r\n        const secondSet = new Set();\r\n        secondDataset.forEach(dataRow => {\r\n            secondSet.add(dataRow[keyField]);\r\n        });\r\n        const onlyNew = firstDataset\r\n            .filter(d => !secondSet.has(d[keyField]))\r\n            .map((d, index, array) => {\r\n            const data = {\r\n                keyField: array[index][keyField],\r\n                valueField: 0\r\n            };\r\n            return data;\r\n        });\r\n        const sortedMerge = (0,d3_array__WEBPACK_IMPORTED_MODULE_2__.default)([secondDataset, onlyNew]);\r\n        return sortedMerge;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/polarNotation/donut/DonutHelper.ts?");

/***/ }),

/***/ "./src/engine/polarNotation/donut/donut.ts":
/*!*************************************************!*\
  !*** ./src/engine/polarNotation/donut/donut.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Donut\": () => /* binding */ Donut\n/* harmony export */ });\n/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-interpolate */ \"./node_modules/d3-interpolate/src/value.js\");\n/* harmony import */ var _aggregator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../aggregator */ \"./src/engine/polarNotation/aggregator.ts\");\n/* harmony import */ var _DonutHelper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DonutHelper */ \"./src/engine/polarNotation/donut/DonutHelper.ts\");\n/* harmony import */ var _helpers_domHelper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../helpers/domHelper */ \"./src/engine/helpers/domHelper.ts\");\n/* harmony import */ var _elementHighlighter_elementHighlighter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../elementHighlighter/elementHighlighter */ \"./src/engine/elementHighlighter/elementHighlighter.ts\");\n\r\n\r\n\r\n\r\n\r\nclass Donut {\r\n    static render(block, data, margin, chart, blockSize, settings) {\r\n        const outerRadius = _DonutHelper__WEBPACK_IMPORTED_MODULE_1__.DonutHelper.getOuterRadius(margin, blockSize);\r\n        const thickness = _DonutHelper__WEBPACK_IMPORTED_MODULE_1__.DonutHelper.getThickness(settings, blockSize, margin);\r\n        const innerRadius = _DonutHelper__WEBPACK_IMPORTED_MODULE_1__.DonutHelper.getInnerRadius(outerRadius, thickness);\r\n        const arcGenerator = _DonutHelper__WEBPACK_IMPORTED_MODULE_1__.DonutHelper.getArcGenerator(outerRadius, innerRadius);\r\n        const pieGenerator = _DonutHelper__WEBPACK_IMPORTED_MODULE_1__.DonutHelper.getPieGenerator(chart.data.valueField.name, settings.padAngle);\r\n        const translateAttr = _DonutHelper__WEBPACK_IMPORTED_MODULE_1__.DonutHelper.getTranslate(margin, blockSize);\r\n        const donutBlock = block.getSvg()\r\n            .append('g')\r\n            .attr('class', this.donutBlockClass)\r\n            .attr('x', translateAttr.x)\r\n            .attr('y', translateAttr.y)\r\n            .attr('transform', `translate(${translateAttr.x}, ${translateAttr.y})`);\r\n        this.renderNewArcItems(arcGenerator, pieGenerator, donutBlock, data, chart);\r\n        this.renderClonesG(block, donutBlock);\r\n        _aggregator__WEBPACK_IMPORTED_MODULE_0__.Aggregator.render(block, data, chart.data.valueField, innerRadius, translateAttr, thickness, settings.aggregatorPad);\r\n    }\r\n    static updateValues(block, data, margin, chart, blockSize, donutSettings, keyField) {\r\n        const outerRadius = _DonutHelper__WEBPACK_IMPORTED_MODULE_1__.DonutHelper.getOuterRadius(margin, blockSize);\r\n        const thickness = _DonutHelper__WEBPACK_IMPORTED_MODULE_1__.DonutHelper.getThickness(donutSettings, blockSize, margin);\r\n        const innerRadius = _DonutHelper__WEBPACK_IMPORTED_MODULE_1__.DonutHelper.getInnerRadius(outerRadius, thickness);\r\n        const arcGenerator = _DonutHelper__WEBPACK_IMPORTED_MODULE_1__.DonutHelper.getArcGenerator(outerRadius, innerRadius);\r\n        const pieGenerator = _DonutHelper__WEBPACK_IMPORTED_MODULE_1__.DonutHelper.getPieGenerator(chart.data.valueField.name, donutSettings.padAngle);\r\n        const oldData = block.getSvg()\r\n            .selectAll(`.${this.donutBlockClass}`)\r\n            .selectAll('path')\r\n            .data()\r\n            .map(d => d.data);\r\n        const dataNewZeroRows = _DonutHelper__WEBPACK_IMPORTED_MODULE_1__.DonutHelper.mergeDataWithZeros(data, oldData, keyField);\r\n        const dataExtraZeroRows = _DonutHelper__WEBPACK_IMPORTED_MODULE_1__.DonutHelper.mergeDataWithZeros(oldData, data, keyField);\r\n        const donutBlock = block.getSvg().select(`.${this.donutBlockClass}`);\r\n        this.renderNewArcItems(arcGenerator, pieGenerator, donutBlock, dataNewZeroRows, chart);\r\n        this.setElementsColor(this.getAllArcGroups(block), chart.style.elementColors);\r\n        const path = this.getAllArcGroups(block)\r\n            .data(pieGenerator(dataExtraZeroRows))\r\n            .select('path');\r\n        const items = this.getAllArcGroups(block)\r\n            .data(pieGenerator(data));\r\n        return new Promise(resolve => {\r\n            this.raiseClonesG(block);\r\n            path\r\n                .interrupt()\r\n                .transition()\r\n                .duration(block.transitionManager.durations.chartUpdate)\r\n                .on('end', () => {\r\n                items.exit().remove();\r\n                resolve('updated');\r\n            })\r\n                .attrTween('d', function (d) {\r\n                const interpolateFunc = (0,d3_interpolate__WEBPACK_IMPORTED_MODULE_4__.default)(this._currentData, d);\r\n                return t => {\r\n                    this._currentData = interpolateFunc(t); // _current - старые данные до обновления, задаются во время рендера\r\n                    return arcGenerator(this._currentData);\r\n                };\r\n            });\r\n        });\r\n    }\r\n    static getAllArcGroups(block) {\r\n        return block.getSvg()\r\n            .selectAll(`.${this.arcItemClass}`);\r\n    }\r\n    static getAllArcClones(block) {\r\n        return block.getSvg()\r\n            .selectAll(`.${Donut.arcItemClass}-clone`);\r\n    }\r\n    static renderNewArcItems(arcGenerator, pieGenerator, donutBlock, data, chart) {\r\n        const items = donutBlock\r\n            .selectAll(`.${this.arcItemClass}`)\r\n            .data(pieGenerator(data))\r\n            .enter()\r\n            .append('g')\r\n            .attr('class', this.arcItemClass);\r\n        const arcs = items\r\n            .append('path')\r\n            .attr('d', arcGenerator)\r\n            .attr('class', this.arcPathClass)\r\n            .each(function (d) { this._currentData = d; }); // _currentData используется для получения текущих данных внутри функции обновления.\r\n        _helpers_domHelper__WEBPACK_IMPORTED_MODULE_2__.DomHelper.setCssClasses(arcs, chart.cssClasses);\r\n        this.setElementsColor(items, chart.style.elementColors);\r\n    }\r\n    static setElementsColor(arcItems, colorPalette) {\r\n        arcItems\r\n            .select('path')\r\n            .style('fill', (d, i) => colorPalette[i % colorPalette.length]);\r\n    }\r\n    /**\r\n     * Рендер группы для клонов сегментов доната внутри donut-block. Объекдиняет в себе стили для клонов\r\n     */\r\n    static renderClonesG(block, donutBlock) {\r\n        const clonesG = donutBlock.append('g').attr('class', this.clonesGroupClass).raise();\r\n        _elementHighlighter_elementHighlighter__WEBPACK_IMPORTED_MODULE_3__.ElementHighlighter.setFilter(clonesG, block);\r\n    }\r\n    static raiseClonesG(block) {\r\n        block.getSvg()\r\n            .select(`.${this.donutBlockClass}`)\r\n            .select(`.${this.clonesGroupClass}`)\r\n            .raise();\r\n    }\r\n}\r\nDonut.donutBlockClass = 'donut-block';\r\nDonut.arcPathClass = 'arc-path';\r\nDonut.arcItemClass = 'arc';\r\nDonut.arcHighlightedClass = 'arc-highlighted';\r\nDonut.clonesGroupClass = 'arc-clones';\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/polarNotation/donut/donut.ts?");

/***/ }),

/***/ "./src/engine/polarNotation/polarManager.ts":
/*!**************************************************!*\
  !*** ./src/engine/polarNotation/polarManager.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PolarManager\": () => /* binding */ PolarManager\n/* harmony export */ });\n/* harmony import */ var _features_legend_legend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../features/legend/legend */ \"./src/engine/features/legend/legend.ts\");\n/* harmony import */ var _features_recordOverflowAlert_recordOverflowAlert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../features/recordOverflowAlert/recordOverflowAlert */ \"./src/engine/features/recordOverflowAlert/recordOverflowAlert.ts\");\n/* harmony import */ var _features_title_title__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../features/title/title */ \"./src/engine/features/title/title.ts\");\n/* harmony import */ var _elementHighlighter_elementHighlighter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../elementHighlighter/elementHighlighter */ \"./src/engine/elementHighlighter/elementHighlighter.ts\");\n/* harmony import */ var _features_tolltip_tooltip__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../features/tolltip/tooltip */ \"./src/engine/features/tolltip/tooltip.ts\");\n/* harmony import */ var _aggregator__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./aggregator */ \"./src/engine/polarNotation/aggregator.ts\");\n/* harmony import */ var _donut_donut__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./donut/donut */ \"./src/engine/polarNotation/donut/donut.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass PolarManager {\r\n    static render(engine, model) {\r\n        const options = model.options;\r\n        engine.block.renderSvg(model.blockCanvas.size);\r\n        this.renderCharts(engine.block, options.charts, engine.data, options.data.dataSource, model.chartBlock.margin, model.blockCanvas.size, model.chartSettings.donut);\r\n        _features_title_title__WEBPACK_IMPORTED_MODULE_2__.Title.render(engine.block, options.title, model.otherComponents.titleBlock, model.blockCanvas.size);\r\n        _features_legend_legend__WEBPACK_IMPORTED_MODULE_0__.Legend.render(engine.block, engine.data, options, model);\r\n        _features_tolltip_tooltip__WEBPACK_IMPORTED_MODULE_4__.Tooltip.render(engine.block, model, engine.data, model.otherComponents.tooltipBlock);\r\n        engine.block.filterEventManager.setListenerPolar(model.chartBlock.margin, model.blockCanvas.size, options, model.chartSettings.donut);\r\n        if (model.dataSettings.scope.hidedRecordsAmount !== 0 && model.options.legend.position !== 'off')\r\n            _features_recordOverflowAlert_recordOverflowAlert__WEBPACK_IMPORTED_MODULE_1__.RecordOverflowAlert.render(engine.block, model.dataSettings.scope.hidedRecordsAmount, model.options.legend.position);\r\n    }\r\n    static updateData(block, model, data) {\r\n        block.transitionManager.interruptTransitions();\r\n        block.removeMouseEvents();\r\n        block.filterEventManager.updateData(data[model.options.data.dataSource]);\r\n        _elementHighlighter_elementHighlighter__WEBPACK_IMPORTED_MODULE_3__.ElementHighlighter.removeDonutArcClones(block);\r\n        _elementHighlighter_elementHighlighter__WEBPACK_IMPORTED_MODULE_3__.ElementHighlighter.removeFilter(_donut_donut__WEBPACK_IMPORTED_MODULE_6__.Donut.getAllArcGroups(block));\r\n        _features_tolltip_tooltip__WEBPACK_IMPORTED_MODULE_4__.Tooltip.hide(block);\r\n        const options = model.options;\r\n        _donut_donut__WEBPACK_IMPORTED_MODULE_6__.Donut.updateValues(block, data[options.data.dataSource], model.chartBlock.margin, options.charts[0], model.blockCanvas.size, model.chartSettings.donut, options.data.keyField.name)\r\n            .then(() => {\r\n            _features_tolltip_tooltip__WEBPACK_IMPORTED_MODULE_4__.Tooltip.render(block, model, data, model.otherComponents.tooltipBlock);\r\n            block.filterEventManager.setListenerPolar(model.chartBlock.margin, model.blockCanvas.size, options, model.chartSettings.donut);\r\n        });\r\n        _aggregator__WEBPACK_IMPORTED_MODULE_5__.Aggregator.update(block, data[options.data.dataSource], options.charts[0].data.valueField, model.chartSettings.donut.aggregatorPad);\r\n        _features_legend_legend__WEBPACK_IMPORTED_MODULE_0__.Legend.update(block, data, model.options);\r\n        if (model.options.legend.position !== 'off')\r\n            _features_recordOverflowAlert_recordOverflowAlert__WEBPACK_IMPORTED_MODULE_1__.RecordOverflowAlert.update(block, model.dataSettings.scope.hidedRecordsAmount, model.options.legend.position);\r\n    }\r\n    static renderCharts(block, charts, data, dataSource, margin, blockSize, donutSettings) {\r\n        //TODO: подумать над заменой charts у polar с массива на один объект\r\n        charts.forEach((chart) => {\r\n            if (chart.type === 'donut')\r\n                _donut_donut__WEBPACK_IMPORTED_MODULE_6__.Donut.render(block, data[dataSource], margin, chart, blockSize, donutSettings);\r\n        });\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/polarNotation/polarManager.ts?");

/***/ }),

/***/ "./src/engine/transitionManager.ts":
/*!*****************************************!*\
  !*** ./src/engine/transitionManager.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TransitionManager\": () => /* binding */ TransitionManager\n/* harmony export */ });\n/* harmony import */ var d3_transition__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-transition */ \"./node_modules/d3-transition/src/index.js\");\n/* harmony import */ var _features_axis_axis__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./features/axis/axis */ \"./src/engine/features/axis/axis.ts\");\n/* harmony import */ var _features_embeddedLabels_embeddedLabels__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./features/embeddedLabels/embeddedLabels */ \"./src/engine/features/embeddedLabels/embeddedLabels.ts\");\n/* harmony import */ var _features_markDots_markDot__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./features/markDots/markDot */ \"./src/engine/features/markDots/markDot.ts\");\n/* harmony import */ var _features_tolltip_tooltip__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./features/tolltip/tooltip */ \"./src/engine/features/tolltip/tooltip.ts\");\n/* harmony import */ var _polarNotation_aggregator__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./polarNotation/aggregator */ \"./src/engine/polarNotation/aggregator.ts\");\n/* harmony import */ var _polarNotation_donut_donut__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./polarNotation/donut/donut */ \"./src/engine/polarNotation/donut/donut.ts\");\n/* harmony import */ var _twoDimensionalNotation_area_area__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./twoDimensionalNotation/area/area */ \"./src/engine/twoDimensionalNotation/area/area.ts\");\n/* harmony import */ var _twoDimensionalNotation_bar_bar__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./twoDimensionalNotation/bar/bar */ \"./src/engine/twoDimensionalNotation/bar/bar.ts\");\n/* harmony import */ var _twoDimensionalNotation_line_line__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./twoDimensionalNotation/line/line */ \"./src/engine/twoDimensionalNotation/line/line.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass TransitionManager {\r\n    constructor(block, transitionsDurations = null) {\r\n        /**\r\n         * Анимации обновления в ms.\r\n         */\r\n        this.durations = {\r\n            chartUpdate: 1000,\r\n            tooltipSlide: 75,\r\n            donutHover: 200,\r\n            markerHover: 50,\r\n            elementFadeOut: 400\r\n        };\r\n        /**\r\n         * Классы \"подвижных\" элементов\r\n         */\r\n        this.transitionableElemClasses = [\r\n            _features_tolltip_tooltip__WEBPACK_IMPORTED_MODULE_4__.Tooltip.tooltipBlockClass,\r\n            _features_tolltip_tooltip__WEBPACK_IMPORTED_MODULE_4__.Tooltip.tooltipLineClass,\r\n            _features_axis_axis__WEBPACK_IMPORTED_MODULE_1__.Axis.axesClass,\r\n            _twoDimensionalNotation_area_area__WEBPACK_IMPORTED_MODULE_7__.Area.areaChartClass,\r\n            _twoDimensionalNotation_bar_bar__WEBPACK_IMPORTED_MODULE_8__.Bar.barItemClass,\r\n            _twoDimensionalNotation_line_line__WEBPACK_IMPORTED_MODULE_9__.Line.lineChartClass,\r\n            _features_markDots_markDot__WEBPACK_IMPORTED_MODULE_3__.MarkDot.markerDotClass,\r\n            _features_embeddedLabels_embeddedLabels__WEBPACK_IMPORTED_MODULE_2__.EmbeddedLabels.embeddedLabelClass,\r\n            _polarNotation_donut_donut__WEBPACK_IMPORTED_MODULE_6__.Donut.arcPathClass,\r\n            _polarNotation_aggregator__WEBPACK_IMPORTED_MODULE_5__.Aggregator.aggregatorValueClass\r\n        ];\r\n        this.block = block;\r\n        if (transitionsDurations)\r\n            this.setDurations(transitionsDurations);\r\n    }\r\n    interruptTransitions() {\r\n        this.transitionableElemClasses.forEach(elemClass => {\r\n            const elementsSelection = this.block\r\n                .getSvg()\r\n                .selectAll(`.${elemClass}`)\r\n                .interrupt();\r\n            elementsSelection.nodes().forEach(node => (0,d3_transition__WEBPACK_IMPORTED_MODULE_0__.interrupt)(node));\r\n        });\r\n        this.block.getSvg().selectAll(`.${_features_axis_axis__WEBPACK_IMPORTED_MODULE_1__.Axis.axesClass}`).selectAll('*').interrupt();\r\n    }\r\n    setDurations(durations) {\r\n        if (durations.chartUpdate !== undefined && durations.chartUpdate >= 0)\r\n            this.durations.chartUpdate = durations.chartUpdate;\r\n        if (durations.donutHover !== undefined && durations.donutHover >= 0)\r\n            this.durations.donutHover = durations.donutHover;\r\n        if (durations.elementFadeOut !== undefined && durations.elementFadeOut >= 0)\r\n            this.durations.elementFadeOut = durations.elementFadeOut;\r\n        if (durations.markerHover !== undefined && durations.markerHover >= 0)\r\n            this.durations.markerHover = durations.markerHover;\r\n        if (durations.tooltipSlide !== undefined && durations.tooltipSlide >= 0)\r\n            this.durations.tooltipSlide = durations.tooltipSlide;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/transitionManager.ts?");

/***/ }),

/***/ "./src/engine/twoDimensionalNotation/area/area.ts":
/*!********************************************************!*\
  !*** ./src/engine/twoDimensionalNotation/area/area.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Area\": () => /* binding */ Area\n/* harmony export */ });\n/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-shape */ \"./node_modules/d3-shape/src/stack.js\");\n/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-selection */ \"./node_modules/d3-selection/src/select.js\");\n/* harmony import */ var _features_markDots_markDot__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../features/markDots/markDot */ \"./src/engine/features/markDots/markDot.ts\");\n/* harmony import */ var _areaHelper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./areaHelper */ \"./src/engine/twoDimensionalNotation/area/areaHelper.ts\");\n/* harmony import */ var _helpers_domHelper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../helpers/domHelper */ \"./src/engine/helpers/domHelper.ts\");\n/* harmony import */ var _helpers_helper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../helpers/helper */ \"./src/engine/helpers/helper.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\nclass Area {\r\n    static render(block, scales, data, keyField, margin, keyAxisOrient, chart, blockSize) {\r\n        if (chart.isSegmented)\r\n            this.renderSegmented(block, scales, data, keyField, margin, keyAxisOrient, chart);\r\n        else\r\n            this.renderGrouped(block, scales, data, keyField, margin, keyAxisOrient, chart, blockSize);\r\n    }\r\n    static update(block, scales, newData, keyField, margin, chart, keyAxisOrient, blockSize) {\r\n        if (chart.isSegmented) {\r\n            this.updateSegmented(block, scales, newData, keyField, margin, chart, keyAxisOrient);\r\n        }\r\n        else {\r\n            this.updateGrouped(block, scales, newData, keyField, margin, chart, keyAxisOrient, blockSize);\r\n        }\r\n    }\r\n    static renderGrouped(block, scales, data, keyField, margin, keyAxisOrient, chart, blockSize) {\r\n        chart.data.valueFields.forEach((field, valueFieldIndex) => {\r\n            const area = _areaHelper__WEBPACK_IMPORTED_MODULE_1__.AreaHelper.getGroupedAreaGenerator(keyAxisOrient, scales, margin, keyField.name, field.name, blockSize);\r\n            const path = block.getChartGroup(chart.index)\r\n                .append('path')\r\n                .attr('d', area(data))\r\n                .attr('class', this.areaChartClass)\r\n                .style('clip-path', `url(#${block.getClipPathId()})`)\r\n                .style('pointer-events', 'none');\r\n            _helpers_domHelper__WEBPACK_IMPORTED_MODULE_2__.DomHelper.setCssClasses(path, _helpers_helper__WEBPACK_IMPORTED_MODULE_3__.Helper.getCssClassesWithElementIndex(chart.cssClasses, valueFieldIndex));\r\n            _helpers_domHelper__WEBPACK_IMPORTED_MODULE_2__.DomHelper.setChartStyle(path, chart.style, valueFieldIndex, 'fill');\r\n            if (chart.markersOptions.show)\r\n                _features_markDots_markDot__WEBPACK_IMPORTED_MODULE_0__.MarkDot.render(block, data, keyAxisOrient, scales, margin, keyField.name, valueFieldIndex, field.name, chart);\r\n        });\r\n    }\r\n    static renderSegmented(block, scales, data, keyField, margin, keyAxisOrient, chart) {\r\n        const stackedData = (0,d3_shape__WEBPACK_IMPORTED_MODULE_4__.default)().keys(chart.data.valueFields.map(field => field.name))(data);\r\n        const areaGenerator = _areaHelper__WEBPACK_IMPORTED_MODULE_1__.AreaHelper.getSegmentedAreaGenerator(keyAxisOrient, scales, margin, keyField.name);\r\n        const areas = block.getChartGroup(chart.index)\r\n            .selectAll(`.${this.areaChartClass}${_helpers_helper__WEBPACK_IMPORTED_MODULE_3__.Helper.getCssClassesLine(chart.cssClasses)}`)\r\n            .data(stackedData)\r\n            .enter()\r\n            .append('path')\r\n            .attr('d', d => areaGenerator(d))\r\n            .attr('class', this.areaChartClass)\r\n            .style('clip-path', `url(#${block.getClipPathId()})`)\r\n            .style('pointer-events', 'none');\r\n        areas.each(function (d, i) {\r\n            _helpers_domHelper__WEBPACK_IMPORTED_MODULE_2__.DomHelper.setCssClasses((0,d3_selection__WEBPACK_IMPORTED_MODULE_5__.default)(this), _helpers_helper__WEBPACK_IMPORTED_MODULE_3__.Helper.getCssClassesWithElementIndex(chart.cssClasses, i));\r\n        });\r\n        this.setSegmentColor(areas, chart.style.elementColors);\r\n        if (chart.markersOptions.show) {\r\n            stackedData.forEach((dataset, index) => {\r\n                _features_markDots_markDot__WEBPACK_IMPORTED_MODULE_0__.MarkDot.render(block, dataset, keyAxisOrient, scales, margin, keyField.name, index, '1', chart);\r\n            });\r\n        }\r\n    }\r\n    static updateGrouped(block, scales, newData, keyField, margin, chart, keyAxisOrient, blockSize) {\r\n        chart.data.valueFields.forEach((field, valueFieldIndex) => {\r\n            const area = _areaHelper__WEBPACK_IMPORTED_MODULE_1__.AreaHelper.getGroupedAreaGenerator(keyAxisOrient, scales, margin, keyField.name, field.name, blockSize);\r\n            block.getChartGroup(chart.index)\r\n                .select(`.${this.areaChartClass}${_helpers_helper__WEBPACK_IMPORTED_MODULE_3__.Helper.getCssClassesLine(chart.cssClasses)}.chart-element-${valueFieldIndex}`)\r\n                .interrupt()\r\n                .transition()\r\n                .duration(block.transitionManager.durations.chartUpdate)\r\n                .attr('d', area(newData));\r\n            if (chart.markersOptions.show) {\r\n                _features_markDots_markDot__WEBPACK_IMPORTED_MODULE_0__.MarkDot.updateDotsCoordinateByValueAxis(block, newData, keyAxisOrient, scales, margin, keyField.name, valueFieldIndex, field.name, chart);\r\n            }\r\n        });\r\n    }\r\n    static updateSegmented(block, scales, newData, keyField, margin, chart, keyAxisOrient) {\r\n        const stackedData = (0,d3_shape__WEBPACK_IMPORTED_MODULE_4__.default)().keys(chart.data.valueFields.map(field => field.name))(newData);\r\n        const areaGenerator = _areaHelper__WEBPACK_IMPORTED_MODULE_1__.AreaHelper.getSegmentedAreaGenerator(keyAxisOrient, scales, margin, keyField.name);\r\n        const areas = block.getChartGroup(chart.index)\r\n            .selectAll(`path.${this.areaChartClass}${_helpers_helper__WEBPACK_IMPORTED_MODULE_3__.Helper.getCssClassesLine(chart.cssClasses)}`);\r\n        areas\r\n            .data(stackedData)\r\n            .interrupt()\r\n            .transition()\r\n            .duration(block.transitionManager.durations.chartUpdate)\r\n            .attr('d', d => areaGenerator(d));\r\n        if (chart.markersOptions.show) {\r\n            areas.each((dataset, index) => {\r\n                // '1' - атрибут, показывающий координаты согласно полю значения\r\n                _features_markDots_markDot__WEBPACK_IMPORTED_MODULE_0__.MarkDot.updateDotsCoordinateByValueAxis(block, dataset, keyAxisOrient, scales, margin, keyField.name, index, '1', chart);\r\n            });\r\n        }\r\n    }\r\n    static setSegmentColor(segments, colorPalette) {\r\n        segments.style('fill', (d, i) => colorPalette[i % colorPalette.length]);\r\n    }\r\n}\r\nArea.areaChartClass = 'area';\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/twoDimensionalNotation/area/area.ts?");

/***/ }),

/***/ "./src/engine/twoDimensionalNotation/area/areaHelper.ts":
/*!**************************************************************!*\
  !*** ./src/engine/twoDimensionalNotation/area/areaHelper.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AreaHelper\": () => /* binding */ AreaHelper\n/* harmony export */ });\n/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-shape */ \"./node_modules/d3-shape/src/area.js\");\n/* harmony import */ var _features_scale_scale__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../features/scale/scale */ \"./src/engine/features/scale/scale.ts\");\n\r\n\r\nclass AreaHelper {\r\n    static getGroupedAreaGenerator(keyAxisOrient, scales, margin, keyFieldName, valueFieldName, blockSize) {\r\n        if (keyAxisOrient === 'bottom' || keyAxisOrient === 'top')\r\n            return (0,d3_shape__WEBPACK_IMPORTED_MODULE_1__.default)()\r\n                .x(d => _features_scale_scale__WEBPACK_IMPORTED_MODULE_0__.Scale.getScaledValue(scales.key, d[keyFieldName]) + margin.left)\r\n                .y0(d => this.getZeroCoordinate(keyAxisOrient, margin, blockSize))\r\n                .y1(d => scales.value(d[valueFieldName]) + margin.top);\r\n        if (keyAxisOrient === 'left' || keyAxisOrient === 'right')\r\n            return (0,d3_shape__WEBPACK_IMPORTED_MODULE_1__.default)()\r\n                .x0(d => this.getZeroCoordinate(keyAxisOrient, margin, blockSize))\r\n                .x1(d => scales.value(d[valueFieldName]) + margin.left)\r\n                .y(d => _features_scale_scale__WEBPACK_IMPORTED_MODULE_0__.Scale.getScaledValue(scales.key, d[keyFieldName]) + margin.top);\r\n    }\r\n    static getSegmentedAreaGenerator(keyAxisOrient, scales, margin, keyFieldName) {\r\n        if (keyAxisOrient === 'bottom' || keyAxisOrient === 'top') {\r\n            return (0,d3_shape__WEBPACK_IMPORTED_MODULE_1__.default)()\r\n                .x(d => _features_scale_scale__WEBPACK_IMPORTED_MODULE_0__.Scale.getScaledValue(scales.key, d.data[keyFieldName]) + margin.left)\r\n                .y0(d => scales.value(d[0]) + margin.top)\r\n                .y1(d => scales.value(d[1]) + margin.top);\r\n        }\r\n        if (keyAxisOrient === 'left' || keyAxisOrient === 'right') {\r\n            return (0,d3_shape__WEBPACK_IMPORTED_MODULE_1__.default)()\r\n                .x0(d => scales.value(d[0]) + margin.left)\r\n                .x1(d => scales.value(d[1]) + margin.left)\r\n                .y(d => _features_scale_scale__WEBPACK_IMPORTED_MODULE_0__.Scale.getScaledValue(scales.key, d.data[keyFieldName]) + margin.top);\r\n        }\r\n    }\r\n    static getZeroCoordinate(axisOrient, margin, blockSize) {\r\n        if (axisOrient === 'bottom')\r\n            return blockSize.height - margin.bottom;\r\n        if (axisOrient === 'top')\r\n            return margin.top;\r\n        if (axisOrient === 'left')\r\n            return margin.left;\r\n        if (axisOrient === 'right')\r\n            return blockSize.width - margin.right;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/twoDimensionalNotation/area/areaHelper.ts?");

/***/ }),

/***/ "./src/engine/twoDimensionalNotation/bar/bar.ts":
/*!******************************************************!*\
  !*** ./src/engine/twoDimensionalNotation/bar/bar.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Bar\": () => /* binding */ Bar\n/* harmony export */ });\n/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-shape */ \"./node_modules/d3-shape/src/stack.js\");\n/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-selection */ \"./node_modules/d3-selection/src/select.js\");\n/* harmony import */ var _features_embeddedLabels_embeddedLabels__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../features/embeddedLabels/embeddedLabels */ \"./src/engine/features/embeddedLabels/embeddedLabels.ts\");\n/* harmony import */ var _features_embeddedLabels_embeddedLabelsHelper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../features/embeddedLabels/embeddedLabelsHelper */ \"./src/engine/features/embeddedLabels/embeddedLabelsHelper.ts\");\n/* harmony import */ var _barHelper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./barHelper */ \"./src/engine/twoDimensionalNotation/bar/barHelper.ts\");\n/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-array */ \"./node_modules/d3-array/src/sum.js\");\n/* harmony import */ var _helpers_domHelper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../helpers/domHelper */ \"./src/engine/helpers/domHelper.ts\");\n/* harmony import */ var _helpers_helper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../helpers/helper */ \"./src/engine/helpers/helper.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass Bar {\r\n    static render(block, scales, data, keyField, margin, keyAxisOrient, chart, blockSize, barSettings, barsAmounts, isSegmented, firstBarIndex) {\r\n        if (isSegmented)\r\n            this.renderSegmented(block, scales, data, keyField, margin, keyAxisOrient, chart, barsAmounts, blockSize, firstBarIndex, barSettings);\r\n        else\r\n            this.renderGrouped(block, scales, data, keyField, margin, keyAxisOrient, chart, barsAmounts, blockSize, firstBarIndex, barSettings);\r\n    }\r\n    static update(block, newData, scales, margin, keyAxisOrient, chart, blockSize, barsAmounts, keyField, firstBarIndex, barSettings, isSegmented) {\r\n        if (isSegmented) {\r\n            this.updateSegmented(block, newData, scales, margin, keyAxisOrient, chart, blockSize, barsAmounts, keyField, firstBarIndex, barSettings);\r\n        }\r\n        else {\r\n            this.updateGrouped(block, newData, scales, margin, keyAxisOrient, chart, blockSize, barsAmounts, keyField, firstBarIndex, barSettings);\r\n        }\r\n    }\r\n    static getAllBarItems(block, chartCssClasses) {\r\n        return block.getSvg().selectAll(`rect.${this.barItemClass}${_helpers_helper__WEBPACK_IMPORTED_MODULE_4__.Helper.getCssClassesLine(chartCssClasses)}`);\r\n    }\r\n    static renderGrouped(block, scales, data, keyField, margin, keyAxisOrient, chart, barsAmounts, blockSize, firstBarIndex, barSettings) {\r\n        chart.data.valueFields.forEach((field, index) => {\r\n            const bars = block.getChartGroup(chart.index)\r\n                .selectAll(`.${this.barItemClass}${_helpers_helper__WEBPACK_IMPORTED_MODULE_4__.Helper.getCssClassesLine(chart.cssClasses)}${_helpers_helper__WEBPACK_IMPORTED_MODULE_4__.Helper.getCssClassesLine(_helpers_helper__WEBPACK_IMPORTED_MODULE_4__.Helper.getCssClassesWithElementIndex(chart.cssClasses, index))}`)\r\n                .data(data)\r\n                .enter()\r\n                .append('rect')\r\n                .attr('class', this.barItemClass)\r\n                .style('clip-path', `url(#${block.getClipPathId()})`);\r\n            const barAttrs = _barHelper__WEBPACK_IMPORTED_MODULE_2__.BarHelper.getGroupedBarAttrs(keyAxisOrient, scales, margin, keyField.name, field.name, blockSize, _barHelper__WEBPACK_IMPORTED_MODULE_2__.BarHelper.getBarIndex(barsAmounts, chart.index) + index - firstBarIndex, (0,d3_array__WEBPACK_IMPORTED_MODULE_5__.default)(barsAmounts), barSettings);\r\n            this.fillBarAttrs(bars, barAttrs);\r\n            _helpers_domHelper__WEBPACK_IMPORTED_MODULE_3__.DomHelper.setCssClasses(bars, _helpers_helper__WEBPACK_IMPORTED_MODULE_4__.Helper.getCssClassesWithElementIndex(chart.cssClasses, index));\r\n            _helpers_domHelper__WEBPACK_IMPORTED_MODULE_3__.DomHelper.setChartStyle(bars, chart.style, index, 'fill');\r\n            if (chart.embeddedLabels !== 'none')\r\n                _features_embeddedLabels_embeddedLabels__WEBPACK_IMPORTED_MODULE_0__.EmbeddedLabels.render(block, bars, barAttrs, _features_embeddedLabels_embeddedLabelsHelper__WEBPACK_IMPORTED_MODULE_1__.EmbeddedLabelsHelper.getLabelField(chart.embeddedLabels, chart.data.valueFields, keyField, index), chart.embeddedLabels, keyAxisOrient, blockSize, margin, index, chart.cssClasses);\r\n        });\r\n    }\r\n    static renderSegmented(block, scales, data, keyField, margin, keyAxisOrient, chart, barsAmounts, blockSize, firstBarIndex, barSettings) {\r\n        const stackedData = (0,d3_shape__WEBPACK_IMPORTED_MODULE_6__.default)().keys(chart.data.valueFields.map(field => field.name))(data);\r\n        let groups = block.getChartGroup(chart.index)\r\n            .selectAll(`g.${this.barSegmentGroupClass}${_helpers_helper__WEBPACK_IMPORTED_MODULE_4__.Helper.getCssClassesLine(chart.cssClasses)}`)\r\n            .data(stackedData);\r\n        if (groups.empty())\r\n            groups = groups\r\n                .data(stackedData)\r\n                .enter()\r\n                .append('g')\r\n                .attr('class', this.barSegmentGroupClass);\r\n        const bars = groups\r\n            .selectAll(`rect${_helpers_helper__WEBPACK_IMPORTED_MODULE_4__.Helper.getCssClassesLine(chart.cssClasses)}`)\r\n            .data(d => d)\r\n            .enter()\r\n            .append('rect')\r\n            .attr('class', this.barItemClass)\r\n            .style('clip-path', `url(#${block.getClipPathId()})`);\r\n        const barAttrs = _barHelper__WEBPACK_IMPORTED_MODULE_2__.BarHelper.getStackedBarAttr(keyAxisOrient, scales, margin, keyField.name, blockSize, _barHelper__WEBPACK_IMPORTED_MODULE_2__.BarHelper.getBarIndex(barsAmounts, chart.index) - firstBarIndex, (0,d3_array__WEBPACK_IMPORTED_MODULE_5__.default)(barsAmounts), barSettings);\r\n        this.fillBarAttrs(bars, barAttrs);\r\n        _helpers_domHelper__WEBPACK_IMPORTED_MODULE_3__.DomHelper.setCssClasses(groups, chart.cssClasses);\r\n        _helpers_domHelper__WEBPACK_IMPORTED_MODULE_3__.DomHelper.setCssClasses(bars, chart.cssClasses); // Для обозначения принадлежности бара к конкретному чарту\r\n        const thisClass = this;\r\n        groups.each(function (d, i) {\r\n            _helpers_domHelper__WEBPACK_IMPORTED_MODULE_3__.DomHelper.setCssClasses((0,d3_selection__WEBPACK_IMPORTED_MODULE_7__.default)(this).selectAll(`rect${_helpers_helper__WEBPACK_IMPORTED_MODULE_4__.Helper.getCssClassesLine(chart.cssClasses)}`), _helpers_helper__WEBPACK_IMPORTED_MODULE_4__.Helper.getCssClassesWithElementIndex(chart.cssClasses, i)); // Для обозначения принадлежности бара к конкретной части стака\r\n            thisClass.setSegmentColor((0,d3_selection__WEBPACK_IMPORTED_MODULE_7__.default)(this).selectAll(_helpers_helper__WEBPACK_IMPORTED_MODULE_4__.Helper.getCssClassesLine(chart.cssClasses)), chart.style.elementColors, i);\r\n        });\r\n    }\r\n    static updateGrouped(block, newData, scales, margin, keyAxisOrient, chart, blockSize, barsAmounts, keyField, firstBarIndex, barSettings) {\r\n        chart.data.valueFields.forEach((valueField, index) => {\r\n            const indexesOfRemoved = [];\r\n            block.getChartGroup(chart.index)\r\n                .selectAll(`.${this.barItemClass}${_helpers_helper__WEBPACK_IMPORTED_MODULE_4__.Helper.getCssClassesLine(chart.cssClasses)}.chart-element-${index}`)\r\n                .filter((d, i) => {\r\n                if (newData.findIndex(row => row[keyField.name] === d[keyField.name]) === -1) {\r\n                    indexesOfRemoved.push(i); // Набор индексов для встроенных лейблов\r\n                    return true;\r\n                }\r\n                return false;\r\n            })\r\n                .transition()\r\n                .duration(block.transitionManager.durations.elementFadeOut)\r\n                .style('opacity', 0)\r\n                .remove();\r\n            const bars = block.getChartGroup(chart.index)\r\n                .selectAll(`.${this.barItemClass}${_helpers_helper__WEBPACK_IMPORTED_MODULE_4__.Helper.getCssClassesLine(chart.cssClasses)}.chart-element-${index}`)\r\n                .filter(d => newData.findIndex(row => row[keyField.name] === d[keyField.name]) !== -1)\r\n                .style('opacity', 1)\r\n                .data(newData);\r\n            const newBars = bars\r\n                .enter()\r\n                .append('rect')\r\n                .attr('class', this.barItemClass)\r\n                .style('clip-path', `url(#${block.getClipPathId()})`);\r\n            const barAttrs = _barHelper__WEBPACK_IMPORTED_MODULE_2__.BarHelper.getGroupedBarAttrs(keyAxisOrient, scales, margin, keyField.name, valueField.name, blockSize, _barHelper__WEBPACK_IMPORTED_MODULE_2__.BarHelper.getBarIndex(barsAmounts, chart.index) + index - firstBarIndex, (0,d3_array__WEBPACK_IMPORTED_MODULE_5__.default)(barsAmounts), barSettings);\r\n            this.fillBarAttrs(bars, barAttrs, block.transitionManager.durations.chartUpdate);\r\n            this.fillBarAttrs(newBars, barAttrs);\r\n            _helpers_domHelper__WEBPACK_IMPORTED_MODULE_3__.DomHelper.setCssClasses(newBars, _helpers_helper__WEBPACK_IMPORTED_MODULE_4__.Helper.getCssClassesWithElementIndex(chart.cssClasses, index));\r\n            _helpers_domHelper__WEBPACK_IMPORTED_MODULE_3__.DomHelper.setChartStyle(newBars, chart.style, index, 'fill');\r\n            if (chart.embeddedLabels !== 'none') {\r\n                _features_embeddedLabels_embeddedLabels__WEBPACK_IMPORTED_MODULE_0__.EmbeddedLabels.removeUnused(block, chart.cssClasses, index, indexesOfRemoved);\r\n                _features_embeddedLabels_embeddedLabels__WEBPACK_IMPORTED_MODULE_0__.EmbeddedLabels.update(block, bars, keyAxisOrient, barAttrs, margin, valueField, chart.embeddedLabels, blockSize, newData, index, chart.cssClasses);\r\n                if (!newBars.empty())\r\n                    _features_embeddedLabels_embeddedLabels__WEBPACK_IMPORTED_MODULE_0__.EmbeddedLabels.render(block, newBars, barAttrs, valueField, chart.embeddedLabels, keyAxisOrient, blockSize, margin, index, chart.cssClasses);\r\n                _features_embeddedLabels_embeddedLabels__WEBPACK_IMPORTED_MODULE_0__.EmbeddedLabels.restoreRemoved(block, bars, barAttrs, valueField, chart.embeddedLabels, keyAxisOrient, blockSize, margin, index, chart.cssClasses, keyField.name);\r\n            }\r\n        });\r\n    }\r\n    static updateSegmented(block, newData, scales, margin, keyAxisOrient, chart, blockSize, barsAmounts, keyField, firstBarIndex, barSettings) {\r\n        const stackedData = (0,d3_shape__WEBPACK_IMPORTED_MODULE_6__.default)().keys(chart.data.valueFields.map(field => field.name))(newData);\r\n        block.getChartGroup(chart.index)\r\n            .selectAll(`.${this.barItemClass}${_helpers_helper__WEBPACK_IMPORTED_MODULE_4__.Helper.getCssClassesLine(chart.cssClasses)}`)\r\n            .filter(d => newData.findIndex(row => row[keyField.name] === d.data[keyField.name]) === -1)\r\n            .transition()\r\n            .duration(block.transitionManager.durations.elementFadeOut)\r\n            .style('opacity', 0)\r\n            .remove();\r\n        const groups = block.getChartGroup(chart.index)\r\n            .selectAll(`g.${this.barSegmentGroupClass}${_helpers_helper__WEBPACK_IMPORTED_MODULE_4__.Helper.getCssClassesLine(chart.cssClasses)}`)\r\n            .data(stackedData);\r\n        const bars = groups\r\n            .selectAll(`.${this.barItemClass}${_helpers_helper__WEBPACK_IMPORTED_MODULE_4__.Helper.getCssClassesLine(chart.cssClasses)}`)\r\n            .filter(d => newData.findIndex(row => row[keyField.name] === d.data[keyField.name]) !== -1)\r\n            .style('opacity', 1)\r\n            .data(d => d);\r\n        const newBars = bars.enter()\r\n            .append('rect')\r\n            .attr('class', this.barItemClass)\r\n            .style('clip-path', `url(#${block.getClipPathId()})`);\r\n        const barAttrs = _barHelper__WEBPACK_IMPORTED_MODULE_2__.BarHelper.getStackedBarAttr(keyAxisOrient, scales, margin, keyField.name, blockSize, _barHelper__WEBPACK_IMPORTED_MODULE_2__.BarHelper.getBarIndex(barsAmounts, chart.index) - firstBarIndex, (0,d3_array__WEBPACK_IMPORTED_MODULE_5__.default)(barsAmounts), barSettings);\r\n        this.fillBarAttrs(bars, barAttrs, block.transitionManager.durations.chartUpdate);\r\n        this.fillBarAttrs(newBars, barAttrs);\r\n        _helpers_domHelper__WEBPACK_IMPORTED_MODULE_3__.DomHelper.setCssClasses(newBars, chart.cssClasses);\r\n        const thisClass = this;\r\n        groups.each(function (d, i) {\r\n            _helpers_domHelper__WEBPACK_IMPORTED_MODULE_3__.DomHelper.setCssClasses((0,d3_selection__WEBPACK_IMPORTED_MODULE_7__.default)(this).selectAll(`rect${_helpers_helper__WEBPACK_IMPORTED_MODULE_4__.Helper.getCssClassesLine(chart.cssClasses)}`), _helpers_helper__WEBPACK_IMPORTED_MODULE_4__.Helper.getCssClassesWithElementIndex(chart.cssClasses, i)); // Для обозначения принадлежности бара к конкретной части стака\r\n            thisClass.setSegmentColor((0,d3_selection__WEBPACK_IMPORTED_MODULE_7__.default)(this).selectAll(_helpers_helper__WEBPACK_IMPORTED_MODULE_4__.Helper.getCssClassesLine(chart.cssClasses)), chart.style.elementColors, i);\r\n        });\r\n    }\r\n    static fillBarAttrs(bars, barAttrs, transitionDuration = 0) {\r\n        let barsHander = bars;\r\n        if (transitionDuration > 0) {\r\n            barsHander = barsHander\r\n                .interrupt()\r\n                .transition()\r\n                .duration(transitionDuration);\r\n        }\r\n        barsHander.attr('x', d => barAttrs.x(d))\r\n            .attr('y', d => barAttrs.y(d))\r\n            .attr('height', d => barAttrs.height(d))\r\n            .attr('width', d => barAttrs.width(d));\r\n        return barsHander;\r\n    }\r\n    static setSegmentColor(segments, colorPalette, segmentedIndex) {\r\n        segments.style('fill', colorPalette[segmentedIndex % colorPalette.length]);\r\n    }\r\n}\r\nBar.barItemClass = 'bar-item';\r\nBar.barSegmentGroupClass = 'bar-segment-group';\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/twoDimensionalNotation/bar/bar.ts?");

/***/ }),

/***/ "./src/engine/twoDimensionalNotation/bar/barHelper.ts":
/*!************************************************************!*\
  !*** ./src/engine/twoDimensionalNotation/bar/barHelper.ts ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BarHelper\": () => /* binding */ BarHelper\n/* harmony export */ });\n/* harmony import */ var _features_scale_scale__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../features/scale/scale */ \"./src/engine/features/scale/scale.ts\");\n/* harmony import */ var _helpers_helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../helpers/helper */ \"./src/engine/helpers/helper.ts\");\n\r\n\r\nclass BarHelper {\r\n    static getGroupedBarAttrs(keyAxisOrient, scales, margin, keyField, valueFieldName, blockSize, barIndex, barsAmount, barSettings) {\r\n        const attrs = {\r\n            x: null,\r\n            y: null,\r\n            width: null,\r\n            height: null\r\n        };\r\n        this.setBarAttrsByKey(attrs, keyAxisOrient, scales.key, margin, keyField, barIndex, barsAmount, barSettings, false);\r\n        this.setGroupedBarAttrsByValue(attrs, keyAxisOrient, margin, scales.value, valueFieldName, blockSize);\r\n        return attrs;\r\n    }\r\n    static getStackedBarAttr(keyAxisOrient, scales, margin, keyField, blockSize, barIndex, barsAmount, barSettings) {\r\n        const attrs = {\r\n            x: null,\r\n            y: null,\r\n            width: null,\r\n            height: null\r\n        };\r\n        this.setBarAttrsByKey(attrs, keyAxisOrient, scales.key, margin, keyField, barIndex, barsAmount, barSettings, true);\r\n        this.setSegmentedBarAttrsByValue(attrs, keyAxisOrient, scales.value, margin, blockSize);\r\n        return attrs;\r\n    }\r\n    static getBarsInGroupAmount(charts) {\r\n        let amounts = [];\r\n        charts.forEach((chart) => {\r\n            if (chart.type === 'bar' && chart.isSegmented)\r\n                amounts.push(1); // Сегментированный бар содержит все свои valueFields в одном баре\r\n            else if (chart.type === 'bar')\r\n                amounts.push(chart.data.valueFields.length);\r\n        });\r\n        return amounts;\r\n    }\r\n    /**\r\n     * Получение индекса бара среди всх графиков и value-филдов. Используется для того, чтобы узнать, какой по счету в группе\r\n     * этот бар идет (сегментированный всегда один, группированный - количество value-филдов).\r\n     * @param barsAmounts\r\n     * @param chartIndex\r\n     */\r\n    static getBarIndex(barsAmounts, chartIndex) {\r\n        if (barsAmounts.length < 2)\r\n            return 0;\r\n        let index = 0;\r\n        barsAmounts.forEach((chartBars, i) => {\r\n            if (i < chartIndex) {\r\n                index += chartBars;\r\n            }\r\n        });\r\n        return index;\r\n    }\r\n    static setBarAttrsByKey(attrs, keyAxisOrient, scaleKey, margin, keyField, barIndex, barsAmount, barSettings, isSegmented) {\r\n        const barStep = (_features_scale_scale__WEBPACK_IMPORTED_MODULE_0__.Scale.getScaleBandWidth(scaleKey) - barSettings.barDistance * (barsAmount - 1)) / barsAmount; // Space for one bar\r\n        const barSize = barStep > barSettings.maxBarWidth ? barSettings.maxBarWidth : barStep;\r\n        const barDiff = (barStep - barSize) * barsAmount / 2; // if bar bigger than maxWidth, diff for x coordinate\r\n        const barPad = barSize * barIndex + barSettings.barDistance * barIndex + barDiff; // Отступ бара от края. Зависит от количества баров в одной группе и порядке текущего бара\r\n        if (keyAxisOrient === 'top' || keyAxisOrient === 'bottom') {\r\n            attrs.x = d => scaleKey(_helpers_helper__WEBPACK_IMPORTED_MODULE_1__.Helper.getKeyFieldValue(d, keyField, isSegmented)) + margin.left + barPad;\r\n            attrs.width = d => barSize;\r\n        }\r\n        if (keyAxisOrient === 'left' || keyAxisOrient === 'right') {\r\n            attrs.y = d => scaleKey(_helpers_helper__WEBPACK_IMPORTED_MODULE_1__.Helper.getKeyFieldValue(d, keyField, isSegmented)) + margin.top + barPad;\r\n            attrs.height = d => barSize;\r\n        }\r\n    }\r\n    static setGroupedBarAttrsByValue(attrs, keyAxisOrient, margin, scaleValue, valueFieldName, blockSize) {\r\n        if (keyAxisOrient === 'top') {\r\n            attrs.y = d => margin.top;\r\n            attrs.height = d => _helpers_helper__WEBPACK_IMPORTED_MODULE_1__.Helper.getValueOrZero(scaleValue(d[valueFieldName]));\r\n        }\r\n        if (keyAxisOrient === 'bottom') {\r\n            attrs.y = d => scaleValue(d[valueFieldName]) + margin.top;\r\n            attrs.height = d => _helpers_helper__WEBPACK_IMPORTED_MODULE_1__.Helper.getValueOrZero(blockSize.height - margin.top - margin.bottom - scaleValue(d[valueFieldName]));\r\n        }\r\n        if (keyAxisOrient === 'left') {\r\n            attrs.x = d => margin.left + 1;\r\n            attrs.width = d => _helpers_helper__WEBPACK_IMPORTED_MODULE_1__.Helper.getValueOrZero(scaleValue(d[valueFieldName]));\r\n        }\r\n        if (keyAxisOrient === 'right') {\r\n            attrs.x = d => scaleValue(d[valueFieldName]) + margin.left;\r\n            attrs.width = d => _helpers_helper__WEBPACK_IMPORTED_MODULE_1__.Helper.getValueOrZero(blockSize.width - margin.left - margin.right - scaleValue(d[valueFieldName]));\r\n        }\r\n    }\r\n    static setSegmentedBarAttrsByValue(attrs, keyAxisOrient, scaleValue, margin, blockSize) {\r\n        if (keyAxisOrient === 'top') {\r\n            attrs.y = d => margin.top + scaleValue(d[0]);\r\n            attrs.height = d => _helpers_helper__WEBPACK_IMPORTED_MODULE_1__.Helper.getValueOrZero(scaleValue(d[1] - d[0]));\r\n        }\r\n        if (keyAxisOrient === 'bottom') {\r\n            attrs.y = d => scaleValue(d[1]) + margin.top;\r\n            attrs.height = d => _helpers_helper__WEBPACK_IMPORTED_MODULE_1__.Helper.getValueOrZero(blockSize.height - margin.top - margin.bottom - scaleValue(d[1] - d[0]));\r\n        }\r\n        if (keyAxisOrient === 'left') {\r\n            attrs.x = d => margin.left + scaleValue(d[0]) + 1;\r\n            attrs.width = d => _helpers_helper__WEBPACK_IMPORTED_MODULE_1__.Helper.getValueOrZero(scaleValue(d[1] - d[0]));\r\n        }\r\n        if (keyAxisOrient === 'right') {\r\n            attrs.x = d => scaleValue(d[1]) + margin.left;\r\n            attrs.width = d => _helpers_helper__WEBPACK_IMPORTED_MODULE_1__.Helper.getValueOrZero(blockSize.width - margin.left - margin.right - scaleValue(d[1] - d[0]));\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/twoDimensionalNotation/bar/barHelper.ts?");

/***/ }),

/***/ "./src/engine/twoDimensionalNotation/line/line.ts":
/*!********************************************************!*\
  !*** ./src/engine/twoDimensionalNotation/line/line.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Line\": () => /* binding */ Line\n/* harmony export */ });\n/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-shape */ \"./node_modules/d3-shape/src/stack.js\");\n/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-selection */ \"./node_modules/d3-selection/src/select.js\");\n/* harmony import */ var _features_markDots_markDot__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../features/markDots/markDot */ \"./src/engine/features/markDots/markDot.ts\");\n/* harmony import */ var _lineHelper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lineHelper */ \"./src/engine/twoDimensionalNotation/line/lineHelper.ts\");\n/* harmony import */ var _helpers_domHelper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../helpers/domHelper */ \"./src/engine/helpers/domHelper.ts\");\n/* harmony import */ var _helpers_helper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../helpers/helper */ \"./src/engine/helpers/helper.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\nclass Line {\r\n    static render(block, scales, data, keyField, margin, keyAxisOrient, chart) {\r\n        if (chart.isSegmented)\r\n            this.renderSegmented(block, scales, data, keyField, margin, keyAxisOrient, chart, chart.markersOptions.show);\r\n        else\r\n            this.renderGrouped(block, scales, data, keyField, margin, keyAxisOrient, chart, chart.markersOptions.show);\r\n    }\r\n    static update(block, scales, newData, keyField, margin, keyAxisOrient, chart) {\r\n        if (chart.isSegmented) {\r\n            this.updateSegmeneted(block, scales, newData, keyField, margin, keyAxisOrient, chart);\r\n        }\r\n        else {\r\n            this.updateGrouped(block, scales, newData, keyField, margin, keyAxisOrient, chart);\r\n        }\r\n    }\r\n    static renderGrouped(block, scales, data, keyField, margin, keyAxisOrient, chart, markFlag) {\r\n        chart.data.valueFields.forEach((valueField, valueFieldIndex) => {\r\n            const lineGenerator = _lineHelper__WEBPACK_IMPORTED_MODULE_1__.LineHelper.getLineGenerator(keyAxisOrient, scales, keyField.name, valueField.name, margin);\r\n            const path = block.getChartGroup(chart.index)\r\n                .append('path')\r\n                .attr('d', lineGenerator(data))\r\n                .attr('class', this.lineChartClass)\r\n                .style('fill', 'none')\r\n                .style('clip-path', `url(#${block.getClipPathId()})`)\r\n                .style('pointer-events', 'none');\r\n            _helpers_domHelper__WEBPACK_IMPORTED_MODULE_2__.DomHelper.setCssClasses(path, _helpers_helper__WEBPACK_IMPORTED_MODULE_3__.Helper.getCssClassesWithElementIndex(chart.cssClasses, valueFieldIndex));\r\n            _helpers_domHelper__WEBPACK_IMPORTED_MODULE_2__.DomHelper.setChartStyle(path, chart.style, valueFieldIndex, 'stroke');\r\n            if (markFlag)\r\n                _features_markDots_markDot__WEBPACK_IMPORTED_MODULE_0__.MarkDot.render(block, data, keyAxisOrient, scales, margin, keyField.name, valueFieldIndex, valueField.name, chart);\r\n        });\r\n    }\r\n    static renderSegmented(block, scales, data, keyField, margin, keyAxisOrient, chart, markFlag) {\r\n        const stackedData = (0,d3_shape__WEBPACK_IMPORTED_MODULE_4__.default)().keys(chart.data.valueFields.map(field => field.name))(data);\r\n        const lineGenerator = _lineHelper__WEBPACK_IMPORTED_MODULE_1__.LineHelper.getSegmentedLineGenerator(keyAxisOrient, scales, keyField.name, margin);\r\n        const lines = block.getChartGroup(chart.index)\r\n            .selectAll(`.${this.lineChartClass}${_helpers_helper__WEBPACK_IMPORTED_MODULE_3__.Helper.getCssClassesLine(chart.cssClasses)}`)\r\n            .data(stackedData)\r\n            .enter()\r\n            .append('path')\r\n            .attr('d', d => lineGenerator(d))\r\n            .attr('class', this.lineChartClass)\r\n            .style('fill', 'none')\r\n            .style('clip-path', `url(#${block.getClipPathId()})`)\r\n            .style('pointer-events', 'none');\r\n        lines.each(function (d, i) {\r\n            _helpers_domHelper__WEBPACK_IMPORTED_MODULE_2__.DomHelper.setCssClasses((0,d3_selection__WEBPACK_IMPORTED_MODULE_5__.default)(this), _helpers_helper__WEBPACK_IMPORTED_MODULE_3__.Helper.getCssClassesWithElementIndex(chart.cssClasses, i));\r\n        });\r\n        this.setSegmentColor(lines, chart.style.elementColors);\r\n        stackedData.forEach((dataset, stackIndex) => {\r\n            if (markFlag)\r\n                _features_markDots_markDot__WEBPACK_IMPORTED_MODULE_0__.MarkDot.render(block, dataset, keyAxisOrient, scales, margin, keyField.name, stackIndex, '1', chart);\r\n        });\r\n    }\r\n    static updateGrouped(block, scales, newData, keyField, margin, keyAxisOrient, chart) {\r\n        chart.data.valueFields.forEach((valueField, valueFieldIndex) => {\r\n            const lineGenerator = _lineHelper__WEBPACK_IMPORTED_MODULE_1__.LineHelper.getLineGenerator(keyAxisOrient, scales, keyField.name, valueField.name, margin);\r\n            block.getChartGroup(chart.index)\r\n                .select(`.${this.lineChartClass}${_helpers_helper__WEBPACK_IMPORTED_MODULE_3__.Helper.getCssClassesLine(chart.cssClasses)}.chart-element-${valueFieldIndex}`)\r\n                .interrupt()\r\n                .transition()\r\n                .duration(block.transitionManager.durations.chartUpdate)\r\n                .attr('d', lineGenerator(newData));\r\n            if (chart.markersOptions.show) {\r\n                _features_markDots_markDot__WEBPACK_IMPORTED_MODULE_0__.MarkDot.updateDotsCoordinateByValueAxis(block, newData, keyAxisOrient, scales, margin, keyField.name, valueFieldIndex, valueField.name, chart);\r\n            }\r\n        });\r\n    }\r\n    static updateSegmeneted(block, scales, newData, keyField, margin, keyAxisOrient, chart) {\r\n        const stackedData = (0,d3_shape__WEBPACK_IMPORTED_MODULE_4__.default)().keys(chart.data.valueFields.map(field => field.name))(newData);\r\n        const lineGenerator = _lineHelper__WEBPACK_IMPORTED_MODULE_1__.LineHelper.getSegmentedLineGenerator(keyAxisOrient, scales, keyField.name, margin);\r\n        const lines = block.getChartGroup(chart.index)\r\n            .selectAll(`path.${this.lineChartClass}${_helpers_helper__WEBPACK_IMPORTED_MODULE_3__.Helper.getCssClassesLine(chart.cssClasses)}`);\r\n        lines\r\n            .data(stackedData)\r\n            .interrupt()\r\n            .transition()\r\n            .duration(block.transitionManager.durations.chartUpdate)\r\n            .attr('d', d => lineGenerator(d));\r\n        if (chart.markersOptions.show) {\r\n            lines.each((dataset, index) => {\r\n                _features_markDots_markDot__WEBPACK_IMPORTED_MODULE_0__.MarkDot.updateDotsCoordinateByValueAxis(block, dataset, keyAxisOrient, scales, margin, keyField.name, index, '1', chart);\r\n            });\r\n        }\r\n    }\r\n    static setSegmentColor(segments, colorPalette) {\r\n        segments.style('stroke', (d, i) => colorPalette[i % colorPalette.length]);\r\n    }\r\n}\r\nLine.lineChartClass = 'line';\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/twoDimensionalNotation/line/line.ts?");

/***/ }),

/***/ "./src/engine/twoDimensionalNotation/line/lineHelper.ts":
/*!**************************************************************!*\
  !*** ./src/engine/twoDimensionalNotation/line/lineHelper.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LineHelper\": () => /* binding */ LineHelper\n/* harmony export */ });\n/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-shape */ \"./node_modules/d3-shape/src/line.js\");\n/* harmony import */ var _features_scale_scale__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../features/scale/scale */ \"./src/engine/features/scale/scale.ts\");\n\r\n\r\nclass LineHelper {\r\n    static getLineGenerator(keyAxisOrient, scales, keyFieldName, valueFieldName, margin) {\r\n        if (keyAxisOrient === 'bottom' || keyAxisOrient === 'top') {\r\n            return (0,d3_shape__WEBPACK_IMPORTED_MODULE_1__.default)()\r\n                .x(d => _features_scale_scale__WEBPACK_IMPORTED_MODULE_0__.Scale.getScaledValue(scales.key, d[keyFieldName]) + margin.left)\r\n                .y(d => scales.value(d[valueFieldName]) + margin.top);\r\n        }\r\n        if (keyAxisOrient === 'left' || keyAxisOrient === 'right') {\r\n            return (0,d3_shape__WEBPACK_IMPORTED_MODULE_1__.default)()\r\n                .x(d => scales.value(d[valueFieldName]) + margin.left)\r\n                .y(d => _features_scale_scale__WEBPACK_IMPORTED_MODULE_0__.Scale.getScaledValue(scales.key, d[keyFieldName]) + margin.top);\r\n        }\r\n    }\r\n    static getSegmentedLineGenerator(keyAxisOrient, scales, keyFieldName, margin) {\r\n        if (keyAxisOrient === 'bottom' || keyAxisOrient === 'top') {\r\n            return (0,d3_shape__WEBPACK_IMPORTED_MODULE_1__.default)()\r\n                .x(d => _features_scale_scale__WEBPACK_IMPORTED_MODULE_0__.Scale.getScaledValue(scales.key, d.data[keyFieldName]) + margin.left)\r\n                .y(d => scales.value(d[1]) + margin.top);\r\n        }\r\n        if (keyAxisOrient === 'left' || keyAxisOrient === 'right') {\r\n            return (0,d3_shape__WEBPACK_IMPORTED_MODULE_1__.default)()\r\n                .x(d => scales.value(d[1]) + margin.left)\r\n                .y(d => _features_scale_scale__WEBPACK_IMPORTED_MODULE_0__.Scale.getScaledValue(scales.key, d.data[keyFieldName]) + margin.top);\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/twoDimensionalNotation/line/lineHelper.ts?");

/***/ }),

/***/ "./src/engine/twoDimensionalNotation/twoDimensionalManager.ts":
/*!********************************************************************!*\
  !*** ./src/engine/twoDimensionalNotation/twoDimensionalManager.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TwoDimensionalManager\": () => /* binding */ TwoDimensionalManager\n/* harmony export */ });\n/* harmony import */ var _elementHighlighter_elementHighlighter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../elementHighlighter/elementHighlighter */ \"./src/engine/elementHighlighter/elementHighlighter.ts\");\n/* harmony import */ var _features_axis_axis__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../features/axis/axis */ \"./src/engine/features/axis/axis.ts\");\n/* harmony import */ var _features_embeddedLabels_embeddedLabels__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../features/embeddedLabels/embeddedLabels */ \"./src/engine/features/embeddedLabels/embeddedLabels.ts\");\n/* harmony import */ var _features_gridLine_gridLine__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../features/gridLine/gridLine */ \"./src/engine/features/gridLine/gridLine.ts\");\n/* harmony import */ var _features_legend_legend__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../features/legend/legend */ \"./src/engine/features/legend/legend.ts\");\n/* harmony import */ var _features_recordOverflowAlert_recordOverflowAlert__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../features/recordOverflowAlert/recordOverflowAlert */ \"./src/engine/features/recordOverflowAlert/recordOverflowAlert.ts\");\n/* harmony import */ var _features_scale_scale__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../features/scale/scale */ \"./src/engine/features/scale/scale.ts\");\n/* harmony import */ var _features_title_title__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../features/title/title */ \"./src/engine/features/title/title.ts\");\n/* harmony import */ var _features_tolltip_tooltip__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../features/tolltip/tooltip */ \"./src/engine/features/tolltip/tooltip.ts\");\n/* harmony import */ var _helpers_helper__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../helpers/helper */ \"./src/engine/helpers/helper.ts\");\n/* harmony import */ var _area_area__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./area/area */ \"./src/engine/twoDimensionalNotation/area/area.ts\");\n/* harmony import */ var _bar_bar__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./bar/bar */ \"./src/engine/twoDimensionalNotation/bar/bar.ts\");\n/* harmony import */ var _bar_barHelper__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./bar/barHelper */ \"./src/engine/twoDimensionalNotation/bar/barHelper.ts\");\n/* harmony import */ var _line_line__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./line/line */ \"./src/engine/twoDimensionalNotation/line/line.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass TwoDimensionalManager {\r\n    static render(engine, model) {\r\n        const options = model.options;\r\n        const scales = _features_scale_scale__WEBPACK_IMPORTED_MODULE_6__.Scale.getScales(options.scale.key, options.scale.value, model.chartSettings.bar);\r\n        engine.block.scales = scales;\r\n        engine.block.renderSvg(model.blockCanvas.size);\r\n        _features_axis_axis__WEBPACK_IMPORTED_MODULE_1__.Axis.render(engine.block, scales, options.scale, options.axis, model.chartBlock.margin, model.blockCanvas.size);\r\n        _features_gridLine_gridLine__WEBPACK_IMPORTED_MODULE_3__.GridLine.render(engine.block, options.additionalElements.gridLine.flag, options.axis.key, options.axis.value, model.blockCanvas.size, model.chartBlock.margin, options.scale.key);\r\n        this.renderCharts(engine.block, options.charts, scales, engine.data, options.data, model.chartBlock.margin, options.axis.key.orient, model.chartSettings.bar, model.blockCanvas.size);\r\n        engine.block.filterEventManager.registerEventFor2D(scales.key, model.chartBlock.margin, model.blockCanvas.size, options);\r\n        engine.block.filterEventManager.event2DUpdate(options);\r\n        _features_title_title__WEBPACK_IMPORTED_MODULE_7__.Title.render(engine.block, options.title, model.otherComponents.titleBlock, model.blockCanvas.size);\r\n        _features_legend_legend__WEBPACK_IMPORTED_MODULE_4__.Legend.render(engine.block, engine.data, options, model);\r\n        _features_tolltip_tooltip__WEBPACK_IMPORTED_MODULE_8__.Tooltip.render(engine.block, model, engine.data, model.otherComponents.tooltipBlock, scales);\r\n        if (model.dataSettings.scope.hidedRecordsAmount !== 0)\r\n            _features_recordOverflowAlert_recordOverflowAlert__WEBPACK_IMPORTED_MODULE_5__.RecordOverflowAlert.render(engine.block, model.dataSettings.scope.hidedRecordsAmount, 'top', options.orient);\r\n    }\r\n    static updateData(block, model, data) {\r\n        block.transitionManager.interruptTransitions();\r\n        block.filterEventManager.updateData(data[model.options.data.dataSource]);\r\n        const options = model.options;\r\n        _elementHighlighter_elementHighlighter__WEBPACK_IMPORTED_MODULE_0__.ElementHighlighter.remove2DChartsFullHighlighting(block, options.charts);\r\n        const scales = _features_scale_scale__WEBPACK_IMPORTED_MODULE_6__.Scale.getScales(options.scale.key, options.scale.value, model.chartSettings.bar);\r\n        const keyDomainEquality = _helpers_helper__WEBPACK_IMPORTED_MODULE_9__.Helper.checkDomainsEquality(block.scales.key.domain(), scales.key.domain());\r\n        block.scales = scales;\r\n        _features_axis_axis__WEBPACK_IMPORTED_MODULE_1__.Axis.update(block, scales, options.scale, options.axis, model.blockCanvas.size, keyDomainEquality);\r\n        _features_gridLine_gridLine__WEBPACK_IMPORTED_MODULE_3__.GridLine.update(block, options.additionalElements.gridLine.flag, options.axis.key, options.axis.value, model.blockCanvas.size, model.chartBlock.margin, options.scale.key);\r\n        this.updateCharts(block, options.charts, scales, data, model.options.data, model.chartBlock.margin, options.axis.key.orient, model.blockCanvas.size, model.chartSettings.bar);\r\n        block.filterEventManager.event2DUpdate(options);\r\n        _features_tolltip_tooltip__WEBPACK_IMPORTED_MODULE_8__.Tooltip.render(block, model, data, model.otherComponents.tooltipBlock, scales);\r\n        _features_recordOverflowAlert_recordOverflowAlert__WEBPACK_IMPORTED_MODULE_5__.RecordOverflowAlert.update(block, model.dataSettings.scope.hidedRecordsAmount, 'top', options.orient);\r\n    }\r\n    static renderCharts(block, charts, scales, data, dataOptions, margin, keyAxisOrient, barSettings, blockSize) {\r\n        block.renderChartClipPath(margin, blockSize);\r\n        block.renderChartsBlock();\r\n        charts.forEach((chart) => {\r\n            if (chart.type === 'bar')\r\n                _bar_bar__WEBPACK_IMPORTED_MODULE_11__.Bar.render(block, scales, data[dataOptions.dataSource], dataOptions.keyField, margin, keyAxisOrient, chart, blockSize, barSettings, _bar_barHelper__WEBPACK_IMPORTED_MODULE_12__.BarHelper.getBarsInGroupAmount(charts), chart.isSegmented, charts.findIndex(ch => ch.type === 'bar'));\r\n            else if (chart.type === 'line')\r\n                _line_line__WEBPACK_IMPORTED_MODULE_13__.Line.render(block, scales, data[dataOptions.dataSource], dataOptions.keyField, margin, keyAxisOrient, chart);\r\n            else if (chart.type === 'area')\r\n                _area_area__WEBPACK_IMPORTED_MODULE_10__.Area.render(block, scales, data[dataOptions.dataSource], dataOptions.keyField, margin, keyAxisOrient, chart, blockSize);\r\n        });\r\n        _features_embeddedLabels_embeddedLabels__WEBPACK_IMPORTED_MODULE_2__.EmbeddedLabels.raiseGroups(block);\r\n    }\r\n    static updateCharts(block, charts, scales, data, dataOptions, margin, keyAxisOrient, blockSize, barSettings) {\r\n        block.updateChartClipPath(margin, blockSize);\r\n        charts.forEach((chart) => {\r\n            if (chart.type === 'bar') {\r\n                _bar_bar__WEBPACK_IMPORTED_MODULE_11__.Bar.update(block, data[dataOptions.dataSource], scales, margin, keyAxisOrient, chart, blockSize, _bar_barHelper__WEBPACK_IMPORTED_MODULE_12__.BarHelper.getBarsInGroupAmount(charts), dataOptions.keyField, charts.findIndex(ch => ch.type === 'bar'), barSettings, chart.isSegmented);\r\n            }\r\n            else if (chart.type === 'line') {\r\n                _line_line__WEBPACK_IMPORTED_MODULE_13__.Line.update(block, scales, data[dataOptions.dataSource], dataOptions.keyField, margin, keyAxisOrient, chart);\r\n            }\r\n            else if (chart.type === 'area') {\r\n                _area_area__WEBPACK_IMPORTED_MODULE_10__.Area.update(block, scales, data[dataOptions.dataSource], dataOptions.keyField, margin, chart, keyAxisOrient, blockSize);\r\n            }\r\n        });\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/twoDimensionalNotation/twoDimensionalManager.ts?");

/***/ }),

/***/ "./src/engine/valueFormatter.ts":
/*!**************************************!*\
  !*** ./src/engine/valueFormatter.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ValueFormatter\": () => /* binding */ ValueFormatter\n/* harmony export */ });\nclass ValueFormatter {\r\n    static formatField(fieldFormat, value) {\r\n        return this.format(value, { type: fieldFormat });\r\n    }\r\n    static setFormatFunction(formatFunction) {\r\n        this.format = formatFunction;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/valueFormatter.ts?");

/***/ }),

/***/ "./src/model/chartStyleModel.ts":
/*!**************************************!*\
  !*** ./src/model/chartStyleModel.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ChartStyleModel\": () => /* binding */ ChartStyleModel\n/* harmony export */ });\n/* harmony import */ var chroma_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chroma-js */ \"./node_modules/chroma-js/chroma.js\");\n/* harmony import */ var chroma_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(chroma_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _modelHelper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modelHelper */ \"./src/model/modelHelper.ts\");\n\r\n\r\nclass ChartStyleModel {\r\n    static getCssClasses(chartIndex) {\r\n        const cssClasses = [`chart-${chartIndex}`];\r\n        return cssClasses;\r\n    }\r\n    static get2DChartStyle(chartsAmount, chartType, chartsFieldsAmounts, chartIndex, isSegmented, styleConfig) {\r\n        const startIndex = this.getStartIndex(chartIndex, chartsFieldsAmounts);\r\n        const palette = this.getColorSet(styleConfig.baseColors, _modelHelper__WEBPACK_IMPORTED_MODULE_1__.ModelHelper.getSum(chartsFieldsAmounts));\r\n        return {\r\n            elementColors: this.getChartColors(palette, chartsFieldsAmounts[chartIndex], startIndex, chartType),\r\n            opacity: this.getChartOpacity(chartsAmount, chartType, chartsFieldsAmounts[chartIndex], isSegmented)\r\n        };\r\n    }\r\n    static getChartStyle(elementsAmount, styleConfig) {\r\n        return {\r\n            elementColors: this.getColorSet(styleConfig.baseColors, elementsAmount),\r\n            opacity: 1\r\n        };\r\n    }\r\n    static getChartColors(palette, elementsAmount, startIndex, chartType) {\r\n        const selectedColors = palette.slice(startIndex, startIndex + elementsAmount);\r\n        if (chartType !== 'line')\r\n            return selectedColors;\r\n        for (let i = 0; i < selectedColors.length; i++) {\r\n            selectedColors[i] = chroma_js__WEBPACK_IMPORTED_MODULE_0__.mix(selectedColors[i], 'white', 0.2).saturate(3).hex();\r\n        }\r\n        return selectedColors;\r\n    }\r\n    static getChartOpacity(chartsLength, chartType, chartsValueFieldAmount, isSegmented) {\r\n        if (chartType === 'area' && (chartsLength > 1 || chartsValueFieldAmount > 1) && !isSegmented)\r\n            return 0.5; // combined area with other charts has 0.5 opacity\r\n        return 1;\r\n    }\r\n    static getColorSet(baseColors, elementsAmount) {\r\n        return chroma_js__WEBPACK_IMPORTED_MODULE_0__.scale(baseColors).mode('rgb').colors(elementsAmount <= 1 ? 2 : elementsAmount);\r\n        // if (elementsAmount < this.safeColorsAmount)\r\n        //     return chroma.scale(baseColors).mode('rgb').colors(elementsAmount <= 1 ? 2 : elementsAmount);\r\n        // const basePalette = chroma.scale(baseColors).mode('rgb').colors(this.safeColorsAmount);\r\n        // const finalPalette = [...basePalette];\r\n        // for (let i = this.safeColorsAmount; i < elementsAmount; i++) {\r\n        //     finalPalette.push(this.resetColor(i, basePalette[i % this.safeColorsAmount]));\r\n        // }\r\n        // return finalPalette;\r\n    }\r\n    static resetColor(index, baseColor) {\r\n        let color = chroma_js__WEBPACK_IMPORTED_MODULE_0__(baseColor)\r\n            .luminance(0.5)\r\n            .saturate(1.5 + Math.floor(index / this.safeColorsAmount) * 0.5);\r\n        color = chroma_js__WEBPACK_IMPORTED_MODULE_0__(color)\r\n            .set('hsv.h', chroma_js__WEBPACK_IMPORTED_MODULE_0__(color).get('hsv.h') + Math.floor(index / this.safeColorsAmount) * 4);\r\n        return color.hex();\r\n    }\r\n    static getStartIndex(chartIndex, chartsFieldsAmounts) {\r\n        let startIndex = 0;\r\n        for (let i = 0; i < chartIndex; i++) {\r\n            startIndex += chartsFieldsAmounts[i];\r\n        }\r\n        return startIndex;\r\n    }\r\n}\r\nChartStyleModel.safeColorsAmount = 8;\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/model/chartStyleModel.ts?");

/***/ }),

/***/ "./src/model/dataManagerModel.ts":
/*!***************************************!*\
  !*** ./src/model/dataManagerModel.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DataManagerModel\": () => /* binding */ DataManagerModel\n/* harmony export */ });\n/* harmony import */ var _featuresModel_axisModel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./featuresModel/axisModel */ \"./src/model/featuresModel/axisModel.ts\");\n/* harmony import */ var _featuresModel_legendModel_legendCanvasModel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./featuresModel/legendModel/legendCanvasModel */ \"./src/model/featuresModel/legendModel/legendCanvasModel.ts\");\n/* harmony import */ var _featuresModel_legendModel_legendModel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./featuresModel/legendModel/legendModel */ \"./src/model/featuresModel/legendModel/legendModel.ts\");\n/* harmony import */ var _modelHelper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modelHelper */ \"./src/model/modelHelper.ts\");\n\r\n\r\n\r\n\r\nclass DataManagerModel {\r\n    static getPreparedData(data, allowableKeys, config) {\r\n        const scopedData = this.getScopedData(data, allowableKeys, config);\r\n        this.setDataType(scopedData, config);\r\n        return scopedData;\r\n    }\r\n    static getDataScope(config, margin, data, designerConfig, legendBlock) {\r\n        if (config.options.type === '2d' || config.options.type === 'interval') {\r\n            return this.getDataScopeFor2D(config.options, config.canvas.size, margin, data, designerConfig);\r\n        }\r\n        else if (config.options.type === 'polar') {\r\n            return this.getDataScopeForPolar(config.options, config.canvas.size, margin, data, legendBlock);\r\n        }\r\n    }\r\n    static getDataValuesByKeyField(data, dataSourceName, keyFieldName) {\r\n        return data[dataSourceName].map(dataRow => dataRow[keyFieldName]);\r\n    }\r\n    static getDataScopeFor2D(configOptions, blockSize, margin, data, designerConfig) {\r\n        // Выбор чартов, которые используют столбики\r\n        const chartsWithBarElement = configOptions.charts\r\n            .filter((chart) => chart.type === 'bar' || chart.type === 'gantt');\r\n        if (chartsWithBarElement.length !== 0) {\r\n            const axisLength = _featuresModel_axisModel__WEBPACK_IMPORTED_MODULE_0__.AxisModel.getAxisLength(configOptions.orientation, margin, blockSize);\r\n            const uniqueKeys = _modelHelper__WEBPACK_IMPORTED_MODULE_3__.ModelHelper.getUniqueValues(data[configOptions.data.dataSource].map(d => d[configOptions.data.keyField.name]));\r\n            const dataLength = uniqueKeys.length;\r\n            const limit = this.getDataLimitByBarSize(this.getElementsInGroupAmount(configOptions, chartsWithBarElement.length), dataLength, axisLength, designerConfig.canvas.chartOptions.bar);\r\n            const allowableKeys = uniqueKeys.slice(0, limit);\r\n            return {\r\n                allowableKeys,\r\n                hidedRecordsAmount: dataLength - allowableKeys.length\r\n            };\r\n        }\r\n        return {\r\n            allowableKeys: this.getDataValuesByKeyField(data, configOptions.data.dataSource, configOptions.data.keyField.name),\r\n            hidedRecordsAmount: 0\r\n        };\r\n    }\r\n    static getDataScopeForPolar(configOptions, blockSize, margin, data, legendBlock) {\r\n        const dataset = data[configOptions.data.dataSource];\r\n        const keyFieldName = configOptions.data.keyField.name;\r\n        const keys = dataset.map(dataRow => dataRow[keyFieldName]);\r\n        if (!configOptions.legend.show) {\r\n            return {\r\n                allowableKeys: keys,\r\n                hidedRecordsAmount: 0\r\n            };\r\n        }\r\n        let position;\r\n        if (blockSize.width - margin.left - margin.right >= _featuresModel_legendModel_legendModel__WEBPACK_IMPORTED_MODULE_2__.MIN_DONUT_BLOCK_SIZE)\r\n            position = 'right';\r\n        else\r\n            position = 'bottom';\r\n        if (position === 'right') {\r\n            if (blockSize.width - margin.left - margin.right < _featuresModel_legendModel_legendModel__WEBPACK_IMPORTED_MODULE_2__.MIN_DONUT_BLOCK_SIZE)\r\n                position = 'bottom';\r\n        }\r\n        let maxItemsNumber;\r\n        if (position === 'right') {\r\n            maxItemsNumber = _featuresModel_legendModel_legendCanvasModel__WEBPACK_IMPORTED_MODULE_1__.LegendCanvasModel.findElementsAmountByLegendSize(keys, position, 200, blockSize.height - margin.top - margin.bottom);\r\n        }\r\n        else {\r\n            let marginBottom = margin.bottom - (legendBlock.bottom.size === 0 ? legendBlock.bottom.size : legendBlock.bottom.size - legendBlock.bottom.margin.bottom);\r\n            maxItemsNumber = _featuresModel_legendModel_legendCanvasModel__WEBPACK_IMPORTED_MODULE_1__.LegendCanvasModel.findElementsAmountByLegendSize(keys, position, blockSize.width - margin.left - margin.right, blockSize.height - margin.top - marginBottom - legendBlock.bottom.margin.bottom - _featuresModel_legendModel_legendModel__WEBPACK_IMPORTED_MODULE_2__.MIN_DONUT_BLOCK_SIZE);\r\n        }\r\n        return {\r\n            allowableKeys: keys.slice(0, maxItemsNumber),\r\n            hidedRecordsAmount: keys.length - maxItemsNumber\r\n        };\r\n    }\r\n    /**\r\n     * Выводит количество элементов (преимущественно баров) в одной группе. Группа - один ключ\r\n     * @param configOptions\r\n     * @param chartsLength\r\n     */\r\n    static getElementsInGroupAmount(configOptions, chartsLength) {\r\n        if (configOptions.type === '2d')\r\n            return this.getBarChartsInGroupAmount(configOptions.charts);\r\n        return chartsLength;\r\n    }\r\n    static getBarChartsInGroupAmount(charts) {\r\n        let barsAmount = 0;\r\n        charts.forEach(chart => {\r\n            if (chart.type === 'bar' && chart.isSegmented)\r\n                barsAmount += 1; // в сегментированном баре все valueFields находятся внутри одного бара, поэтому бар всегда один.\r\n            else if (chart.type === 'bar')\r\n                barsAmount += chart.data.valueFields.length;\r\n        });\r\n        return barsAmount;\r\n    }\r\n    static getScopedData(data, allowableKeys, config) {\r\n        const newData = {};\r\n        newData[config.options.data.dataSource] = this.getScopedChartData(data[config.options.data.dataSource], allowableKeys, config.options.data.keyField.name);\r\n        return newData;\r\n    }\r\n    static getScopedChartData(data, allowableKeys, keyFieldName) {\r\n        return data.filter(d => allowableKeys.findIndex(key => key === d[keyFieldName]) !== -1);\r\n    }\r\n    static setDataType(data, config) {\r\n        if (config.options.type === 'polar' || config.options.type === '2d') {\r\n            // Форматиривание для оси ключей пока не совсем верно установлено\r\n            // if(config.options.data.keyField.format === 'date') {\r\n            //     data[config.options.data.dataSource] = this.getTypedData(data[config.options.data.dataSource], config.options.data.keyField);\r\n            // }\r\n        }\r\n        else if (config.options.type === 'interval') {\r\n            config.options.charts.forEach((chart) => {\r\n                if (chart.data.valueField1.format === 'date') {\r\n                    data[config.options.data.dataSource] = this.getTypedData(data[config.options.data.dataSource], chart.data.valueField1);\r\n                }\r\n                if (chart.data.valueField2.format === 'date') {\r\n                    data[config.options.data.dataSource] = this.getTypedData(data[config.options.data.dataSource], chart.data.valueField2);\r\n                }\r\n            });\r\n        }\r\n    }\r\n    static getTypedData(data, field) {\r\n        if (field.format === 'date')\r\n            data.forEach(d => {\r\n                d[field.name] = new Date(d[field.name]);\r\n            });\r\n        return data;\r\n    }\r\n    static getDataLimitByBarSize(elementsInGroupAmount, dataLength, axisLength, barOptions) {\r\n        let sumSize = dataLength * (elementsInGroupAmount * barOptions.minBarWidth + (elementsInGroupAmount - 1) * barOptions.barDistance + barOptions.groupMinDistance);\r\n        while (dataLength !== 0 && axisLength < sumSize) {\r\n            dataLength--;\r\n            // find whole space for bars in group + distance between bars + group distance\r\n            sumSize = dataLength * (elementsInGroupAmount * barOptions.minBarWidth + (elementsInGroupAmount - 1)\r\n                * barOptions.barDistance + barOptions.groupMinDistance);\r\n        }\r\n        return dataLength;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/model/dataManagerModel.ts?");

/***/ }),

/***/ "./src/model/featuresModel/axisModel.ts":
/*!**********************************************!*\
  !*** ./src/model/featuresModel/axisModel.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AxisModel\": () => /* binding */ AxisModel\n/* harmony export */ });\n/* harmony import */ var _modelHelper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../modelHelper */ \"./src/model/modelHelper.ts\");\n/* harmony import */ var _modelBuilder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../modelBuilder */ \"./src/model/modelBuilder.ts\");\n/* harmony import */ var _dataManagerModel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dataManagerModel */ \"./src/model/dataManagerModel.ts\");\n/* harmony import */ var _notations_twoDimensionalModel__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../notations/twoDimensionalModel */ \"./src/model/notations/twoDimensionalModel.ts\");\n\r\n\r\n\r\n\r\nclass AxisModel {\r\n    static getKeyAxis(charts, data, dataOptions, orient, axisConfig, labelConfig, margin, blockSize) {\r\n        return {\r\n            type: 'key',\r\n            orient: AxisModel.getAxisOrient(_modelBuilder__WEBPACK_IMPORTED_MODULE_1__.AxisType.Key, orient, axisConfig.position),\r\n            translate: {\r\n                translateX: AxisModel.getAxisTranslateX(_modelBuilder__WEBPACK_IMPORTED_MODULE_1__.AxisType.Key, orient, axisConfig.position, margin, blockSize.width),\r\n                translateY: AxisModel.getAxisTranslateY(_modelBuilder__WEBPACK_IMPORTED_MODULE_1__.AxisType.Key, orient, axisConfig.position, margin, blockSize.height)\r\n            },\r\n            cssClass: 'key-axis',\r\n            ticks: axisConfig.ticks,\r\n            labels: {\r\n                maxSize: AxisModel.getLabelSize(labelConfig.maxSize.main, data[dataOptions.dataSource].map(d => d[dataOptions.keyField.name])).width,\r\n                positition: AxisModel.getKeyAxisLabelPosition(margin, blockSize, _dataManagerModel__WEBPACK_IMPORTED_MODULE_2__.DataManagerModel.getDataValuesByKeyField(data, dataOptions.dataSource, dataOptions.keyField.name).length),\r\n                visible: !_notations_twoDimensionalModel__WEBPACK_IMPORTED_MODULE_3__.TwoDimensionalModel.getChartsEmbeddedLabelsFlag(charts, orient)\r\n            },\r\n            visibility: axisConfig.visibility\r\n        };\r\n    }\r\n    static getValueAxis(orient, axisConfig, labelConfig, margin, blockSize) {\r\n        return {\r\n            type: 'value',\r\n            orient: AxisModel.getAxisOrient(_modelBuilder__WEBPACK_IMPORTED_MODULE_1__.AxisType.Value, orient, axisConfig.position),\r\n            translate: {\r\n                translateX: AxisModel.getAxisTranslateX(_modelBuilder__WEBPACK_IMPORTED_MODULE_1__.AxisType.Value, orient, axisConfig.position, margin, blockSize.width),\r\n                translateY: AxisModel.getAxisTranslateY(_modelBuilder__WEBPACK_IMPORTED_MODULE_1__.AxisType.Value, orient, axisConfig.position, margin, blockSize.height)\r\n            },\r\n            cssClass: 'value-axis',\r\n            ticks: axisConfig.ticks,\r\n            labels: {\r\n                maxSize: labelConfig.maxSize.main,\r\n                positition: 'straight',\r\n                visible: true\r\n            },\r\n            visibility: axisConfig.visibility\r\n        };\r\n    }\r\n    static getAxisLength(chartOrientation, margin, blockSize) {\r\n        if (chartOrientation === 'horizontal') {\r\n            return blockSize.height - margin.top - margin.bottom;\r\n        }\r\n        else {\r\n            return blockSize.width - margin.left - margin.right;\r\n        }\r\n    }\r\n    static getAxisOrient(axisType, chartOrientation, axisPosition) {\r\n        if (chartOrientation === 'vertical') {\r\n            if (axisPosition === 'start')\r\n                return axisType === _modelBuilder__WEBPACK_IMPORTED_MODULE_1__.AxisType.Key ? 'top' : 'left';\r\n            return axisType === _modelBuilder__WEBPACK_IMPORTED_MODULE_1__.AxisType.Key ? 'bottom' : 'right';\r\n        }\r\n        if (axisPosition === 'start')\r\n            return axisType === _modelBuilder__WEBPACK_IMPORTED_MODULE_1__.AxisType.Key ? 'left' : 'top';\r\n        return axisType === _modelBuilder__WEBPACK_IMPORTED_MODULE_1__.AxisType.Key ? 'right' : 'bottom';\r\n    }\r\n    static getAxisTranslateX(axisType, chartOrientation, axisPosition, margin, blockWidth) {\r\n        const orient = AxisModel.getAxisOrient(axisType, chartOrientation, axisPosition);\r\n        if (orient === 'top' || orient === 'left')\r\n            return margin.left;\r\n        else if (orient === 'bottom')\r\n            return margin.left;\r\n        return blockWidth - margin.right;\r\n    }\r\n    static getAxisTranslateY(axisType, chartOrientation, axisPosition, margin, blockHeight) {\r\n        const orient = AxisModel.getAxisOrient(axisType, chartOrientation, axisPosition);\r\n        if (orient === 'top' || orient === 'left')\r\n            return margin.top;\r\n        else if (orient === 'bottom')\r\n            return blockHeight - margin.bottom;\r\n        return margin.top;\r\n    }\r\n    static getKeyAxisLabelPosition(margin, blockSize, scopedDataLength) {\r\n        const minBandSize = 50;\r\n        if ((blockSize.width - margin.left - margin.right) / scopedDataLength < minBandSize)\r\n            return 'rotated';\r\n        return 'straight';\r\n    }\r\n    static getLabelSize(labelMaxWidth, labelTexts) {\r\n        const labelSize = {\r\n            width: 0,\r\n            height: 0\r\n        };\r\n        const textBlock = document.createElement('span');\r\n        textBlock.style.opacity = '0';\r\n        textBlock.style.position = 'absolute';\r\n        textBlock.style.whiteSpace = 'nowrap';\r\n        textBlock.classList.add(_modelBuilder__WEBPACK_IMPORTED_MODULE_1__.CLASSES.dataLabel);\r\n        let maxLabel = '';\r\n        let biggestScore = 0;\r\n        let maxWidth = 0;\r\n        labelTexts.forEach((text) => {\r\n            if (_modelHelper__WEBPACK_IMPORTED_MODULE_0__.ModelHelper.getStringScore(text) > biggestScore) {\r\n                maxLabel = text;\r\n                biggestScore = _modelHelper__WEBPACK_IMPORTED_MODULE_0__.ModelHelper.getStringScore(text);\r\n            }\r\n        });\r\n        textBlock.textContent = maxLabel === '0000' ? maxLabel : maxLabel + 'D';\r\n        document.body.append(textBlock);\r\n        maxWidth = Math.ceil(textBlock.getBoundingClientRect().width);\r\n        labelSize.height = textBlock.getBoundingClientRect().height;\r\n        labelSize.width = maxWidth > labelMaxWidth ? labelMaxWidth : maxWidth;\r\n        textBlock.remove();\r\n        return labelSize;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/model/featuresModel/axisModel.ts?");

/***/ }),

/***/ "./src/model/featuresModel/legendModel/legendCanvasModel.ts":
/*!******************************************************************!*\
  !*** ./src/model/featuresModel/legendModel/legendCanvasModel.ts ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LegendCanvasModel\": () => /* binding */ LegendCanvasModel\n/* harmony export */ });\n/* harmony import */ var _modelBuilder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../modelBuilder */ \"./src/model/modelBuilder.ts\");\n/* harmony import */ var _legendModel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./legendModel */ \"./src/model/featuresModel/legendModel/legendModel.ts\");\n\r\n\r\nclass LegendCanvasModel {\r\n    static getLegendHeight(texts, blockWidth, marginLeft, marginRight, itemsPosition, legendPosition) {\r\n        const legendWrapper = document.createElement('div');\r\n        legendWrapper.style.opacity = '0';\r\n        legendWrapper.style.display = 'flex';\r\n        if (itemsPosition === 'column')\r\n            legendWrapper.style.flexDirection = 'column';\r\n        legendWrapper.style.position = 'absolute';\r\n        legendWrapper.style.width = blockWidth - marginLeft - marginRight + 'px';\r\n        texts.forEach(text => {\r\n            const itemWrapper = document.createElement('div');\r\n            const colorBlock = document.createElement('span');\r\n            const textBlock = document.createElement('span');\r\n            itemWrapper.classList.add(_legendModel__WEBPACK_IMPORTED_MODULE_1__.LegendModel.getLegendItemClass(itemsPosition));\r\n            if (itemsPosition === 'column') {\r\n                itemWrapper.style.whiteSpace = 'nowrap';\r\n                itemWrapper.classList.add(_legendModel__WEBPACK_IMPORTED_MODULE_1__.LegendModel.getMarginClass(legendPosition));\r\n            }\r\n            colorBlock.classList.add(_modelBuilder__WEBPACK_IMPORTED_MODULE_0__.CLASSES.legendColor);\r\n            textBlock.classList.add(_modelBuilder__WEBPACK_IMPORTED_MODULE_0__.CLASSES.legendLabel);\r\n            textBlock.textContent = text;\r\n            itemWrapper.append(colorBlock, textBlock);\r\n            legendWrapper.append(itemWrapper);\r\n        });\r\n        document.body.append(legendWrapper);\r\n        const height = legendWrapper.offsetHeight;\r\n        legendWrapper.remove();\r\n        return height;\r\n    }\r\n    static getLegendItemWidth(text) {\r\n        const itemWrapper = document.createElement('div');\r\n        itemWrapper.style.opacity = '0';\r\n        const colorBlock = document.createElement('span');\r\n        const textBlock = document.createElement('span');\r\n        itemWrapper.style.display = 'inline-block';\r\n        itemWrapper.classList.add(_modelBuilder__WEBPACK_IMPORTED_MODULE_0__.CLASSES.legendItem);\r\n        colorBlock.classList.add(_modelBuilder__WEBPACK_IMPORTED_MODULE_0__.CLASSES.legendColor);\r\n        textBlock.classList.add(_modelBuilder__WEBPACK_IMPORTED_MODULE_0__.CLASSES.legendLabel);\r\n        textBlock.textContent = text;\r\n        itemWrapper.append(colorBlock, textBlock);\r\n        document.body.append(itemWrapper);\r\n        const sumWidth = itemWrapper.getBoundingClientRect().width\r\n            + parseFloat(window.getComputedStyle(itemWrapper, null).getPropertyValue('margin-left'))\r\n            + parseFloat(window.getComputedStyle(itemWrapper, null).getPropertyValue('margin-right'));\r\n        itemWrapper.remove();\r\n        return sumWidth;\r\n    }\r\n    static findElementsAmountByLegendSize(texts, position, legendBlockWidth, legendBlockHeight) {\r\n        const legendWrapper = document.createElement('div');\r\n        legendWrapper.style.opacity = '0';\r\n        legendWrapper.style.display = 'flex';\r\n        legendWrapper.style.flexDirection = 'column';\r\n        legendWrapper.style.position = 'absolute';\r\n        legendWrapper.style.width = legendBlockWidth + 'px';\r\n        document.body.append(legendWrapper);\r\n        let amount = 0;\r\n        for (let i = 0; i < texts.length; i++) {\r\n            const itemWrapper = document.createElement('div');\r\n            const colorBlock = document.createElement('span');\r\n            const textBlock = document.createElement('span');\r\n            itemWrapper.classList.add('legend-item-row');\r\n            if (position === 'bottom')\r\n                textBlock.classList.add('legend-label-nowrap', 'mt-10');\r\n            else\r\n                itemWrapper.classList.add('mt-15');\r\n            colorBlock.classList.add(_modelBuilder__WEBPACK_IMPORTED_MODULE_0__.CLASSES.legendColor);\r\n            textBlock.classList.add(_modelBuilder__WEBPACK_IMPORTED_MODULE_0__.CLASSES.legendLabel);\r\n            textBlock.textContent = texts[i];\r\n            itemWrapper.append(colorBlock, textBlock);\r\n            legendWrapper.append(itemWrapper);\r\n            if (legendWrapper.offsetHeight > legendBlockHeight) {\r\n                itemWrapper.remove();\r\n                if (legendBlockHeight - legendWrapper.offsetHeight >= 15 && position !== 'bottom')\r\n                    amount = i;\r\n                else\r\n                    amount = i - 1;\r\n                break;\r\n            }\r\n            amount++;\r\n        }\r\n        legendWrapper.remove();\r\n        return amount < 0 ? 0 : amount;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/model/featuresModel/legendModel/legendCanvasModel.ts?");

/***/ }),

/***/ "./src/model/featuresModel/legendModel/legendModel.ts":
/*!************************************************************!*\
  !*** ./src/model/featuresModel/legendModel/legendModel.ts ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MIN_DONUT_BLOCK_SIZE\": () => /* binding */ MIN_DONUT_BLOCK_SIZE,\n/* harmony export */   \"LegendModel\": () => /* binding */ LegendModel\n/* harmony export */ });\n/* harmony import */ var _modelHelper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../modelHelper */ \"./src/model/modelHelper.ts\");\n/* harmony import */ var _titleModel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../titleModel */ \"./src/model/featuresModel/titleModel.ts\");\n/* harmony import */ var _legendCanvasModel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./legendCanvasModel */ \"./src/model/featuresModel/legendModel/legendCanvasModel.ts\");\n\r\n\r\n\r\n/** If donut block has width less than this const, legend change postion from \"right\" to \"bottom\" */\r\nconst MIN_DONUT_BLOCK_SIZE = 260;\r\nclass LegendModel {\r\n    static getLegendSize(chartNotation, position, texts, legendMaxWidth, blockSize, legendBlockModel) {\r\n        if (position === 'left' || position === 'right')\r\n            return this.getLegendWidth(texts, legendMaxWidth);\r\n        if (chartNotation === '2d' || chartNotation === 'interval') {\r\n            return _legendCanvasModel__WEBPACK_IMPORTED_MODULE_2__.LegendCanvasModel.getLegendHeight(texts, blockSize.width, legendBlockModel[position].margin.left, legendBlockModel[position].margin.right, 'row', position);\r\n        }\r\n        else if (chartNotation === 'polar') {\r\n            const size = _legendCanvasModel__WEBPACK_IMPORTED_MODULE_2__.LegendCanvasModel.getLegendHeight(texts, blockSize.width, legendBlockModel[position].margin.left, legendBlockModel[position].margin.right, 'column', position);\r\n            return size;\r\n        }\r\n    }\r\n    static getBaseLegendBlockModel() {\r\n        const mt = 20, mb = 20, ml = 20, mr = 20;\r\n        const titleModelTemplate = _titleModel__WEBPACK_IMPORTED_MODULE_1__.TitleModel.getTitleModel();\r\n        return {\r\n            left: {\r\n                size: 0,\r\n                margin: { top: mt, bottom: mb, left: ml, right: 0 },\r\n                pad: 0\r\n            },\r\n            bottom: {\r\n                size: 0,\r\n                margin: { top: 0, bottom: 20, left: 20, right: 20 },\r\n                pad: 0\r\n            },\r\n            right: {\r\n                size: 0,\r\n                margin: { top: titleModelTemplate.pad + titleModelTemplate.margin.top + titleModelTemplate.size, bottom: mb, left: 0, right: mr },\r\n                pad: 0\r\n            },\r\n            top: {\r\n                size: 0,\r\n                margin: { top: 20, bottom: 0, left: 20, right: 20 },\r\n                pad: titleModelTemplate.pad + titleModelTemplate.margin.top + titleModelTemplate.size\r\n            }\r\n        };\r\n    }\r\n    static getLegendModel(chartNotation, legendShow, blockSize, margin) {\r\n        let legendPosition = 'off';\r\n        if (legendShow) {\r\n            if (chartNotation === '2d' || chartNotation === 'interval')\r\n                legendPosition = 'top';\r\n            else if (chartNotation === 'polar') {\r\n                legendPosition = blockSize.width - margin.left - margin.right < MIN_DONUT_BLOCK_SIZE ? 'bottom' : 'right';\r\n            }\r\n        }\r\n        return {\r\n            position: legendPosition\r\n        };\r\n    }\r\n    static getLegendItemClass(itemsPosition) {\r\n        return itemsPosition === 'column' ? 'legend-item-row' : 'legend-item-inline';\r\n    }\r\n    static getMarginClass(legendPosition) {\r\n        return legendPosition === 'right' ? 'mt-15' : 'mt-10';\r\n    }\r\n    static getLegendWidth(texts, legendMaxWidth) {\r\n        let longestText = '';\r\n        let biggestScore = 0;\r\n        texts.forEach(text => {\r\n            if (_modelHelper__WEBPACK_IMPORTED_MODULE_0__.ModelHelper.getStringScore(text) > biggestScore) {\r\n                longestText = text;\r\n                biggestScore = _modelHelper__WEBPACK_IMPORTED_MODULE_0__.ModelHelper.getStringScore(text);\r\n            }\r\n        });\r\n        const maxWidth = _legendCanvasModel__WEBPACK_IMPORTED_MODULE_2__.LegendCanvasModel.getLegendItemWidth(longestText + '?'); // One letter reserve\r\n        return maxWidth > legendMaxWidth ? legendMaxWidth : maxWidth;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/model/featuresModel/legendModel/legendModel.ts?");

/***/ }),

/***/ "./src/model/featuresModel/otherComponents.ts":
/*!****************************************************!*\
  !*** ./src/model/featuresModel/otherComponents.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"OtherComponentsModel\": () => /* binding */ OtherComponentsModel\n/* harmony export */ });\n/* harmony import */ var _legendModel_legendModel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./legendModel/legendModel */ \"./src/model/featuresModel/legendModel/legendModel.ts\");\n/* harmony import */ var _titleModel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./titleModel */ \"./src/model/featuresModel/titleModel.ts\");\n\r\n\r\nclass OtherComponentsModel {\r\n    static getOtherComponentsModel(elementsOptions) {\r\n        return {\r\n            legendBlock: _legendModel_legendModel__WEBPACK_IMPORTED_MODULE_0__.LegendModel.getBaseLegendBlockModel(),\r\n            titleBlock: _titleModel__WEBPACK_IMPORTED_MODULE_1__.TitleModel.getTitleModel(),\r\n            tooltipBlock: elementsOptions.tooltip\r\n        };\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/model/featuresModel/otherComponents.ts?");

/***/ }),

/***/ "./src/model/featuresModel/scaleModel.ts":
/*!***********************************************!*\
  !*** ./src/model/featuresModel/scaleModel.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ScaleType\": () => /* binding */ ScaleType,\n/* harmony export */   \"ScaleModel\": () => /* binding */ ScaleModel\n/* harmony export */ });\n/* harmony import */ var _modelHelper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../modelHelper */ \"./src/model/modelHelper.ts\");\n\r\nvar ScaleType;\r\n(function (ScaleType) {\r\n    ScaleType[ScaleType[\"Key\"] = 0] = \"Key\";\r\n    ScaleType[ScaleType[\"Value\"] = 1] = \"Value\";\r\n})(ScaleType || (ScaleType = {}));\r\nclass ScaleModel {\r\n    static getScaleKey(allowableKeys, orient, margin, blockSize, charts, barCharts) {\r\n        return {\r\n            domain: allowableKeys,\r\n            range: {\r\n                start: 0,\r\n                end: ScaleModel.getRangePeek(ScaleType.Key, orient, margin, blockSize)\r\n            },\r\n            type: ScaleModel.getScaleKeyType(charts),\r\n            elementsAmount: this.getElementsAmount(barCharts)\r\n        };\r\n    }\r\n    static getScaleLinear(options, data, margin, blockSize) {\r\n        return {\r\n            domain: ScaleModel.getLinearDomain(options.axis.value.domain, data, options),\r\n            range: {\r\n                start: 0,\r\n                end: ScaleModel.getRangePeek(ScaleType.Value, options.orientation, margin, blockSize)\r\n            },\r\n            type: ScaleModel.getScaleValueType(options.charts)\r\n        };\r\n    }\r\n    static getRangePeek(scaleType, chartOrientation, margin, blockSize) {\r\n        if (chartOrientation === 'vertical')\r\n            return scaleType === ScaleType.Key\r\n                ? blockSize.width - margin.left - margin.right\r\n                : blockSize.height - margin.top - margin.bottom;\r\n        return scaleType === ScaleType.Key\r\n            ? blockSize.height - margin.top - margin.bottom\r\n            : blockSize.width - margin.left - margin.right;\r\n    }\r\n    static getDateValueDomain(data, charts, keyAxisPosition, dataSource) {\r\n        const minMax = _modelHelper__WEBPACK_IMPORTED_MODULE_0__.ModelHelper.getMinAndMaxOfIntervalData(data, dataSource, charts);\r\n        let domainPeekMin = minMax[0];\r\n        let domainPeekMax = minMax[1];\r\n        if (keyAxisPosition === 'start')\r\n            return [domainPeekMin, domainPeekMax];\r\n        return [domainPeekMax, domainPeekMin];\r\n    }\r\n    static getLinearDomain(configDomain, data, configOptions) {\r\n        let domainPeekMin;\r\n        let domainPeekMax;\r\n        if (configDomain.start === -1)\r\n            domainPeekMin = 0;\r\n        else\r\n            domainPeekMin = configDomain.start;\r\n        if (configDomain.end === -1)\r\n            domainPeekMax = this.getScaleMaxValue(configOptions.charts, configOptions.data.dataSource, data);\r\n        else\r\n            domainPeekMax = configDomain.end;\r\n        if (configOptions.axis.key.position === 'start')\r\n            return [domainPeekMin, domainPeekMax];\r\n        return [domainPeekMax, domainPeekMin];\r\n    }\r\n    static getScaleKeyType(charts) {\r\n        if (charts.findIndex((chart) => chart.type === 'bar' || chart.type === 'gantt') === -1)\r\n            return 'point';\r\n        return 'band';\r\n    }\r\n    static getScaleValueType(charts) {\r\n        if (charts.findIndex((chart) => chart.type === 'gantt') !== -1)\r\n            return 'datetime';\r\n        return 'linear';\r\n    }\r\n    static getElementsAmount(barCharts) {\r\n        if (barCharts.length === 0)\r\n            return 1;\r\n        let barsAmount = 0;\r\n        barCharts.forEach(chart => {\r\n            if (chart.isSegmented)\r\n                barsAmount += 1; // Если бар сегментированный, то все valueFields являются частями одного бара\r\n            else\r\n                barsAmount += chart.data.valueFields.length;\r\n        });\r\n        return barsAmount;\r\n    }\r\n    static getScaleMaxValue(charts, dataSource, data) {\r\n        let max = 0;\r\n        charts.forEach(chart => {\r\n            data[dataSource].forEach(dataRow => {\r\n                let sumInRow = 0;\r\n                chart.data.valueFields.forEach(field => {\r\n                    if (chart.isSegmented)\r\n                        sumInRow += dataRow[field.name];\r\n                    else if (dataRow[field.name] > sumInRow)\r\n                        sumInRow = dataRow[field.name];\r\n                });\r\n                if (max < sumInRow)\r\n                    max = sumInRow;\r\n            });\r\n        });\r\n        return max;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/model/featuresModel/scaleModel.ts?");

/***/ }),

/***/ "./src/model/featuresModel/titleModel.ts":
/*!***********************************************!*\
  !*** ./src/model/featuresModel/titleModel.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TitleModel\": () => /* binding */ TitleModel\n/* harmony export */ });\nclass TitleModel {\r\n    static getTitleModel() {\r\n        return {\r\n            margin: {\r\n                bottom: 0,\r\n                left: 20,\r\n                right: 20,\r\n                top: 20\r\n            },\r\n            size: 20,\r\n            pad: 0\r\n        };\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/model/featuresModel/titleModel.ts?");

/***/ }),

/***/ "./src/model/marginModel.ts":
/*!**********************************!*\
  !*** ./src/model/marginModel.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AXIS_HORIZONTAL_LABEL_PADDING\": () => /* binding */ AXIS_HORIZONTAL_LABEL_PADDING,\n/* harmony export */   \"AXIS_VERTICAL_LABEL_PADDING\": () => /* binding */ AXIS_VERTICAL_LABEL_PADDING,\n/* harmony export */   \"MarginModel\": () => /* binding */ MarginModel\n/* harmony export */ });\n/* harmony import */ var _featuresModel_axisModel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./featuresModel/axisModel */ \"./src/model/featuresModel/axisModel.ts\");\n/* harmony import */ var _dataManagerModel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dataManagerModel */ \"./src/model/dataManagerModel.ts\");\n/* harmony import */ var _featuresModel_legendModel_legendModel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./featuresModel/legendModel/legendModel */ \"./src/model/featuresModel/legendModel/legendModel.ts\");\n/* harmony import */ var _modelBuilder__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modelBuilder */ \"./src/model/modelBuilder.ts\");\n/* harmony import */ var _notations_twoDimensionalModel__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./notations/twoDimensionalModel */ \"./src/model/notations/twoDimensionalModel.ts\");\n\r\n\r\n\r\n\r\n\r\nconst AXIS_HORIZONTAL_LABEL_PADDING = 15;\r\nconst AXIS_VERTICAL_LABEL_PADDING = 10;\r\nclass MarginModel {\r\n    static getMargin(designerConfig, config, otherComponents, data) {\r\n        const margin = Object.assign({}, designerConfig.canvas.chartBlockMargin);\r\n        this.recalcMarginWithLegend(margin, config, designerConfig.canvas.legendBlock.maxWidth, otherComponents.legendBlock, data);\r\n        this.recalcMarginByTitle(margin, otherComponents.titleBlock);\r\n        if (config.options.type === '2d' || config.options.type === 'interval') {\r\n            const labelSize = this.getHorizontalMarginByAxisLabels(designerConfig.canvas.axisLabel.maxSize.main, config.options.axis, data, config.options);\r\n            this.recalcVerticalMarginByAxisLabelHeight(labelSize, margin, config.options.orientation, config.options.axis);\r\n            // Если встроенный лейбл показывает ключи, то лейблы оси ключей не показываются\r\n            // При этом все графики должны иметь: embeddedLabels = 'key'\r\n            // И все графики должны быть типа bar. \r\n            const showingFlag = config.options.type === '2d'\r\n                ? !_notations_twoDimensionalModel__WEBPACK_IMPORTED_MODULE_4__.TwoDimensionalModel.getChartsEmbeddedLabelsFlag(config.options.charts, config.options.orientation)\r\n                : true;\r\n            this.recalcHorizontalMarginByAxisLabelWidth(labelSize, margin, config.options.orientation, config.options.axis, showingFlag);\r\n        }\r\n        return margin;\r\n    }\r\n    static recalcPolarMarginWithScopedData(margin, blockSize, designerConfig, config, legendBlockModel, dataScope, options) {\r\n        let position = _featuresModel_legendModel_legendModel__WEBPACK_IMPORTED_MODULE_2__.LegendModel.getLegendModel(config.options.type, config.options.legend.show, config.canvas.size, margin).position;\r\n        if (position !== 'off') {\r\n            if (position === 'right' && blockSize.width - margin.left - margin.right < _featuresModel_legendModel_legendModel__WEBPACK_IMPORTED_MODULE_2__.MIN_DONUT_BLOCK_SIZE)\r\n                position = 'bottom';\r\n            this.clearMarginByLegendBlockPosition(margin, legendBlockModel);\r\n            let allowableKeys = [...dataScope.allowableKeys];\r\n            if (dataScope.hidedRecordsAmount !== 0 && position === 'bottom')\r\n                allowableKeys.push('1'); // Если есть спрятанные записи, то в массив добавляется объект, чтобы выделить место в легенде для индикатора переполнения\r\n            const legendSize = _featuresModel_legendModel_legendModel__WEBPACK_IMPORTED_MODULE_2__.LegendModel.getLegendSize(config.options.type, position, allowableKeys, designerConfig.canvas.legendBlock.maxWidth, config.canvas.size, legendBlockModel);\r\n            margin[position] += legendSize + legendBlockModel[position].margin[position];\r\n            legendBlockModel[position].size = legendSize;\r\n            options.legend.position = position;\r\n        }\r\n    }\r\n    static recalcMarginByVerticalAxisLabel(margin, config, designerConfig, dataScope) {\r\n        if ((config.options.type === '2d' || config.options.type === 'interval') && config.options.orientation === 'vertical') {\r\n            const axisLabelSize = _featuresModel_axisModel__WEBPACK_IMPORTED_MODULE_0__.AxisModel.getLabelSize(designerConfig.canvas.axisLabel.maxSize.main, dataScope.allowableKeys);\r\n            const axisConfig = _featuresModel_axisModel__WEBPACK_IMPORTED_MODULE_0__.AxisModel.getKeyAxisLabelPosition(margin, config.canvas.size, dataScope.allowableKeys.length);\r\n            const marginOrient = config.options.axis.key.position === 'end' ? 'bottom' : 'top';\r\n            if (axisConfig === 'rotated')\r\n                margin[marginOrient] += (axisLabelSize.width - axisLabelSize.height);\r\n        }\r\n    }\r\n    static getHorizontalMarginByAxisLabels(labelsMaxWidth, axis, data, options) {\r\n        const keyAxisOrient = _featuresModel_axisModel__WEBPACK_IMPORTED_MODULE_0__.AxisModel.getAxisOrient(_modelBuilder__WEBPACK_IMPORTED_MODULE_3__.AxisType.Key, options.orientation, axis.key.position);\r\n        let labelsTexts;\r\n        if (keyAxisOrient === 'left' || keyAxisOrient === 'right') {\r\n            labelsTexts = _dataManagerModel__WEBPACK_IMPORTED_MODULE_1__.DataManagerModel.getDataValuesByKeyField(data, options.data.dataSource, options.data.keyField.name);\r\n        }\r\n        else {\r\n            labelsTexts = ['0000'];\r\n        }\r\n        return _featuresModel_axisModel__WEBPACK_IMPORTED_MODULE_0__.AxisModel.getLabelSize(labelsMaxWidth, labelsTexts);\r\n    }\r\n    static recalcVerticalMarginByAxisLabelHeight(labelSize, margin, orientation, axis) {\r\n        const keyAxisOrient = _featuresModel_axisModel__WEBPACK_IMPORTED_MODULE_0__.AxisModel.getAxisOrient(_modelBuilder__WEBPACK_IMPORTED_MODULE_3__.AxisType.Key, orientation, axis.key.position);\r\n        const valueAxisOrient = _featuresModel_axisModel__WEBPACK_IMPORTED_MODULE_0__.AxisModel.getAxisOrient(_modelBuilder__WEBPACK_IMPORTED_MODULE_3__.AxisType.Value, orientation, axis.value.position);\r\n        if ((keyAxisOrient === 'bottom' || keyAxisOrient === 'top')) {\r\n            if (axis.key.visibility)\r\n                margin[keyAxisOrient] += labelSize.height + AXIS_HORIZONTAL_LABEL_PADDING;\r\n        }\r\n        else if (axis.value.visibility) {\r\n            margin[valueAxisOrient] += labelSize.height + AXIS_HORIZONTAL_LABEL_PADDING;\r\n        }\r\n    }\r\n    static recalcHorizontalMarginByAxisLabelWidth(labelSize, margin, orientation, axis, isShow) {\r\n        const keyAxisOrient = _featuresModel_axisModel__WEBPACK_IMPORTED_MODULE_0__.AxisModel.getAxisOrient(_modelBuilder__WEBPACK_IMPORTED_MODULE_3__.AxisType.Key, orientation, axis.key.position);\r\n        const valueAxisOrient = _featuresModel_axisModel__WEBPACK_IMPORTED_MODULE_0__.AxisModel.getAxisOrient(_modelBuilder__WEBPACK_IMPORTED_MODULE_3__.AxisType.Value, orientation, axis.value.position);\r\n        if ((keyAxisOrient === 'left' || keyAxisOrient === 'right') && isShow && axis.key.visibility) {\r\n            margin[keyAxisOrient] += labelSize.width + AXIS_VERTICAL_LABEL_PADDING;\r\n        }\r\n        else if ((valueAxisOrient === 'left' || valueAxisOrient === 'right') && axis.value.visibility) {\r\n            margin[valueAxisOrient] += labelSize.width + AXIS_VERTICAL_LABEL_PADDING;\r\n        }\r\n    }\r\n    static recalcMarginWithLegend(margin, config, legendMaxWidth, legendBlockModel, data) {\r\n        const legendPosition = _featuresModel_legendModel_legendModel__WEBPACK_IMPORTED_MODULE_2__.LegendModel.getLegendModel(config.options.type, config.options.legend.show, config.canvas.size, margin).position;\r\n        if (legendPosition !== 'off') {\r\n            const legendItemsContent = this.getLegendItemsContent(config.options, data);\r\n            const legendSize = _featuresModel_legendModel_legendModel__WEBPACK_IMPORTED_MODULE_2__.LegendModel.getLegendSize(config.options.type, legendPosition, legendItemsContent, legendMaxWidth, config.canvas.size, legendBlockModel);\r\n            margin[legendPosition] += legendSize;\r\n            if (legendSize !== 0)\r\n                this.appendToGlobalMarginValuesLegendMargin(margin, legendPosition, legendBlockModel);\r\n            legendBlockModel[legendPosition].size = legendSize;\r\n        }\r\n    }\r\n    static getLegendItemsContent(options, data) {\r\n        if (options.type === '2d') {\r\n            let texts = [];\r\n            options.charts.forEach(chart => {\r\n                texts = texts.concat(chart.data.valueFields.map(field => field.title));\r\n            });\r\n            return texts;\r\n        }\r\n        else if (options.type === 'polar') {\r\n            return _dataManagerModel__WEBPACK_IMPORTED_MODULE_1__.DataManagerModel.getDataValuesByKeyField(data, options.data.dataSource, options.data.keyField.name);\r\n        }\r\n        else if (options.type === 'interval') {\r\n            return options.charts.map(chart => chart.data.valueField1.name);\r\n        }\r\n    }\r\n    static appendToGlobalMarginValuesLegendMargin(margin, position, legendBlockModel) {\r\n        if (position === 'left' || position === 'right')\r\n            margin[position] += legendBlockModel[position].margin.left + legendBlockModel[position].margin.right;\r\n        else\r\n            margin[position] += legendBlockModel[position].margin.top + legendBlockModel[position].margin.bottom;\r\n    }\r\n    static clearMarginByLegendBlockPosition(margin, legendBlockModel) {\r\n        ['left', 'right', 'top', 'bottom'].forEach((position) => {\r\n            margin[position] -= legendBlockModel[position].size === 0\r\n                ? 0\r\n                : legendBlockModel[position].size + legendBlockModel[position].margin[position];\r\n        });\r\n    }\r\n    static recalcMarginByTitle(margin, titleBlockModel) {\r\n        margin.top += titleBlockModel.margin.top + titleBlockModel.size;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/model/marginModel.ts?");

/***/ }),

/***/ "./src/model/modelBuilder.ts":
/*!***********************************!*\
  !*** ./src/model/modelBuilder.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AxisType\": () => /* binding */ AxisType,\n/* harmony export */   \"CLASSES\": () => /* binding */ CLASSES,\n/* harmony export */   \"assembleModel\": () => /* binding */ assembleModel,\n/* harmony export */   \"getPreparedData\": () => /* binding */ getPreparedData,\n/* harmony export */   \"getUpdatedModel\": () => /* binding */ getUpdatedModel\n/* harmony export */ });\n/* harmony import */ var _marginModel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./marginModel */ \"./src/model/marginModel.ts\");\n/* harmony import */ var _notations_twoDimensionalModel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./notations/twoDimensionalModel */ \"./src/model/notations/twoDimensionalModel.ts\");\n/* harmony import */ var _notations_polarModel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./notations/polarModel */ \"./src/model/notations/polarModel.ts\");\n/* harmony import */ var _dataManagerModel__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dataManagerModel */ \"./src/model/dataManagerModel.ts\");\n/* harmony import */ var _notations_intervalModel__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./notations/intervalModel */ \"./src/model/notations/intervalModel.ts\");\n/* harmony import */ var _featuresModel_otherComponents__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./featuresModel/otherComponents */ \"./src/model/featuresModel/otherComponents.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\nvar AxisType;\r\n(function (AxisType) {\r\n    AxisType[AxisType[\"Key\"] = 0] = \"Key\";\r\n    AxisType[AxisType[\"Value\"] = 1] = \"Value\";\r\n})(AxisType || (AxisType = {}));\r\nconst CLASSES = {\r\n    dataLabel: 'data-label',\r\n    legendLabel: 'legend-label',\r\n    legendColor: 'legend-circle',\r\n    legendItem: 'legend-item',\r\n};\r\nfunction getBlockCanvas(config) {\r\n    return {\r\n        size: {\r\n            width: config.canvas.size.width,\r\n            height: config.canvas.size.height\r\n        },\r\n        cssClass: config.canvas.class\r\n    };\r\n}\r\nfunction getChartBlock(margin) {\r\n    return {\r\n        margin\r\n    };\r\n}\r\nfunction getOptions(config, designerConfig, margin, dataScope, data) {\r\n    if (config.options.type === '2d') {\r\n        return _notations_twoDimensionalModel__WEBPACK_IMPORTED_MODULE_1__.TwoDimensionalModel.getOptions(config, designerConfig, margin, dataScope, data);\r\n    }\r\n    else if (config.options.type === 'polar') {\r\n        return _notations_polarModel__WEBPACK_IMPORTED_MODULE_2__.PolarModel.getOptions(config, data, margin, designerConfig);\r\n    }\r\n    else if (config.options.type === 'interval') {\r\n        return _notations_intervalModel__WEBPACK_IMPORTED_MODULE_4__.IntervalModel.getOptions(config, designerConfig, margin, dataScope, data);\r\n    }\r\n}\r\nfunction getDataSettings(dataScope, designerConfig) {\r\n    return {\r\n        scope: dataScope,\r\n        format: getDataFormat(designerConfig)\r\n    };\r\n}\r\nfunction getChartSettings(barSettings, donutSettings) {\r\n    return {\r\n        bar: Object.assign({}, barSettings),\r\n        donut: Object.assign({}, donutSettings)\r\n    };\r\n}\r\nfunction getDataFormat(designerConfig) {\r\n    return {\r\n        formatters: designerConfig.dataFormat.formatters\r\n    };\r\n}\r\nfunction getTransitions(designerConfig) {\r\n    return designerConfig.transitions;\r\n}\r\nfunction roundMargin(margin) {\r\n    margin.top = Math.ceil(margin.top);\r\n    margin.bottom = Math.ceil(margin.bottom);\r\n    margin.left = Math.ceil(margin.left);\r\n    margin.right = Math.ceil(margin.right);\r\n}\r\nfunction assembleModel(config, data, designerConfig) {\r\n    if (!data || Object.keys(data).length === 0)\r\n        return {\r\n            blockCanvas: getBlockCanvas(config),\r\n            chartBlock: null,\r\n            otherComponents: null,\r\n            options: null,\r\n            dataSettings: null,\r\n            chartSettings: null\r\n        };\r\n    resetFalsyValues(data, config.options.data.keyField.name);\r\n    const otherComponents = _featuresModel_otherComponents__WEBPACK_IMPORTED_MODULE_5__.OtherComponentsModel.getOtherComponentsModel(designerConfig.elementsOptions);\r\n    const margin = _marginModel__WEBPACK_IMPORTED_MODULE_0__.MarginModel.getMargin(designerConfig, config, otherComponents, data);\r\n    const dataScope = _dataManagerModel__WEBPACK_IMPORTED_MODULE_3__.DataManagerModel.getDataScope(config, margin, data, designerConfig, otherComponents.legendBlock);\r\n    const preparedData = _dataManagerModel__WEBPACK_IMPORTED_MODULE_3__.DataManagerModel.getPreparedData(data, dataScope.allowableKeys, config);\r\n    if (config.options.type === '2d' && config.options.axis.key.visibility)\r\n        _marginModel__WEBPACK_IMPORTED_MODULE_0__.MarginModel.recalcMarginByVerticalAxisLabel(margin, config, designerConfig, dataScope);\r\n    const blockCanvas = getBlockCanvas(config);\r\n    const chartBlock = getChartBlock(margin);\r\n    const options = getOptions(config, designerConfig, margin, dataScope, preparedData);\r\n    const dataSettings = getDataSettings(dataScope, designerConfig);\r\n    const chartSettings = getChartSettings(designerConfig.canvas.chartOptions.bar, designerConfig.canvas.chartOptions.donut);\r\n    const transitions = getTransitions(designerConfig);\r\n    if (options.type === 'polar')\r\n        _marginModel__WEBPACK_IMPORTED_MODULE_0__.MarginModel.recalcPolarMarginWithScopedData(margin, config.canvas.size, designerConfig, config, otherComponents.legendBlock, dataScope, options);\r\n    roundMargin(margin);\r\n    return {\r\n        blockCanvas,\r\n        chartBlock,\r\n        otherComponents,\r\n        options,\r\n        dataSettings,\r\n        chartSettings,\r\n        transitions\r\n    };\r\n}\r\nfunction resetFalsyValues(data, keyFieldName) {\r\n    for (let setName in data) {\r\n        data[setName].forEach(dataRow => {\r\n            for (let fieldName in dataRow) {\r\n                if (fieldName === keyFieldName && !dataRow[fieldName]) {\r\n                    dataRow[fieldName] = '';\r\n                }\r\n                else if (dataRow[fieldName] !== 0 && !dataRow[fieldName]) {\r\n                    dataRow[fieldName] = 0;\r\n                }\r\n            }\r\n        });\r\n    }\r\n}\r\nfunction getPreparedData(model, data, config) {\r\n    resetFalsyValues(data, config.options.data.keyField.name);\r\n    if (!model || Object.keys(model).length === 0 || !data || Object.keys(data).length === 0)\r\n        return null;\r\n    const preparedData = _dataManagerModel__WEBPACK_IMPORTED_MODULE_3__.DataManagerModel.getPreparedData(data, model.dataSettings.scope.allowableKeys, config);\r\n    return preparedData;\r\n}\r\nfunction getUpdatedModel(config, data, designerConfig) {\r\n    return assembleModel(config, data, designerConfig);\r\n}\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/model/modelBuilder.ts?");

/***/ }),

/***/ "./src/model/modelHelper.ts":
/*!**********************************!*\
  !*** ./src/model/modelHelper.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ModelHelper\": () => /* binding */ ModelHelper\n/* harmony export */ });\nclass ModelHelper {\r\n    static getSum(items) {\r\n        return items.reduce((acc, item) => acc + item, 0);\r\n    }\r\n    static getMinAndMaxOfIntervalData(data, dataSource, charts) {\r\n        let min = data[dataSource][0][charts[0].data.valueField1.name];\r\n        let max = data[dataSource][0][charts[0].data.valueField1.name];\r\n        charts.forEach(chart => {\r\n            const chartData = data[dataSource];\r\n            const valueField1 = chart.data.valueField1.name;\r\n            const valueField2 = chart.data.valueField2.name;\r\n            chartData.forEach(dataRow => {\r\n                if (dataRow[valueField1] > max)\r\n                    max = dataRow[valueField1];\r\n                if (dataRow[valueField1] < min)\r\n                    min = dataRow[valueField1];\r\n                if (dataRow[valueField2] > max)\r\n                    max = dataRow[valueField2];\r\n                if (dataRow[valueField2] < min)\r\n                    min = dataRow[valueField2];\r\n            });\r\n        });\r\n        return [min, max];\r\n    }\r\n    static getUniqueValues(values) {\r\n        const uniqueValues = values.filter((keyValue, index, self) => self.indexOf(keyValue) === index);\r\n        return uniqueValues;\r\n    }\r\n    static getStringScore(word) {\r\n        // lower case letter width ~ 0.74 from upper case width.\r\n        // Number width == lower case letter width\r\n        let score = 0;\r\n        const upperLetterScore = 1;\r\n        const lowerLetterScore = 0.74;\r\n        for (let i = 0; i < word.length; i++) {\r\n            if (word[i].toUpperCase() === word[i] && parseFloat(word[i]).toString() !== word[i])\r\n                score += upperLetterScore;\r\n            else\r\n                score += lowerLetterScore;\r\n        }\r\n        return score;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/model/modelHelper.ts?");

/***/ }),

/***/ "./src/model/notations/intervalModel.ts":
/*!**********************************************!*\
  !*** ./src/model/notations/intervalModel.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"IntervalModel\": () => /* binding */ IntervalModel\n/* harmony export */ });\n/* harmony import */ var _featuresModel_axisModel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../featuresModel/axisModel */ \"./src/model/featuresModel/axisModel.ts\");\n/* harmony import */ var _chartStyleModel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../chartStyleModel */ \"./src/model/chartStyleModel.ts\");\n/* harmony import */ var _dataManagerModel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dataManagerModel */ \"./src/model/dataManagerModel.ts\");\n/* harmony import */ var _featuresModel_legendModel_legendModel__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../featuresModel/legendModel/legendModel */ \"./src/model/featuresModel/legendModel/legendModel.ts\");\n/* harmony import */ var _modelBuilder__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../modelBuilder */ \"./src/model/modelBuilder.ts\");\n/* harmony import */ var _featuresModel_scaleModel__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../featuresModel/scaleModel */ \"./src/model/featuresModel/scaleModel.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\nclass IntervalModel {\r\n    static getOptions(config, designerConfig, margin, dataScope, data) {\r\n        const options = config.options;\r\n        return {\r\n            legend: _featuresModel_legendModel_legendModel__WEBPACK_IMPORTED_MODULE_3__.LegendModel.getLegendModel(config.options.type, config.options.legend.show, config.canvas.size, margin),\r\n            title: options.title,\r\n            selectable: options.selectable,\r\n            orient: options.orientation,\r\n            scale: {\r\n                key: {\r\n                    domain: dataScope.allowableKeys,\r\n                    range: {\r\n                        start: 0,\r\n                        end: _featuresModel_scaleModel__WEBPACK_IMPORTED_MODULE_5__.ScaleModel.getRangePeek(_featuresModel_scaleModel__WEBPACK_IMPORTED_MODULE_5__.ScaleType.Key, options.orientation, margin, config.canvas.size)\r\n                    },\r\n                    type: _featuresModel_scaleModel__WEBPACK_IMPORTED_MODULE_5__.ScaleModel.getScaleKeyType(options.charts),\r\n                    elementsAmount: options.charts.length\r\n                },\r\n                value: {\r\n                    domain: _featuresModel_scaleModel__WEBPACK_IMPORTED_MODULE_5__.ScaleModel.getDateValueDomain(data, options.charts, options.axis.key.position, options.data.dataSource),\r\n                    range: {\r\n                        start: 0,\r\n                        end: _featuresModel_scaleModel__WEBPACK_IMPORTED_MODULE_5__.ScaleModel.getRangePeek(_featuresModel_scaleModel__WEBPACK_IMPORTED_MODULE_5__.ScaleType.Value, options.orientation, margin, config.canvas.size)\r\n                    },\r\n                    type: _featuresModel_scaleModel__WEBPACK_IMPORTED_MODULE_5__.ScaleModel.getScaleValueType(options.charts)\r\n                }\r\n            },\r\n            axis: {\r\n                key: {\r\n                    type: 'key',\r\n                    orient: _featuresModel_axisModel__WEBPACK_IMPORTED_MODULE_0__.AxisModel.getAxisOrient(_modelBuilder__WEBPACK_IMPORTED_MODULE_4__.AxisType.Key, options.orientation, options.axis.key.position),\r\n                    translate: {\r\n                        translateX: _featuresModel_axisModel__WEBPACK_IMPORTED_MODULE_0__.AxisModel.getAxisTranslateX(_modelBuilder__WEBPACK_IMPORTED_MODULE_4__.AxisType.Key, options.orientation, options.axis.key.position, margin, config.canvas.size.width),\r\n                        translateY: _featuresModel_axisModel__WEBPACK_IMPORTED_MODULE_0__.AxisModel.getAxisTranslateY(_modelBuilder__WEBPACK_IMPORTED_MODULE_4__.AxisType.Key, options.orientation, options.axis.key.position, margin, config.canvas.size.height)\r\n                    },\r\n                    cssClass: 'key-axis',\r\n                    ticks: options.axis.key.ticks,\r\n                    labels: {\r\n                        maxSize: _featuresModel_axisModel__WEBPACK_IMPORTED_MODULE_0__.AxisModel.getLabelSize(designerConfig.canvas.axisLabel.maxSize.main, data[options.data.dataSource].map(d => d[options.data.keyField.name])).width,\r\n                        positition: _featuresModel_axisModel__WEBPACK_IMPORTED_MODULE_0__.AxisModel.getKeyAxisLabelPosition(margin, config.canvas.size, _dataManagerModel__WEBPACK_IMPORTED_MODULE_2__.DataManagerModel.getDataValuesByKeyField(data, options.data.dataSource, options.data.keyField.name).length),\r\n                        visible: true\r\n                    },\r\n                    visibility: options.axis.key.visibility\r\n                },\r\n                value: {\r\n                    type: 'value',\r\n                    orient: _featuresModel_axisModel__WEBPACK_IMPORTED_MODULE_0__.AxisModel.getAxisOrient(_modelBuilder__WEBPACK_IMPORTED_MODULE_4__.AxisType.Value, options.orientation, options.axis.value.position),\r\n                    translate: {\r\n                        translateX: _featuresModel_axisModel__WEBPACK_IMPORTED_MODULE_0__.AxisModel.getAxisTranslateX(_modelBuilder__WEBPACK_IMPORTED_MODULE_4__.AxisType.Value, options.orientation, options.axis.value.position, margin, config.canvas.size.width),\r\n                        translateY: _featuresModel_axisModel__WEBPACK_IMPORTED_MODULE_0__.AxisModel.getAxisTranslateY(_modelBuilder__WEBPACK_IMPORTED_MODULE_4__.AxisType.Value, options.orientation, options.axis.value.position, margin, config.canvas.size.height)\r\n                    },\r\n                    cssClass: 'value-axis',\r\n                    ticks: options.axis.value.ticks,\r\n                    labels: {\r\n                        maxSize: designerConfig.canvas.axisLabel.maxSize.main,\r\n                        positition: 'straight',\r\n                        visible: true\r\n                    },\r\n                    visibility: options.axis.value.visibility\r\n                }\r\n            },\r\n            data: Object.assign({}, options.data),\r\n            type: options.type,\r\n            charts: this.getChartsModel(options.charts, designerConfig.chartStyle),\r\n            additionalElements: this.getAdditionalElements(options)\r\n        };\r\n    }\r\n    static getAdditionalElements(options) {\r\n        return {\r\n            gridLine: options.additionalElements.gridLine\r\n        };\r\n    }\r\n    static getChartsModel(charts, chartStyleConfig) {\r\n        const chartsModel = [];\r\n        charts.forEach((chart, index) => {\r\n            chartsModel.push({\r\n                type: chart.type,\r\n                data: Object.assign({}, chart.data),\r\n                tooltip: chart.tooltip,\r\n                cssClasses: _chartStyleModel__WEBPACK_IMPORTED_MODULE_1__.ChartStyleModel.getCssClasses(index),\r\n                style: _chartStyleModel__WEBPACK_IMPORTED_MODULE_1__.ChartStyleModel.getChartStyle(charts.length, chartStyleConfig)\r\n            });\r\n        });\r\n        return chartsModel;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/model/notations/intervalModel.ts?");

/***/ }),

/***/ "./src/model/notations/polarModel.ts":
/*!*******************************************!*\
  !*** ./src/model/notations/polarModel.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PolarModel\": () => /* binding */ PolarModel\n/* harmony export */ });\n/* harmony import */ var _chartStyleModel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../chartStyleModel */ \"./src/model/chartStyleModel.ts\");\n/* harmony import */ var _featuresModel_legendModel_legendModel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../featuresModel/legendModel/legendModel */ \"./src/model/featuresModel/legendModel/legendModel.ts\");\n\r\n\r\nclass PolarModel {\r\n    static getOptions(config, data, margin, designerConfig) {\r\n        const options = config.options;\r\n        return {\r\n            type: options.type,\r\n            selectable: options.selectable,\r\n            title: options.title,\r\n            data: Object.assign({}, options.data),\r\n            charts: this.getChartsModel(options.charts, data[options.data.dataSource].length, designerConfig.chartStyle),\r\n            legend: _featuresModel_legendModel_legendModel__WEBPACK_IMPORTED_MODULE_1__.LegendModel.getLegendModel(config.options.type, config.options.legend.show, config.canvas.size, margin)\r\n        };\r\n    }\r\n    static getChartsModel(charts, dataLength, chartStyleConfig) {\r\n        const chartsModel = [];\r\n        charts.forEach((chart, index) => {\r\n            chartsModel.push({\r\n                type: chart.type,\r\n                data: Object.assign({}, chart.data),\r\n                tooltip: chart.tooltip,\r\n                cssClasses: _chartStyleModel__WEBPACK_IMPORTED_MODULE_0__.ChartStyleModel.getCssClasses(index),\r\n                style: _chartStyleModel__WEBPACK_IMPORTED_MODULE_0__.ChartStyleModel.getChartStyle(dataLength, chartStyleConfig)\r\n            });\r\n        });\r\n        return chartsModel;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/model/notations/polarModel.ts?");

/***/ }),

/***/ "./src/model/notations/twoDimensionalModel.ts":
/*!****************************************************!*\
  !*** ./src/model/notations/twoDimensionalModel.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TwoDimensionalModel\": () => /* binding */ TwoDimensionalModel\n/* harmony export */ });\n/* harmony import */ var _chartStyleModel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../chartStyleModel */ \"./src/model/chartStyleModel.ts\");\n/* harmony import */ var _featuresModel_axisModel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../featuresModel/axisModel */ \"./src/model/featuresModel/axisModel.ts\");\n/* harmony import */ var _featuresModel_legendModel_legendModel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../featuresModel/legendModel/legendModel */ \"./src/model/featuresModel/legendModel/legendModel.ts\");\n/* harmony import */ var _featuresModel_scaleModel__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../featuresModel/scaleModel */ \"./src/model/featuresModel/scaleModel.ts\");\n\r\n\r\n\r\n\r\nclass TwoDimensionalModel {\r\n    static getOptions(config, designerConfig, margin, dataScope, data) {\r\n        const options = config.options;\r\n        return {\r\n            legend: _featuresModel_legendModel_legendModel__WEBPACK_IMPORTED_MODULE_2__.LegendModel.getLegendModel(config.options.type, config.options.legend.show, config.canvas.size, margin),\r\n            title: options.title,\r\n            selectable: options.selectable,\r\n            orient: options.orientation,\r\n            scale: {\r\n                key: _featuresModel_scaleModel__WEBPACK_IMPORTED_MODULE_3__.ScaleModel.getScaleKey(dataScope.allowableKeys, options.orientation, margin, config.canvas.size, options.charts, this.getChartsByType(options.charts, 'bar')),\r\n                value: _featuresModel_scaleModel__WEBPACK_IMPORTED_MODULE_3__.ScaleModel.getScaleLinear(options, data, margin, config.canvas.size)\r\n            },\r\n            axis: {\r\n                key: _featuresModel_axisModel__WEBPACK_IMPORTED_MODULE_1__.AxisModel.getKeyAxis(options.charts, data, options.data, options.orientation, options.axis.key, designerConfig.canvas.axisLabel, margin, config.canvas.size),\r\n                value: _featuresModel_axisModel__WEBPACK_IMPORTED_MODULE_1__.AxisModel.getValueAxis(options.orientation, options.axis.value, designerConfig.canvas.axisLabel, margin, config.canvas.size)\r\n            },\r\n            type: options.type,\r\n            data: Object.assign({}, options.data),\r\n            charts: this.getChartsModel(options.charts, options.orientation, designerConfig.chartStyle),\r\n            additionalElements: this.getAdditionalElements(options)\r\n        };\r\n    }\r\n    static getChartsEmbeddedLabelsFlag(charts, chartOrientation) {\r\n        // Если НЕ найден хотя бы один чарт, который сегментированный или хотя бы один НЕ бар чарт, то лейблы можно прятать\r\n        return charts.findIndex(chart => chart.isSegmented || chart.type !== 'bar') === -1\r\n            && chartOrientation === 'horizontal'\r\n            && charts.length === this.findChartsWithEmbeddedKeyLabels(charts).length;\r\n    }\r\n    /**\r\n     * Сортирует список чартов в порядке: area - bar - line.\r\n     * Используется для того, чтобы при рендере графики с наибольшей площадью (area) не перекрывали графики с меньшей площадью (bar, line).\r\n     * @param charts Чарты из конфига\r\n     */\r\n    static sortCharts(charts) {\r\n        const chartOrder = ['area', 'bar', 'line'];\r\n        charts.sort((chart1, chart2) => chartOrder.indexOf(chart1.type) - chartOrder.indexOf(chart2.type));\r\n    }\r\n    static getChartsModel(charts, chartOrientation, chartStyleConfig) {\r\n        this.sortCharts(charts);\r\n        const chartsModel = [];\r\n        charts.forEach((chart, index) => {\r\n            chartsModel.push({\r\n                type: chart.type,\r\n                isSegmented: chart.isSegmented,\r\n                data: Object.assign({}, chart.data),\r\n                tooltip: chart.tooltip,\r\n                cssClasses: _chartStyleModel__WEBPACK_IMPORTED_MODULE_0__.ChartStyleModel.getCssClasses(index),\r\n                style: _chartStyleModel__WEBPACK_IMPORTED_MODULE_0__.ChartStyleModel.get2DChartStyle(charts.length, chart.type, this.getChartsValueFieldsAmount(charts), index, chart.isSegmented, chartStyleConfig),\r\n                embeddedLabels: this.getEmbeddedLabelType(chart, chartOrientation),\r\n                markersOptions: chart.markers,\r\n                index\r\n            });\r\n        });\r\n        return chartsModel;\r\n    }\r\n    static findChartsWithEmbeddedKeyLabels(charts) {\r\n        const chartsWithEmbeddedLabels = [];\r\n        charts.forEach(chart => {\r\n            if (chart.type === 'bar' && chart.embeddedLabels === 'key')\r\n                chartsWithEmbeddedLabels.push(chart);\r\n        });\r\n        return chartsWithEmbeddedLabels;\r\n    }\r\n    static getEmbeddedLabelType(currentChart, chartOrientation) {\r\n        if (chartOrientation === 'horizontal' && currentChart.type === 'bar')\r\n            return currentChart.embeddedLabels;\r\n        return 'none';\r\n    }\r\n    static getAdditionalElements(options) {\r\n        return {\r\n            gridLine: options.additionalElements.gridLine\r\n        };\r\n    }\r\n    static getChartsByType(charts, type) {\r\n        return charts.filter(chart => chart.type === type);\r\n    }\r\n    static getChartsValueFieldsAmount(charts) {\r\n        return charts.map(chart => chart.data.valueFields.length);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/model/notations/twoDimensionalModel.ts?");

/***/ })

}]);